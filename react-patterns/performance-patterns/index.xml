<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Performance Patterns 性能模式 on codthing</title>
    <link>https://codthing.github.io/react-patterns/performance-patterns/</link>
    <description>Recent content in Performance Patterns 性能模式 on codthing</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko</language>
    <copyright>&amp;copy;{year}, codthing</copyright>
    <lastBuildDate>Tue, 28 Jan 2020 00:34:39 +0900</lastBuildDate>
    
        <atom:link href="https://codthing.github.io/react-patterns/performance-patterns/index.xml" rel="self" type="application/rss+xml" />
    
    
    
      
      <item>
        <title>优化加载顺序</title>
        <link>https://codthing.github.io/react-patterns/performance-patterns/loading-sequence/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://codthing.github.io/react-patterns/performance-patterns/loading-sequence/</guid>
        <description>注意：本文深受 Chrome 中 Aurora 团队的见解的影响，尤其是 Shubhie Panicker，他一直在研究最佳加载顺序。 在每个成功的网页加载中，一些关键组件和资源会在适当</description>
      </item>
      
      <item>
        <title>静态导入</title>
        <link>https://codthing.github.io/react-patterns/performance-patterns/static-import/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://codthing.github.io/react-patterns/performance-patterns/static-import/</guid>
        <description>import 关键字允许导入由另一个模块导出的代码。 默认情况下，静态导入的所有模块都会添加到初始包中。 使用默认的 ES2015 导入语法 import module from &#39;module&#39; 导入的模块是静态导入的</description>
      </item>
      
      <item>
        <title>动态导入</title>
        <link>https://codthing.github.io/react-patterns/performance-patterns/dynamic-import/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://codthing.github.io/react-patterns/performance-patterns/dynamic-import/</guid>
        <description>在聊天应用程序中，有四个主要部分：UserInfo，ChatList，ChatInput和EmojiPicker。 但是，在初始页面加载时，只</description>
      </item>
      
      <item>
        <title>导入可见性</title>
        <link>https://codthing.github.io/react-patterns/performance-patterns/import-on-visibility/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://codthing.github.io/react-patterns/performance-patterns/import-on-visibility/</guid>
        <description>除了用户交互，经常有在初始页面上不可见的组件。 一个很好的例子是延迟加载在视口中不直接可见的图像，但只有在用户向下滚动时才会加载。 由于不会立即</description>
      </item>
      
      <item>
        <title>交互导入</title>
        <link>https://codthing.github.io/react-patterns/performance-patterns/import-on-interaction/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://codthing.github.io/react-patterns/performance-patterns/import-on-interaction/</guid>
        <description>页面可能包含并非立即需要的组件或资源的代码或数据。 例如，用户不会看到部分用户界面，除非他们单击或滚动页面的某些部分。 这适用于编写的多种第一方</description>
      </item>
      
      <item>
        <title>基于路由的拆分</title>
        <link>https://codthing.github.io/react-patterns/performance-patterns/route-base/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://codthing.github.io/react-patterns/performance-patterns/route-base/</guid>
        <description>可以通过添加基于路由的拆分来请求仅特定路由需要的资源。 通过将 React Suspense 或 loadable-component 与 react-router 等库结合，可以根据当前路由动态加载组件。 1 2 3 4 5 6 7 8 9 10 11 12 13 14</description>
      </item>
      
      <item>
        <title>捆绑拆分</title>
        <link>https://codthing.github.io/react-patterns/performance-patterns/bundle-splitting/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://codthing.github.io/react-patterns/performance-patterns/bundle-splitting/</guid>
        <description>在构建现代 Web 应用程序时， 诸如 Webpack 或 Rollup 之类的打包器会获取应用程序的源代码，并将其捆绑到一个或多个包中。 当用户访问网站时，会请求并加载包，以便将数</description>
      </item>
      
      <item>
        <title>PRPL模式</title>
        <link>https://codthing.github.io/react-patterns/performance-patterns/prpl/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://codthing.github.io/react-patterns/performance-patterns/prpl/</guid>
        <description>使应用程序在全球范围内可访问可能是一个挑战！ 我们必须确保应用程序在低端设备和互联网连接较差的地区运行良好。 为了确保应用程序能够在困难的条件下</description>
      </item>
      
      <item>
        <title>摇树 tree-shaking</title>
        <link>https://codthing.github.io/react-patterns/performance-patterns/tree-shaking/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://codthing.github.io/react-patterns/performance-patterns/tree-shaking/</guid>
        <description>我们可能会向 bundle 添加代码，而这些代码在应用程序中的任何地方都没有使用。 可以消除这一段死代码，以减少包的大小，并防止不必要地加载更多数据！ 在将死</description>
      </item>
      
      <item>
        <title>预加载</title>
        <link>https://codthing.github.io/react-patterns/performance-patterns/preload/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://codthing.github.io/react-patterns/performance-patterns/preload/</guid>
        <description>预加载 (&amp;lt;link rel=&amp;quot;preload&amp;quot;&amp;gt;) 是一种浏览器优化，允许更早地请求关键资源（可能发现较晚）。 如果您对如何手动排序关键资源的加载感到满意，它会对 Core Web Vitals 中的加载性能和指</description>
      </item>
      
      <item>
        <title>预取</title>
        <link>https://codthing.github.io/react-patterns/performance-patterns/prefetch/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://codthing.github.io/react-patterns/performance-patterns/prefetch/</guid>
        <description>Prefetch (&amp;lt;link rel=&amp;quot;prefetch&amp;quot;&amp;gt;) 是一种浏览器优化，它允许我们在需要之前获取后续路由或页面可能需要的资源。 预取可以通过几种方式实现。 它可以在 HTML 中声明性地完成（例如在下面</description>
      </item>
      
      <item>
        <title>优化加载第三方</title>
        <link>https://codthing.github.io/react-patterns/performance-patterns/third-party/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://codthing.github.io/react-patterns/performance-patterns/third-party/</guid>
        <description>第三方资源可能会降低网站速度，并且可能是优化的挑战。 可以遵循某些最佳实践来有效地加载或延迟不同类型的第三方。 还可以使用框架级组件，例如 Next.js 脚本</description>
      </item>
      
      <item>
        <title>列表虚拟化</title>
        <link>https://codthing.github.io/react-patterns/performance-patterns/virtual-lists/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://codthing.github.io/react-patterns/performance-patterns/virtual-lists/</guid>
        <description>在本指南中，讨论列表虚拟化（也称为窗口化）。 这是在动态列表中仅呈现可见内容行而不是整个列表的想法。 呈现的行只是完整列表的一小部分，随着用户滚</description>
      </item>
      
      <item>
        <title>压缩 JavaScript</title>
        <link>https://codthing.github.io/react-patterns/performance-patterns/%E5%8E%8B%E7%BC%A9-javascript/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://codthing.github.io/react-patterns/performance-patterns/%E5%8E%8B%E7%BC%A9-javascript/</guid>
        <description>压缩 JavaScript 并密切关注块大小以获得最佳性能。 过高的 JavaScript 包粒度有助于重复数据删除和缓存，但可能会在 50-100 个块范围内受到较差的压缩和影响加载（由于浏览器进程</description>
      </item>
      
    
  </channel>
</rss>