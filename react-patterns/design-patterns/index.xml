<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Design Patterns 设计模式 on codthing</title>
    <link>https://codthing.github.io/react-patterns/design-patterns/</link>
    <description>Recent content in Design Patterns 设计模式 on codthing</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko</language>
    <copyright>&amp;copy;{year}, codthing</copyright>
    <lastBuildDate>Tue, 28 Jan 2020 00:34:39 +0900</lastBuildDate>
    
        <atom:link href="https://codthing.github.io/react-patterns/design-patterns/index.xml" rel="self" type="application/rss+xml" />
    
    
    
      
      <item>
        <title>设计模式介绍</title>
        <link>https://codthing.github.io/react-patterns/design-patterns/design-patterns/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://codthing.github.io/react-patterns/design-patterns/design-patterns/</guid>
        <description>注意：菜单项目中（X）的都为过时或者不建议使用的模式，依然写出来只是为了让我们了解历史 设计模式是软件开发的基本部分， 因为它们为软件设计中经常</description>
      </item>
      
      <item>
        <title>单例模式</title>
        <link>https://codthing.github.io/react-patterns/design-patterns/single-patterns/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://codthing.github.io/react-patterns/design-patterns/single-patterns/</guid>
        <description>单例（统一用名词 Singleton 代替）是可以实例化一次的类，并且可以全局访问。单个实例可以在整个应用程序中共享，非常适合管理应用程序中的全局状态。 计数器案</description>
      </item>
      
      <item>
        <title>代理模式</title>
        <link>https://codthing.github.io/react-patterns/design-patterns/proxy-patterns/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://codthing.github.io/react-patterns/design-patterns/proxy-patterns/</guid>
        <description>使用 Proxy 对象，可以更好地控制与某些对象的交互。 每当与对象交互时，代理对象都可以确定行为，例如当我们获取一个值或设置一个值时。 一般来说，代理是指</description>
      </item>
      
      <item>
        <title>提供者模式</title>
        <link>https://codthing.github.io/react-patterns/design-patterns/provider-pattern/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://codthing.github.io/react-patterns/design-patterns/provider-pattern/</guid>
        <description>在某些情况下，我们希望为应用程序中的许多（如果不是全部）组件提供可用数据。 单向数据流 props 存在的问题 虽然我们可以使用 props 将数据传递给组件，但如果应</description>
      </item>
      
      <item>
        <title>原型模式</title>
        <link>https://codthing.github.io/react-patterns/design-patterns/prototype-pattern/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://codthing.github.io/react-patterns/design-patterns/prototype-pattern/</guid>
        <description>原型模式是一种在许多相同类型的对象之间共享属性的有用方法。 原型prototype是 JavaScript 原生的对象，对象可以通过原型链__proto__访问。 在</description>
      </item>
      
      <item>
        <title>容器/展示模式（X）</title>
        <link>https://codthing.github.io/react-patterns/design-patterns/presentational-container-pattern/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://codthing.github.io/react-patterns/design-patterns/presentational-container-pattern/</guid>
        <description>这是历史遗留问题，所以不建议使用（现在有了Hooks），在这里只是让我们了解这段历史 在 React 中，一种强制分离关注点的方法是通过使用容器/演示模式</description>
      </item>
      
      <item>
        <title>观察者模式</title>
        <link>https://codthing.github.io/react-patterns/design-patterns/observer-pattern/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://codthing.github.io/react-patterns/design-patterns/observer-pattern/</guid>
        <description>使用观察者模式，我们可以将某些对象（观察者）订阅到另一个称为 observable（可观察） 的对象。 每当一个事件发生时，observable 就</description>
      </item>
      
      <item>
        <title>模块模式</title>
        <link>https://codthing.github.io/react-patterns/design-patterns/module-pattern/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://codthing.github.io/react-patterns/design-patterns/module-pattern/</guid>
        <description>随着应用程序和代码库的增长，保持代码的可维护性和分离性变得越来越重要。 模块模式将代码拆分为更小的、可重用的部分。 除了能够将代码拆分为更小的可</description>
      </item>
      
      <item>
        <title>混合模式（X）</title>
        <link>https://codthing.github.io/react-patterns/design-patterns/mixin-pattern/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://codthing.github.io/react-patterns/design-patterns/mixin-pattern/</guid>
        <description>mixin 是一个对象，可以使用它来向另一个对象或类添加可重用的功能，而无需使用继承。 不能单独使用 mixin：它们的唯一目的是在没有继承的情况下向对象</description>
      </item>
      
      <item>
        <title>中介者/中间件模式</title>
        <link>https://codthing.github.io/react-patterns/design-patterns/mediator-pattern/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://codthing.github.io/react-patterns/design-patterns/mediator-pattern/</guid>
        <description>中介者模式使组件可以通过一个中心点相互交互：中介者（也称中介器或中间件）。 中介器不是直接相互交谈，而是接收请求，并将它们转发！ 在 JavaScript 中，中介者</description>
      </item>
      
      <item>
        <title>render 道具模式（X）</title>
        <link>https://codthing.github.io/react-patterns/design-patterns/render-props-pattern/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://codthing.github.io/react-patterns/design-patterns/render-props-pattern/</guid>
        <description>这是历史遗留问题，所以不建议使用（现在有了Hooks），在这里只是让我们了解这段历史 通过 props 道具将 JSX 元素传递给组件 在高阶组件部分，我们看到如果</description>
      </item>
      
      <item>
        <title>Hooks 模式</title>
        <link>https://codthing.github.io/react-patterns/design-patterns/hooks-pattern/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://codthing.github.io/react-patterns/design-patterns/hooks-pattern/</guid>
        <description>React 16.8 引入了一个名为 Hooks 的新功能。 Hooks 使得使用 React 状态和生命周期方法成为可能，而无需使用 ES2015 类组件。 尽管 Hooks 不一定是一种设计模式，但 Hooks 在您的应用程序设计</description>
      </item>
      
      <item>
        <title>HOC 模式（X）</title>
        <link>https://codthing.github.io/react-patterns/design-patterns/hoc-pattern/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://codthing.github.io/react-patterns/design-patterns/hoc-pattern/</guid>
        <description>这是历史遗留问题，所以不建议使用（现在有了Hooks），在这里只是让我们了解这段历史 在我们的应用程序中，我们经常希望在多个组件中使用相同的逻</description>
      </item>
      
      <item>
        <title>亨元模式</title>
        <link>https://codthing.github.io/react-patterns/design-patterns/flyweight-pattern/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://codthing.github.io/react-patterns/design-patterns/flyweight-pattern/</guid>
        <description>当创建大量相似的对象时，享元模式是一种节省内存的有用方法。 图书馆案例 在应用程序中，我们希望用户能够添加书籍。 所有的书都有书名、作者和书号！ 但</description>
      </item>
      
      <item>
        <title>工厂模式</title>
        <link>https://codthing.github.io/react-patterns/design-patterns/factory-pattern/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://codthing.github.io/react-patterns/design-patterns/factory-pattern/</guid>
        <description>使用工厂模式，我们可以使用工厂函数来创建新对象。 当一个函数在不使用 new 关键字的情况下返回一个新对象时，它就是一个工厂函数！ 用户案例 假设我们的应</description>
      </item>
      
      <item>
        <title>复合模式</title>
        <link>https://codthing.github.io/react-patterns/design-patterns/compound-pattern/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://codthing.github.io/react-patterns/design-patterns/compound-pattern/</guid>
        <description>在应用程序中，经常有属于彼此的组件。 它们通过共享状态相互依赖，并共享逻辑。 经常会在选择、下拉组件或菜单项等组件中看到这一点。 复合组件模式允许</description>
      </item>
      
      <item>
        <title>命令模式</title>
        <link>https://codthing.github.io/react-patterns/design-patterns/command-pattern/</link>
        <pubDate>Tue, 28 Jan 2020 00:34:39 +0900</pubDate>
        
        <guid>https://codthing.github.io/react-patterns/design-patterns/command-pattern/</guid>
        <description>使用命令模式，我们可以将执行特定任务的对象与调用该方法的对象解耦。 订单管理案例 假设我们有一个在线食品配送平台。 用户可以下订单、跟踪订单和取消</description>
      </item>
      
    
  </channel>
</rss>